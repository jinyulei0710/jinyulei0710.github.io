<hr>
<p>layout: post<br>title:  “(译)Flutter+Redux- 如何做一个购物清单应用”<br>date:   2019-04-21 15:16:17 +0800<br>categories: </p>
<ul>
<li>Flutter 开发<br>tags:<ul>
<li>状态管理 </li>
<li>Redux</li>
</ul>
</li>
</ul>
<hr>
<p><a href="http://127.0.0.1:4000/flutter/state/management/2019/04/21/Flutter-+-Redux-How-to-make-Shopping-List-App/">原文链接</a></p>
<p>嗨，大家好！在本文中，我想向你展示如何使用Redux创建Flutter应用程序。如果你不知道Flutter是什么，我推荐你阅读我的文章<a href="https://medium.com/@pszklarska/flutter-5-reasons-why-you-may-love-it-55021fdbf1aa">Flutter - 你可能喜欢它的5个理由</a>。但是，如果你知道Flutter是什么，并且你想要创建一个设计良好，易于测试且具有非常可预测的行为的应用程序 - 那么请继续看下去！</p>
<!--more-->


<h2 id="什么是Redux？"><a href="#什么是Redux？" class="headerlink" title="什么是Redux？"></a>什么是Redux？</h2><p>首先，让我们首先解释一下Redux是什么。Redux是一种应用程序架构，最初是为JavaScript构建的，现在用于使用反应式框架构建的应用程序(例如React Native或Flutter)。Redux是由Facebook制作的Flux架构的简化版本。但Redux有什么用呢？基本上，你需要知道三件事：</p>
<ol>
<li>有一个单一的数据源-你的整个应用程序状态只保存在一个地方（被称为仓库）</li>
<li>状态是只读的 - 要修改应用状态，你需要发送一个<code>action</code>，然后新状态就被创建出来的</li>
<li>使用纯方法进行修改 - 纯方法（简单的说，它是没有负效应的方法），采用先前的状态和操作，并返回新状态</li>
</ol>
<p>听起来很酷，但该解决方案的优点是什么？</p>
<ul>
<li>我们控制了状态 - 这意味着我们确切地知道导致状态变化的原因，我们没有重复状态，我们可以轻松地跟踪数据流</li>
<li>纯reducer方法很容易对其进行测试 -我们可以传入状态和<code>action</code>,然后看结果是否正确</li>
<li>应用程序结构清晰 - 我们为<code>action</code>，<code>model</code>，业务逻辑等提供了不同的层 - 因此你要加新功能的时候，你会知道要放在哪里。</li>
<li>对于更复杂的应用程序来说，这是一个很棒的架构 - 您不需要将整个视图树中的状态从父级传递到子级</li>
<li>还有一个……</li>
</ul>
<h3 id="Redux时间旅行"><a href="#Redux时间旅行" class="headerlink" title="Redux时间旅行"></a>Redux时间旅行</h3><p>Redux中有一个很酷的功能 - 🎉时间旅行！使用Redux和适当的工具，您可以随时跟踪应用程序状态，检查实际状态并随时重新创建。看看这个功能到底是什么样的：</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*KL-z2sJRBYEHrnzFASVvVw.gif" alt></p>
<h2 id="Redux相关Widget在一个简单例子上的应用"><a href="#Redux相关Widget在一个简单例子上的应用" class="headerlink" title="Redux相关Widget在一个简单例子上的应用"></a>Redux相关Widget在一个简单例子上的应用</h2><p>所有上述规则使数据在Redux是单向流动的。但是这是什么意思？事实上，这都是由多个<code>action</code>,多个<code>reducer</code>,<code>store</code>以及多个<code>state</code>完成的。让我们想象显示按钮计数器的应用程序：</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*vM852avXATOs1_1Mq7Bn7w.png" alt></p>
<ul>
<li>你的应用程序在开始的有一些状态（点击次数，即0）</li>
<li>基于该状态视图被渲染出来了。</li>
<li>如果用户点击按钮，则会发送<code>action</code>（例如IncrementCounter）</li>
<li><code>reducer</code>收到动作，它知道先前的状态（计数器0），接收动作（IncrementCounter）并且可以返回新状态（计数器1）</li>
<li>你的应用程序有了新状态（计数器1）</li>
<li>基于新状态，视图再次被渲染出来</li>
</ul>
<p>正如你能看到的，通常都是与状态相关的。你有单个应用程序状态，状态对于视图是只读的，并且要创建新的状态的时候你需要发送一个<code>action</code>。发送<code>action</code>会触发<code>reducer</code>创建并发送一个新的应用状态。循环往复。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*S_BZUDym3j0Vxjfi8D21Zg.png" alt>Redux数据流</p>
<h2 id="使用Redux的购物清单应用示例"><a href="#使用Redux的购物清单应用示例" class="headerlink" title="使用Redux的购物清单应用示例"></a>使用Redux的购物清单应用示例</h2><p>让我展示一下Redux在更为复杂例子中的实践。我们将创建一个简单的购物车应用程序。在这个应用程序中，将具有以下功能：</p>
<ul>
<li>添加条目</li>
<li>将条目标记为已选中</li>
<li>就那么多</li>
</ul>
<p>该应用程序的样子是这样的:</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*F_VsjS0EfcjFI5S-fsTvRQ.png" alt><br>你可以在Github上看到<a href="https://github.com/pszklarska/FlutterShoppingCart">该程序的完整代码</a>。</p>
<p>让我们从编码开始吧！ 👇</p>
<h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>在本文中，我不会展示应用程序UI创建的部分。您可以查看这个<a href="https://github.com/pszklarska/FlutterShoppingCart/tree/a8120a23232a05d380384bb377f3994ef65ad221">实现Redux之前的Shopping List应用程序的代码</a>。我们将从这个基础上，把Redux添加到此应用程序中。</p>
<p>如果你之前从未使用过Flutter，我建议您尝试使用Google推出的<a href="https://codelabs.developers.google.com/codelabs/flutter/">Flutter Codelabs</a>。</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>要在Flutter上使用Redux运行，您需要向pubspec.yaml文件添加依赖项：</p>
<pre><code class="yaml"><span class="attr">flutter_redux:</span> <span class="string">^0.5.2</span></code></pre>
<p>您可以在<a href="https://pub.dartlang.org/packages/flutter_redux">flutter_redux</a>包页面上查看最新版本。</p>
<h3 id="模型-Model"><a href="#模型-Model" class="headerlink" title="模型(Model)"></a>模型(Model)</h3><p>我们的应用程序需要管理添加和修改条目，因此我们将使用简单的CartItem模型来存储单个条目的状态。我们的整个应用程序状态将只是多个CartItem组成的列表。如你所见，CartItem只是一个普通的Dart对象</p>
<pre><code class="dart"><span class="class"><span class="keyword">class</span> <span class="title">CartItem</span> </span>{
  <span class="built_in">String</span> name;
  <span class="built_in">bool</span> checked;

  CartItem(<span class="keyword">this</span>.name, <span class="keyword">this</span>.checked);
}</code></pre>
<p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/model/CartItem.dart">注意：这里是这个文件的完整源代码</a></p>
<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a><code>Actions</code></h3><p>首先，我们需要声明<code>action</code>。 Action基本上是可以被调用以更改应用程序状态的任何意图。在我们的应用程序中，我们将有两个<code>action</code>，用于添加和修改条目：</p>
<pre><code class="dart"><span class="class"><span class="keyword">class</span> <span class="title">AddItemAction</span> </span>{
  <span class="keyword">final</span> CartItem item;

  AddItemAction(<span class="keyword">this</span>.item);
}

<span class="class"><span class="keyword">class</span> <span class="title">ToggleItemStateAction</span> </span>{
  <span class="keyword">final</span> CartItem item;

  ToggleItemStateAction(<span class="keyword">this</span>.item);
}
</code></pre>
<p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/redux/actions.dart">注意：这里是这个文件的完整源代码</a></p>
<h3 id="Reducers"><a href="#Reducers" class="headerlink" title="Reducers"></a><code>Reducers</code></h3><p>然后，我们需要告诉我们的应用程序应该如何处理这些操作。这就是Reducer的用途 - 它们只是采用当前的<code>State</code>和<code>action</code>，然后它们会创建并返回新的<code>State</code>。我们将有两种<code>Reducer</code>方法：</p>
<pre><code class="dart"><span class="built_in">List</span>&lt;CartItem&gt; appReducers(<span class="built_in">List</span>&lt;CartItem&gt; items, <span class="keyword">dynamic</span> action) {
  <span class="keyword">if</span> (action <span class="keyword">is</span> AddItemAction) {
    <span class="keyword">return</span> addItem(items, action);
  } <span class="keyword">else</span> <span class="keyword">if</span> (action <span class="keyword">is</span> ToggleItemStateAction) {
    <span class="keyword">return</span> toggleItemState(items, action);
  } 
  <span class="keyword">return</span> items;
}

<span class="built_in">List</span>&lt;CartItem&gt; addItem(<span class="built_in">List</span>&lt;CartItem&gt; items, AddItemAction action) {
  <span class="keyword">return</span> <span class="built_in">List</span>.from(items)..add(action.item);
}

<span class="built_in">List</span>&lt;CartItem&gt; toggleItemState(<span class="built_in">List</span>&lt;CartItem&gt; items, ToggleItemStateAction action) {
  <span class="keyword">return</span> items.map((item) =&gt; item.name == action.item.name ?
    action.item : item).toList();
}</code></pre>
<p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/redux/reducers.dart">注意：这里是这个文件的完整源代码</a></p>
<p>方法<code>appReducers()</code>将<code>action</code>委托给正确的方法。 addItem()和toggleItemState()方法都返回新列表-这个列表就是我们的新应用程序状态。如你所见，您不应修改当前列表，而是每次都创建新的列表。</p>
<h3 id="StoreProvider"><a href="#StoreProvider" class="headerlink" title="StoreProvider"></a>StoreProvider</h3><p>现在，当我们有了<code>action</code>和<code>reducer</code>时，我们需要提供存储应用程序状态的位置。它在Redux中称为仓库，它是我们应用程序的唯一数据源。</p>
<pre><code class="dart"><span class="keyword">void</span> main() {
  <span class="keyword">final</span> store = <span class="keyword">new</span> Store&lt;<span class="built_in">List</span>&lt;CartItem&gt;&gt;(
      appReducers,
      initialState: <span class="keyword">new</span> <span class="built_in">List</span>());

  runApp(<span class="keyword">new</span> FlutterReduxApp(store));
}</code></pre>
<p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/main.dart">注意：这里是这个文件的完整源代码</a></p>
<p>要创建仓库，我们需要传递<code>reducers</code>方法和初始应用程序状态。如果我们创建了仓库，我们必须将它传递给<code>StoreProvider</code>，来告诉我们的应用程序它可以被所有请求应用状态的对象使用：</p>
<pre><code class="dart"><span class="class"><span class="keyword">class</span> <span class="title">FlutterReduxApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>{
  <span class="keyword">final</span> Store&lt;<span class="built_in">List</span>&lt;CartItem&gt;&gt; store;

  FlutterReduxApp(<span class="keyword">this</span>.store);

  <span class="meta">@override</span>
  Widget build(BuildContext context) {
    <span class="keyword">return</span> <span class="keyword">new</span> StoreProvider&lt;<span class="built_in">List</span>&lt;CartItem&gt;&gt;(
      store: store,
      child: <span class="keyword">new</span> ShoppingCartApp(),
    );
  }
}</code></pre>
<p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/main.dart">注意：这里是这个文件的完整源代码</a></p>
<p>在上面的示例中，ShoppingCartApp()是主要的应用程序widget。</p>
<h3 id="StoreConnector"><a href="#StoreConnector" class="headerlink" title="StoreConnector"></a>StoreConnector</h3><p>目前我们拥有除了实际添加和更改条目之外的所有内容都已经做了。那么怎么添加和修改条目呢，我们需要使用<code>StoreConnector</code>。这是一种获取仓库并采取一些行动或读取它的状态的方法。</p>
<p>首先，我们想要读取当前数据并在列表中显示：</p>
<pre><code class="dart"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingList</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>{
  <span class="meta">@override</span>
  Widget build(BuildContext context) {
    <span class="keyword">return</span> <span class="keyword">new</span> StoreConnector&lt;<span class="built_in">List</span>&lt;CartItem&gt;, <span class="built_in">List</span>&lt;CartItem&gt;&gt;(
      converter: (store) =&gt; store.state,
      builder: (context, list) {
        <span class="keyword">return</span> <span class="keyword">new</span> ListView.builder(
            itemCount: list.length,
            itemBuilder: (context, position) =&gt;
                <span class="keyword">new</span> ShoppingListItem(list[position]));
      },
    );
  }
}</code></pre>
<p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/list/shopping_list.dart">注意：这里是这个文件的完整源代码</a></p>
<p>上面的代码使用<code>StoreConnector</code>包装默认的<code>ListView.builder</code>。 <code>StoreConnector</code>可以获取当前应用程序状态（List<cartitem>）并将其与转换器方法映射到任何内容。出于这种情况的目的，它将是相同的状态（List<cartitem>)，因为我们需要这里的整个列表。</cartitem></cartitem></p>
<p>接下来，在builder方法中我们获取到了列表 - 这基本上是来自仓库的CartItems列表，我们可以使用它来构建ListView。</p>
<hr>
<p>好的，很酷 - 我们到读取数据这一步了。现在如何去设置一些数据？</p>
<p>为此，我们还将使用<code>StoreConnector</code>，但方式略有不同。</p>
<pre><code class="dart"><span class="class"><span class="keyword">class</span> <span class="title">AddItemDialog</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>{
  <span class="meta">@override</span>
  Widget build(BuildContext context) {
    <span class="keyword">return</span> <span class="keyword">new</span> StoreConnector&lt;<span class="built_in">List</span>&lt;CartItem&gt;, OnItemAddedCallback&gt;(
        converter: (store) {
      <span class="keyword">return</span> (itemName) =&gt;
          store.dispatch(AddItemAction(CartItem(itemName, <span class="keyword">false</span>)));
    }, builder: (context, callback) {
      <span class="keyword">return</span> <span class="keyword">new</span> AddItemDialogWidget(callback);
    });
  }
}
<span class="keyword">typedef</span> OnItemAddedCallback = <span class="built_in">Function</span>(<span class="built_in">String</span> itemName);</code></pre>
<p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/add_item/add_item_dialog.dart">注意：这里是这个文件的完整源代码</a></p>
<p>我们来看看代码吧。我们使用了<code>StoreConnector</code>，就像前面的例子一样，但这一次，我们将把它映射到OnItemAddedCallback，而不是将CartItems列表映射到同一个列表中。这样我们就可以将回调传递给AddItemDialogWidget，并在用户添加一些新项时调用它：</p>
<pre><code class="dart"><span class="class"><span class="keyword">class</span> <span class="title">AddItemDialogWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AddItemDialogWidget</span>&gt; </span>{
  <span class="built_in">String</span> itemName;

  <span class="keyword">final</span> OnItemAddedCallback callback;
  AddItemDialogWidgetState(<span class="keyword">this</span>.callback);

  <span class="meta">@override</span>
  Widget build(BuildContext context) {
    <span class="keyword">return</span> <span class="keyword">new</span> AlertDialog(
      ...
      actions: &lt;Widget&gt;[
        ...
        <span class="keyword">new</span> FlatButton(
            child: <span class="keyword">const</span> Text(<span class="string">'ADD'</span>),
            onPressed: () {
              ...
              callback(itemName);
            })
      ],
    );
  }
}</code></pre>
<p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/add_item/add_item_dialog.dart">注意：这里是这个文件的完整源代码</a></p>
<p>现在，每次用户按“ADD”按钮时，回调都会发送AddItemAction()事件。</p>
<p>现在，我们可以为切换条目状态做类似的事情：</p>
<pre><code class="dart"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>{
  <span class="keyword">final</span> CartItem item;

  ShoppingListItem(<span class="keyword">this</span>.item);

  <span class="meta">@override</span>
  Widget build(BuildContext context) {
    <span class="keyword">return</span> <span class="keyword">new</span> StoreConnector&lt;<span class="built_in">List</span>&lt;CartItem&gt;, OnStateChanged&gt;(
        converter: (store) {
      <span class="keyword">return</span> (item) =&gt; store.dispatch(ToggleItemStateAction(item));
    }, builder: (context, callback) {
      <span class="keyword">return</span> <span class="keyword">new</span> ListTile(
        title: <span class="keyword">new</span> Text(item.name),
        leading: <span class="keyword">new</span> Checkbox(
            value: item.checked,
            onChanged: (<span class="built_in">bool</span> newValue) {
              callback(CartItem(item.name, newValue));
            }),
      );
    });
  }
}

<span class="keyword">typedef</span> OnStateChanged = <span class="built_in">Function</span>(CartItem item);</code></pre>
<p>注意：<a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/list/shopping_list_item.dart">这里是这个文件的完整源代码</a></p>
<p>与前面的示例一样，我们使用<code>StoreConnector</code>将List<cartitem>映射到OnStateChanged回调。现在每次更改复选框（在onChanged方法中),回调都会触发ToggleItemStateAction事件。</cartitem></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>以上就是全部内容！在本文中，我们使用Redux架构创建了一个简单的购物清单应用程序。在我们的应用程序中，我们可以添加一些条目并更改其状态。向此应用程序添加新功能就像添加新action和reducer一样简单。</p>
<p><a href="https://github.com/pszklarska/FlutterShoppingCart">在这里</a>，您可以查看此应用程序的完整源代码，包括时间旅行widge：</p>
<p>希望你喜欢这篇文章并敬请期待更多！ 🙌</p>
