<hr>
<p>layout: post<br>title:  “(译)Flutter bloc包”<br>date:   2019-04-22 14:16:17 +0800<br>categories: </p>
<ul>
<li>Flutter 开发<br>tags:<ul>
<li>状态管理 </li>
<li>BLoC</li>
</ul>
</li>
</ul>
<hr>
<p><a href="https://medium.com/flutter-community/flutter-bloc-package-295b53e95c5c">原文链接</a></p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*lP-1aF6Rg8jo459f87l3zg.png" alt></p>
<p>在使用Flutter一段时间之后，我决定创造一个包帮忙我经常使用的东西—BLoC模式做一些事情。</p>
<!--more-->


<p>对于那些不熟悉BLoC模式的人来说，它是一种设计模式，它有助于将表示层与业务逻辑分开。你从<a href="https://www.youtube.com/watch?v=fahC3ky_zW0">这里</a>能够了解更多。</p>
<p>虽然使用BLoC模式可能会因为设置以及对<code>Streams</code>和<code>Reactive Programming</code>的理解而具有挑战性，但它的核心BLoC是非常简单的：</p>
<p>BLoC将事件流作为输入，并将它们转换为状态流作为输出。</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*_EgLk67LpREOEMCSIhc_4Q.png" alt></p>
<p>我们现在可以在bloc包的帮助下使用这种强大的设计模式。</p>
<p>该软件包抽象了BLoC模式的响应式方面，允许开发人员专注于将事件转换为状态。</p>
<p>让我们从定义这些术语开始。</p>
<h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><p>事件(<code>Events</code>)是BLoC的输入。它们通常是UI事件，例如按钮按下。事件(<code>Events</code>)被发送(<code>dispatched</code>)并转换为状态(<code>States</code>)。</p>
<p>状态(<code>State</code>)是BLoC的产物。表示组件可以监听状态流并根据给定状态对其自身的部分进行重绘(有关详细信息，请参阅<code>BlocBuilder</code>)。</p>
<p>转换(<code>Transitions</code>)发生在mapEventToState被调用之后，当事件被发送之后，但在bloc状态被修改之前。一个转换(<code>Transition</code>)由当前状态(<code>currentState</code>)，已分送的事件(<code>event</code>)和下个状态(<code>nextState</code>)组成。</p>
<p>现在我们了解事件和状态，我们可以看一下Bloc API了。</p>
<h2 id="Bloc-API"><a href="#Bloc-API" class="headerlink" title="Bloc API"></a>Bloc API</h2><p>mapEventToState是一个类在扩展Bloc时必须实现的方法。该方法将传入事件作为参数。只要有一个事件被表示层发送(<code>dispatched</code>)，就会调用<code>mapEventToState</code>。 <code>mapEventToState</code>必须将该事件转换为新状态，并<code>Stream</code>的形式返回新状态,而这个新状态会被表示层使用。</p>
<p><code>dispatch</code>是一个接收事件并触发<code>mapEventToState</code>的方法。可以从表示层或从Bloc内部调用dispatch（参见示例）并向Bloc通知新事件来了。</p>
<p><code>initialState</code>是任何事件都没有被处理之前的状态（在调用<code>mapEventToState</code>之前）。initialState是一个可选的getter。如果未实现，则initialState将为null。</p>
<p><code>transform</code>是一个方法，可以在调用<code>mapEventToState</code>之前重写Stream<event>。这其中允许使用distinct()和debounce()之类的操作。</event></p>
<p><code>onTransition</code>是一个方法，可以在发生转换时覆盖对其加以处理。转换(<code>Transition</code>)发生在新的事件(<code>event</code>)被发送以及<code>mapEventToState</code>被调用的时候。<code>onTransition</code>在bloc的状态被更新之前被调用。这是添加bloc特有的日志记录/分析的好地方。</p>
<p>让我们创建一个计数器bloc！</p>
<pre><code class="dart"><span class="keyword">enum</span> CounterEvent { increment, decrement }

<span class="class"><span class="keyword">class</span> <span class="title">CounterBloc</span> <span class="keyword">extends</span> <span class="title">Bloc</span>&lt;<span class="title">CounterEvent</span>, <span class="title">int</span>&gt; </span>{
  <span class="meta">@override</span>
  <span class="built_in">int</span> <span class="keyword">get</span> initialState =&gt; <span class="number">0</span>;

  <span class="meta">@override</span>
  Stream&lt;<span class="built_in">int</span>&gt; mapEventToState(CounterEvent event) <span class="keyword">async</span>* {
    <span class="keyword">switch</span> (event) {
      <span class="keyword">case</span> CounterEvent.decrement:
        <span class="keyword">yield</span> currentState - <span class="number">1</span>;
        <span class="keyword">break</span>;
      <span class="keyword">case</span> CounterEvent.increment:
        <span class="keyword">yield</span> currentState + <span class="number">1</span>;
        <span class="keyword">break</span>;
    }
  }
}</code></pre>
<p>为了创建一个计数器bloc，我们需要做的就是：</p>
<ul>
<li>定义我们的事件和状态</li>
<li>扩展BloC</li>
<li>覆盖<code>initialState</code>和<code>mapEventToState</code>。</li>
</ul>
<p>在这种情况中，我们的事件是<code>CounterEvents</code>，我们的状态是整数类型。</p>
<p>我们的<code>CounterBloc</code>将<code>CounterEvents</code>转换为整数类型。</p>
<p>我们可以通过像这样调用<code>dispatch</code>方法来通知CounterBloc发出事件：</p>
<pre><code class="dart"><span class="keyword">void</span> main() {
  <span class="keyword">final</span> counterBloc = CounterBloc();

  counterBloc.dispatch(CounterEvent.increment);
  counterBloc.dispatch(CounterEvent.decrement);
}</code></pre>
<p>为了观察状态变化(<code>Transitions</code>），我们可以覆盖<code>onTransition</code>。</p>
<pre><code class="dart"><span class="keyword">enum</span> CounterEvent { increment, decrement }

<span class="class"><span class="keyword">class</span> <span class="title">CounterBloc</span> <span class="keyword">extends</span> <span class="title">Bloc</span>&lt;<span class="title">CounterEvent</span>, <span class="title">int</span>&gt; </span>{
  <span class="meta">@override</span>
  <span class="built_in">int</span> <span class="keyword">get</span> initialState =&gt; <span class="number">0</span>;

  <span class="meta">@override</span>
  <span class="keyword">void</span> onTransition(Transition&lt;CounterEvent, <span class="built_in">int</span>&gt; transition) {
    <span class="built_in">print</span>(transition);
  }

  <span class="meta">@override</span>
  Stream&lt;<span class="built_in">int</span>&gt; mapEventToState(CounterEvent event) <span class="keyword">async</span>* {
    <span class="keyword">switch</span> (event) {
      <span class="keyword">case</span> CounterEvent.decrement:
        <span class="keyword">yield</span> currentState - <span class="number">1</span>;
        <span class="keyword">break</span>;
      <span class="keyword">case</span> CounterEvent.increment:
        <span class="keyword">yield</span> currentState + <span class="number">1</span>;
        <span class="keyword">break</span>;
    }
  }
</code></pre>
<p>现在，每当我们调度CounterEvent时，我们的Bloc将以新的整数状态响应，我们将看到一个转换记录被打印到到控制台。</p>
<p>现在让我们使用Flutter构建一个UI，并使用<a href="https://pub.dartlang.org/packages/flutter_bloc">flutter_bloc</a>包将表示层连接到我们的<code>CounterBloc</code>。</p>
<p><a href="https://pub.dartlang.org/packages/flutter_bloc">flutter_bloc</a>包提供了两个widget，使得可以轻松地与Bloc进行交互：</p>
<h2 id="BlocBuilder"><a href="#BlocBuilder" class="headerlink" title="BlocBuilder"></a>BlocBuilder</h2><p><code>BlocBuilder</code>是一个Flutter widget，它需要一个Bloc和一个builder方法。 BlocBuilder处理了构建widget的工作以响应新状态。BlocBuilder与StreamBuilder非常相似，但它有一个更简单的API来减少所需的样板代码量。</p>
<h2 id="BlocProvider"><a href="#BlocProvider" class="headerlink" title="BlocProvider"></a>BlocProvider</h2><p><code>BlocProvider</code>是一个Flutter widget，它通过<code>BlocProvider.of(context)</code>为其子节点提供一个集合。它被用作依赖注入(DI)widget，以便可以将BloC的单例提供给子树中的多个widget。</p>
<p>现在让我们构建我们的Counter App！</p>
<pre><code class="dart">
<span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>{
  <span class="meta">@override</span>
  State&lt;StatefulWidget&gt; createState() =&gt; _AppState();
}

<span class="class"><span class="keyword">class</span> <span class="title">_AppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">App</span>&gt; </span>{
  <span class="keyword">final</span> CounterBloc _counterBloc = CounterBloc();

  <span class="meta">@override</span>
  Widget build(BuildContext context) {
    <span class="keyword">return</span> MaterialApp(
      title: <span class="string">'Flutter Demo'</span>,
      home: BlocProvider&lt;CounterBloc&gt;(
        bloc: _counterBloc,
        child: CounterPage(),
      ),
    );
  }

  <span class="meta">@override</span>
  <span class="keyword">void</span> dispose() {
    _counterBloc.dispose();
    <span class="keyword">super</span>.dispose();
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>{
  <span class="meta">@override</span>
  Widget build(BuildContext context) {
    <span class="keyword">final</span> CounterBloc _counterBloc = BlocProvider.of&lt;CounterBloc&gt;(context);

    <span class="keyword">return</span> Scaffold(
      appBar: AppBar(title: Text(<span class="string">'Counter'</span>)),
      body: BlocBuilder&lt;CounterEvent, <span class="built_in">int</span>&gt;(
        bloc: _counterBloc,
        builder: (BuildContext context, <span class="built_in">int</span> count) {
          <span class="keyword">return</span> Center(
            child: Text(
              <span class="string">'<span class="subst">$count</span>'</span>,
              style: TextStyle(fontSize: <span class="number">24.0</span>),
            ),
          );
        },
      ),
      floatingActionButton: Column(
        crossAxisAlignment: CrossAxisAlignment.end,
        mainAxisAlignment: MainAxisAlignment.end,
        children: &lt;Widget&gt;[
          Padding(
            padding: EdgeInsets.symmetric(vertical: <span class="number">5.0</span>),
            child: FloatingActionButton(
              child: Icon(Icons.add),
              onPressed: () {
                _counterBloc.dispatch(CounterEvent.increment);
              },
            ),
          ),
          Padding(
            padding: EdgeInsets.symmetric(vertical: <span class="number">5.0</span>),
            child: FloatingActionButton(
              child: Icon(Icons.remove),
              onPressed: () {
                _counterBloc.dispatch(CounterEvent.decrement);
              },
            ),
          ),
        ],
      ),
    );
  }
}</code></pre>
<p>我们的App widget是<code>StatefulWidget</code>，负责创建和处理CounterBloc。它使用我们上面提到的BlocProvider widget使CounterBloc可用于CounterPage widget。</p>
<p>我们的<code>CounterPage</code> widget是一个<code>StatelessWidget</code>，它使用<code>BlocBuilder</code>重建UI以响应<code>CounterBloc</code>的状态变化。</p>
<p>此时，我们已经成功地将我们的表示层与业务逻辑层分开。请注意，CounterPage widget 不知道用户点击按钮时会发生什么。widget只是告诉CounterBloc用户按下了递增或递减按钮。</p>
<p>就这么多。</p>
<p>有关更多示例和详细文档，请查看<a href="https://felangel.github.io/bloc">官方bloc文档</a>。</p>
<p>如果你喜欢这个bloc库，你可以通过⭐️<a href="https://github.com/felangel/bloc">仓库</a>或者👏来支持我这个文章。</p>
