<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Handler,我要你有何用?</title>
      <link href="/2019/04/27/Android/Async/Handler/"/>
      <url>/2019/04/27/Android/Async/Handler/</url>
      
        <content type="html"><![CDATA[<p>Android UI 框架是单线程机制,这也就意味着如果要保持界面的高刷新率,对于任何的耗时任务而言,对于它来说最好的选择就是跑在别的线程里面.为了与UI线程主线程进行区分,一般这些线程被称作工作线程或是后台线程.那么在一个工作流程中,如何做到从一个线程跑到另一个线程,而又从另一个线程跑回到最开始的线程呢.</p><p>这时候就要祭出 Android 系统中的 Handler, 位于天堑之间,人们只能通过索道来往通行.而对于两个线程而言呢,其实也就是把人挂在索道上,然后把一个个传过去.从而引申出了另外两个概念,消息和消息队列.那么Handler是谁,就是负责把人送过去的人.</p><p>搬运工主要的职责有两个:安排什么时候送过去,当然送到对岸之后,跟现在的地方也就没什么关系.</p><a id="more"></a><p>Hanlder-&gt;MessageQueue-&gt;Message</p><p>Handler 操作的对象是 MessageQueue,而 MessageQueue 的操作对象则是 Message.</p><p>但是,这里我们需要注意的是,说是队列,但是我们没有使用任何Java集合的类,Message是以内部引用方式存在的单向链表队列.</p><p>我们先忽略掉细节先从,handler的构造函数开始:</p><p>映入眼脸吓一跳:</p><p>Handler()、Hanlder(Callback)、Handler(Looper)、Handler(Looper,Callback)<br>、Handler(boolean)、Hanlder(Callback,boolean)、Hanlder(Looper,Callback,boolean)</p><p>其实就是啥都是默认的,传个callback、Looper、boolean 的搭配组合.</p><p>我们需要看的是最常用的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Handler(@Nullable Callback callback, boolean async) &#123;</span><br><span class="line">       if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">           final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">           if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                   (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">               Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                   klass.getCanonicalName());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mLooper = Looper.myLooper();</span><br><span class="line">       if (mLooper == null) &#123;</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">               &quot;Can&apos;t create handler inside thread &quot; + Thread.currentThread()</span><br><span class="line">                       + &quot; that has not called Looper.prepare()&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       mQueue = mLooper.mQueue;</span><br><span class="line">       mCallback = callback;</span><br><span class="line">       mAsynchronous = async;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先,如果Handler不是静态的,说你肯能造成内存泄漏,当然现在不是重点,我们先过.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLooper = Looper.myLooper();</span><br></pre></td></tr></table></figure><p>相当于说,我去looper这个map里面拿,每个线程独一份的Looper,当然如果没有初始化的话,这个looper肯定是空的.</p><p>如果我在线程中,在没有初始化Looper之前去初始化Handler,报错事必然的,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E/Handler: This is not main thread, and the caller should invoke Looper.prepare()  and Looper.loop()called byandroid.os.Handler</span><br></pre></td></tr></table></figure><p>大致意思是,应该先调用Loope.prepare(),并且在Handler中你要去调用 Looper.loop().</p><p>也就是说:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread &#123;</span><br><span class="line">            Looper.prepare()</span><br><span class="line">            val handler = Handler()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>那在Looper.prepare()这步到底做了什么呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void prepare() &#123;</span><br><span class="line">        prepare(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">        if (sThreadLocal.get() != null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>初始化当前线程的Looper,并且如果已经有Looper的情况下去调用,肯定是会报错的.</p><p>譬如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread &#123;</span><br><span class="line">            Looper.prepare()</span><br><span class="line">            Looper.prepare()</span><br><span class="line">            val handler = Handler()</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2020-07-08 14:06:44.322 29171-29332/cn.jinyulei.handlertest E/AndroidRuntime: FATAL EXCEPTION: Thread-2</span><br><span class="line">    Process: cn.jinyulei.handlertest, PID: 29171</span><br><span class="line">    java.lang.RuntimeException: Only one Looper may be created per thread</span><br><span class="line">        at android.os.Looper.prepare(Looper.java:110)</span><br><span class="line">        at android.os.Looper.prepare(Looper.java:105)</span><br><span class="line">        at cn.jinyulei.handlertest.MainActivity$onCreate$2.invoke(MainActivity.kt:27)</span><br><span class="line">        at cn.jinyulei.handlertest.MainActivity$onCreate$2.invoke(MainActivity.kt:13)</span><br><span class="line">        at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)</span><br></pre></td></tr></table></figure><p>同时,我们看到 Handler 中的 mQueue不过指向从 looper中mQueue的. 而Looper.loop()中也是干了些什么呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (;;) &#123;</span><br><span class="line">         Message msg = queue.next(); // might block</span><br><span class="line">         if (msg == null) &#123;</span><br><span class="line">             // No message indicates that the message queue is quitting.</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">         msg.target.dispatchMessage(msg);</span><br><span class="line">             if (observer != null) &#123;</span><br><span class="line">                 observer.messageDispatched(token, msg);</span><br><span class="line">             &#125;</span><br><span class="line">         ....    </span><br><span class="line">         </span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 无限循环,从消息队列里面拿消息,拿到之后就进行分发,分发之后进行回收.</p><p> 而这里面的target,就是我们的Handler.</p><p> 很明显以上做的事一个出队列的操作.但是至于怎么消息是怎么进来的呢?</p><p> 我们有两个系列的方法分别来把不同类型的消息塞进来,post系列以及sendMessage系列</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public final boolean post(@NonNull Runnable r) &#123;</span><br><span class="line">   return  sendMessageDelayed(getPostMessage(r), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public final boolean postAtTime(@NonNull Runnable r, long uptimeMillis) &#123;</span><br><span class="line">    return sendMessageAtTime(getPostMessage(r), uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public final boolean postAtTime(</span><br><span class="line">        @NonNull Runnable r, @Nullable Object token, long uptimeMillis) &#123;</span><br><span class="line">    return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean postDelayed(@NonNull Runnable r, long delayMillis) &#123;</span><br><span class="line">    return sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean postDelayed(</span><br><span class="line">        @NonNull Runnable r, @Nullable Object token, long delayMillis) &#123;</span><br><span class="line">    return sendMessageDelayed(getPostMessage(r, token), delayMillis);</span><br><span class="line">&#125;</span><br><span class="line">     public final boolean postAtFrontOfQueue(@NonNull Runnable r) &#123;</span><br><span class="line">    return sendMessageAtFrontOfQueue(getPostMessage(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 按照求同存异的法则,通过比较这些方法可以知道,传入的都是要干的事情,然后通过getPostMessage(r)把干的事情存到消息里面,然后通过发送消息的一系列方法,把消息压入队列.</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessage(@NonNull Message msg) &#123;</span><br><span class="line">       return sendMessageDelayed(msg, 0);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public final boolean sendEmptyMessage(int what)</span><br><span class="line">   &#123;</span><br><span class="line">       return sendEmptyMessageDelayed(what, 0);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123;</span><br><span class="line">       Message msg = Message.obtain();</span><br><span class="line">       msg.what = what;</span><br><span class="line">       return sendMessageDelayed(msg, delayMillis);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123;</span><br><span class="line">       Message msg = Message.obtain();</span><br><span class="line">       msg.what = what;</span><br><span class="line">       return sendMessageAtTime(msg, uptimeMillis);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">  public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123;</span><br><span class="line">       if (delayMillis &lt; 0) &#123;</span><br><span class="line">           delayMillis = 0;</span><br><span class="line">       &#125;</span><br><span class="line">       return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">     public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123;</span><br><span class="line">       MessageQueue queue = mQueue;</span><br><span class="line">       if (queue == null) &#123;</span><br><span class="line">           RuntimeException e = new RuntimeException(</span><br><span class="line">                   this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">           Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">  public final boolean sendMessageAtFrontOfQueue(@NonNull Message msg) &#123;</span><br><span class="line">       MessageQueue queue = mQueue;</span><br><span class="line">       if (queue == null) &#123;</span><br><span class="line">           RuntimeException e = new RuntimeException(</span><br><span class="line">               this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">           Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return enqueueMessage(queue, msg, 0);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 别看那么多东西最终调用的都是这么一个方法:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,</span><br><span class="line">           long uptimeMillis) &#123;</span><br><span class="line">       msg.target = this;</span><br><span class="line">       msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">       if (mAsynchronous) &#123;</span><br><span class="line">           msg.setAsynchronous(true);</span><br><span class="line">       &#125;</span><br><span class="line">       return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650241824&amp;idx=1&amp;sn=aa4be9ab94828bfff4ee9108a85a0f0b&amp;chksm=88638a4fbf1403594b7e2e0fc04a30ced3ec7819cc891b4e872b52e29692b9f7a11a8658a97d&amp;scene=38#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650241824&amp;idx=1&amp;sn=aa4be9ab94828bfff4ee9108a85a0f0b&amp;chksm=88638a4fbf1403594b7e2e0fc04a30ced3ec7819cc891b4e872b52e29692b9f7a11a8658a97d&amp;scene=38#wechat_redirect</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Async </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
