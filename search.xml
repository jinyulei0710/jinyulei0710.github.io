<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>(译)Android 中的依赖注入</title>
      <link href="/2020/04/19/Android/dependency-injection/"/>
      <url>/2020/04/19/Android/dependency-injection/</url>
      
        <content type="html"><![CDATA[<p>依赖注入是编程中广泛使用的技术,并且同样适用于 Android 开发.遵循以下依赖注入的原则,为你能够开发一个优秀架构的应用打下基础.</p><p>实现依赖注入给你提供了以下好处:</p><ul><li>代码复用</li><li>易于重构</li><li>易于测试</li></ul><a id="more"></a><h2 id="依赖注入基础"><a href="#依赖注入基础" class="headerlink" title="依赖注入基础"></a>依赖注入基础</h2><p>在讲解特定于Android的依赖注入之前,这个页面会提供一个更为通用的关于依赖注入如何工作的概览.</p><h3 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h3><p>类通常需要引用其它类,例如,Car 类可能需要一个指向 Engine 类的引用.这些被需要的类被称作依赖,并且在这个例子中,Car类依赖于一个Engine类的实例才能够运行.</p><p>对于类来说,有三种获取它需要类的方式:</p><ol><li>类本身构造它所需的依赖.在以上的例子中,Car 会创建并初始化它自己的 Engine 实例.</li><li>从别处获取依赖.一些 Android 接口,例如 <code>Context</code>的 getter系列以及<code>getSystemService()</code>,这是这么做的.</li><li>让依赖作为参数提供.应用能够在类构造或是方法中传入所需的依赖.在上面的例子中,<code>Car</code> 构造器会接收<code>Engine</code>作为参数.       </li></ol><p>第三种选项就是依赖注入.通过这种方式你能够获取并提供一个类的依赖,而不是让类实例本身自己获取.</p><p>以下是一个例子,不使用依赖注入,意味着 <code>Car</code>是像以下这样在代码中创建它自己的<code>Engine</code>依赖的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Car&#123;</span><br><span class="line">   </span><br><span class="line">   private val engine = Engine();</span><br><span class="line">   </span><br><span class="line">   fun start()&#123;</span><br><span class="line">      engine.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args:Array)&#123;</span><br><span class="line">   val car = Car()</span><br><span class="line">   car.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不是一个依赖注入的例子,因为<code>Car</code>类构造了它自己的<code>Engine</code>.这可能是有问题的,因为:</p><ul><li><p><code>Car</code>和<code>Engine</code>是紧密耦合的-<code>Car</code>实例适用了<code>Engine</code>类型,子类和替代的实现不能够很容易实现.如果<code>Car</code>需要构造它自己的<code>Engine</code>,你会需要创建两种类型的<code>Car</code>,而不是让<code>Gas</code>和<code>Electric</code>两种引擎复用相同的<code>Car</code>.</p></li><li><p>硬编码依赖是的测试变得更加困难. <code>Car</code>使用了真实的<code>Engine</code>实例,从而阻止你使用替身来修改<code>Engine</code>来应对不同的测试用例.</p></li></ul><p>使用依赖注入的代码是怎么样的? <code>Car</code>实例不是在初始化的时候构建它自己的<code>Engine</code>,它接收了一个参数作为它构造器的参数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Car(private val engine:Engine)&#123;</span><br><span class="line">    fun start()&#123;</span><br><span class="line">        engine.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args:Array)&#123;</span><br><span class="line">   val engine=Engine();</span><br><span class="line">   val car=Car(engine);</span><br><span class="line">   car.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code> 函数使用了<code>Car</code>.因为<code>Car</code>依赖于<code>Engine</code>,应用能够创建一个Engine实例,并将它用于构建一个<code>Car</code>实例.这种基于依赖注入的方式的好处有:</p><ul><li><p><code>Car</code>的复用性.你可以传入<code>Engine</code>的不同实现到<code>Car</code>.例如,你可能定义了一个新的<code>Engine</code>的子类叫做 <code>ElectricEngine</code>来让<code>Car</code>来使用.如果你使用了依赖注入,你需要的是传入修改过的<code>EletricEngine</code>子类,<code>Car</code>仍旧能够工作而不需要进行进一步的修改.</p></li><li><p>很容易对<code>Car</code>进行测试.你可以针对不同的场景,你可以传入不同的替身.例如,你能够创建一个<code>Engine</code>替身叫做<code>FakeEngine</code>并将它配置到不同的测试场景下.</p></li></ul><p>在Android中主要有两种依赖注入的方式:</p><ul><li>构造器注入.这是以上所描述的.你可以类依赖作到它的构造器.</li><li>字段注入(或Setter注入).一些Android框架类,例如activity和fragment是由系统初始化的,构造器注入就不再可能了,字段注入中,依赖是在类创建完成之后初始化的.代码看起来是像这样的:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">    lateinit var engine: Engine</span><br><span class="line">    </span><br><span class="line">    fun start()&#123;</span><br><span class="line">      engine.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun main(args:Array)&#123;</span><br><span class="line">    val car=Car()</span><br><span class="line">    car.engine=Engine()</span><br><span class="line">    car.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动化的依赖注入"><a href="#自动化的依赖注入" class="headerlink" title="自动化的依赖注入"></a>自动化的依赖注入</h3><p>在之前的例子中,你创建、提供以及管理不同类的依赖都是由你自己来的,没有依赖于一个库.这叫做手动依赖注入.在<code>Car</code>的例子中,只有一个依赖,但是越来越多的类和依赖会使手动依赖注入变得越来越单调乏味.手动依赖注入同样也暴露出一些问题:</p><ul><li><p>对于大型应用来说,获取所有的依赖并将它们正确连接需要大量的模版代码.在多层次的架构中,为了给高层创建一个对象,你需要提供所有这个层之下的依赖.举个具体的例子,为了建造一辆车你可能需要引擎,变速器,地盘以及其它的部分;并且引擎转而需要气缸和火花塞.</p></li><li><p>当你不能够在传入依赖之前构造函数的时候,例如使用懒初始化或是限定对象来构成你的应用的时候,你需要写和维护一个自定义的容器(或是依赖图)来在内存中管理你的依赖的生命周期.</p></li></ul><p>通过自动化创建和提供依赖这个过程,存在很多解决这个问题的库.它们可以分为两类:</p><ul><li>基于反射的解决方案,在运行时对依赖进行连接.</li><li>静态解决方案,在编译时生成代码并连接依赖.</li></ul><p>Dagger 是针对Java、Kotlin以及Android的一个流行的由Google维护的依赖注入库.Dagger通过为你创建和管理依赖图,使在你的应用中使用DI变得便利.它提供了全静态的编译时的依赖,解决了基于反射的解决方案(Guice)的开发和性能的问题.</p><h2 id="依赖注入的替代方案"><a href="#依赖注入的替代方案" class="headerlink" title="依赖注入的替代方案"></a>依赖注入的替代方案</h2><p>依赖注入的替代方案是使用服务定位器.服务定位器设计模式同样促进了类和具体依赖的解耦.你创建了一个服务定位类,这个类是用来创建和存储依赖用的,并按需提供这个依赖.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">object ServiceLocator&#123;</span><br><span class="line">     fun getEngine():Engine=Engine()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car&#123;</span><br><span class="line">    private val engine=ServiceLocator.getEngine()</span><br><span class="line">    </span><br><span class="line">    fun start()&#123;</span><br><span class="line">       engine.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args:Array)&#123;</span><br><span class="line">   val car=Car();</span><br><span class="line">   car.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务定位模式和依赖注入的不同点在于元素的使用方式不同.服务定位模式中,类控制并请求对象注入;依赖注入中,应用控制并主动地注入需要的对象.</p><p>与依赖注入相比:</p><ul><li>依赖集合需要一个服务定位器是的代码测试变得困难,因为所有的测试都要与同一个全局服务定位器交互.</li><li>依赖在类实现中编码,而不是在API层面.结果是,从外部很难知道类需要什么,对服务定位中对Car或依赖的修改可能导致在运行时或是测试中引用不到.</li><li>当你想要限定对象的生命周期不只是整个应用的生命周期的时候,管理对象的生命周期显得更为困难.</li></ul><h2 id="为你的应用选择正确的技术"><a href="#为你的应用选择正确的技术" class="headerlink" title="为你的应用选择正确的技术"></a>为你的应用选择正确的技术</h2><p>如上所述,有多种不同管理你应用依赖的技术.</p><p>手动依赖注入只在相对较小的应用上有效,因为它扩展性很差.当项目变大,传递对象需要大量的模版代码.</p><p>服务定位器起初需要较少的模版的代码,但是扩展性很差,进一步的来说,测试会变得更为困难因为它们依赖于单例对象.</p><p>Dagger为扩展而生.它与构建复杂的应用相适应.</p><p>如果你的小应用会变得复杂,你应该考虑尽早迁移到Dagger,因为不需要很大的代码修改量.</p><h2 id="为你的库选择正确的技术"><a href="#为你的库选择正确的技术" class="headerlink" title="为你的库选择正确的技术"></a>为你的库选择正确的技术</h2><p>如果你在开发一个外部的SDK或是库,你应该基于SDK和库的大小在手动依赖注入和Dagger之间选择.注意如果你使用第三方库来做依赖注入,你的库的大小会有一定增长.</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>依赖注入为你的应用提供了以下的好处:</p><ul><li>类的复用以及依赖的解耦,使得依赖实现的置换变得简单.由于控制反转,代码的复用性提高了,类不再控制它们的依赖是如何创建的,而是由配置控制.</li><li>易于重构:依赖变成了API层面的一个可变部分,所以它们能够在对象创建或编译时进行检查,而不是隐藏在具体实现后面.</li><li>易于测试,类不再管理它的依赖,所以当你测试它的时候,你可以传递进不同实现来测试你的不同用例.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Android 消息传递机制</title>
      <link href="/2020/03/26/Android/AndroidMessagePassing/"/>
      <url>/2020/03/26/Android/AndroidMessagePassing/</url>
      
        <content type="html"><![CDATA[<p>目前为止,目前我们使用的线程通讯手段都是常规的 Java 应用所使用的. 管道、内存共享、可阻塞式队列可以应用到 Android 应用 ,但是会引起 UI 线程的问题, 因为这些手段都倾向于堵塞. UI 线程的响应性在使用带有阻塞行为的机制的时候是有风险的,因为这些机制通常可能会使线程挂起.</p><p>在 Android 中绝大部份线程之间的通讯是 UI 线程和 工作线程之间的通讯.因此,Android 平台定义了它自己的线程间通讯的方式. UI 线程能够以发送数据消息的方式让长时间运行的任务在后台线程被处理.消息传递机制是非阻塞式的 生产者-消费者模式,在这个模式下无论是生产者线程还是消费者线程,在消息处理的时候都不会被堵塞.</p><p>消息处理机制是 Android 平台的基石, API 位于 android.os 包下, 由下图 4-4 中所示的一系列类来实现功能.</p><p><img src="//jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-4.api-overview.png" alt></p><a id="more"></a><p>android.os.Looper</p><p>&emsp;&emsp;&emsp;&emsp; 跟有且只有一个消费者线程关联的消息分发者</p><p>android.os.Handler</p><p>&emsp;&emsp;&emsp;&emsp; 消费线程消息处理者,生产者线程插入消息到队列的接口. 一个Looper能有多个相关联的Handler,但是它们都会被插入到相同的队列中.</p><p>android.os.MessageQueue</p><p>&emsp;&emsp;&emsp;&emsp; 在消费者线程被处理的无限的消息列表.每一个Looper以及线程至多有一个消息队列.</p><p>android.os.Message</p><p>&emsp;&emsp;&emsp;&emsp; 将被在消费者线程执行的消息</p><p>如图4-5所示消息由生产者线程插入并且由消费者线程处理.</p><ol><li>插入: 生产者线程通过使用与消费者线程相关联的Handler往消息队列中插入消息</li><li>获取:运行在消息者线程的Looper按照序列的顺序从队列中获取消息</li><li>分发: handler负责在消费者线程处理消息.一个线程可能有多个Handler实例来处理消息,Looper确保了消息被分发到了正确的Handler.</li></ol><p><img src="//jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-5.png" alt></p><p>图 4-5 ,多个生产者线程和单个消费者线程之间的消息传递机制.每个消息都指向队列中的下一个消息,图中以左向的箭头指示.</p><h1 id="例子-基本的消息传递"><a href="#例子-基本的消息传递" class="headerlink" title="例子: 基本的消息传递"></a>例子: 基本的消息传递</h1><p>在我们进一步详细的分析组件之前,让我们先来看个基本的消息传递的例子来熟悉下:</p><p>以下代码实现可能是最常见的使用场景之一,用户按下屏幕上的一个能够触发长时间操作的按钮,例如网络操作.为了不拖慢UI的渲染,一个假的 代表长时间运行的操作doLongRunningOperation()方法 ,需要运行在工作线程.因此,需要仅仅需要对一个生产者线程(UI线程)以及一个工作线程(Looper线程)进行设置.</p><p>我们的代码建立了一个消息队列.它在click()回调中处理按钮点击事件,这是在UI线程执行的.在我们的实现中,回调插入了一条假的消息到消息队列当中.为简洁起见,布局和UI组件在我们的代码事例中被省略了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class LooperActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    LooperThread mLooperThread;</span><br><span class="line"></span><br><span class="line">    private static class LooperThread extends Thread &#123; //1</span><br><span class="line"></span><br><span class="line">        Handler mHandler;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Looper.prepare();//2</span><br><span class="line">            mHandler = new Handler() &#123;//3</span><br><span class="line">                @Override</span><br><span class="line">                public void handleMessage(@NonNull Message msg) &#123;//4</span><br><span class="line">                    if (msg.what == 0) &#123;</span><br><span class="line">                        doLongRunningOperation();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Looper.loop();//5</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void doLongRunningOperation() &#123;</span><br><span class="line">            //Add long running operation here.</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onCreate(Bundle saveInstanceState) &#123;</span><br><span class="line">        super.onCreate(saveInstanceState);</span><br><span class="line">        mLooperThread = new LooperThread();//6</span><br><span class="line">        mLooperThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        if (mLooperThread.mHandler != null) &#123;//7</span><br><span class="line">            Message msg = mLooperThread.mHandler.obtainMessage(0);//8</span><br><span class="line">            mLooperThread.mHandler.sendMessage(msg);//9</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        mLooperThread.mHandler.getLooper().quit();//10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>定义工作线程,作为消息队列的消费者</li><li>将 Looper-隐式关联了消息队列与线程关联在一起</li><li>设置一个被生产者所使用的Handler,让生产者用来插入消息到队列中.这里我们使用的是默认的构造器,因而会与当前线程的 Looper 绑定在一起. 因此,Handler 只能在 Looper.prepare() 之后创建,不然它没有东西可以绑定了.</li><li>当消息被分发到工作线程的时候进入了回调.它会检查 what 参数并执行长时间运行的任务</li><li>开始从消息队列向消息者线程分发消息.这是一个阻塞的调用,因此工作现象不会终止.</li><li>启动工作线程,从而它能开始处理消息</li><li>后台工作线程上handler的设置和handler在UI线程上的使用存在竞态.因此需要验证mHandler是否可用.</li><li>初始化一个消息对象并将其what参数设置为0</li><li>将消息插入队列</li><li>终止后台线程.Looper.quit()的调用终止了 消息的分发并将 Looper.loop 从 阻塞中释放出来,从而run方法能终止,从而导致线程的终止.</li></ol><h1 id="消息传递所使用的类"><a href="#消息传递所使用的类" class="headerlink" title="消息传递所使用的类"></a>消息传递所使用的类</h1><p>现在,让我们更为具体地看看消息传递中所使用的具体组件,以及它们的用途.</p><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>消息队列由 android.os.MessageQueue 所代表.它由链接的消息构建而成,形成了一个无限的单向链表.生产者线程插入到队列的消息,稍后会被分发到消息者.消息是基于事件戳排序的.队列中时间戳最小的消息,排在分发给消费者的队列的最前面.但是,消息只有在时间戳的值小于当前的时间值的时候才会被分发.如果时间没有到,分发这个动作会等到当前时间超过时间戳.</p><p>图4-6 显示了一个有三个等待的消息的消息队列,它们是以时间戳顺序排列的, t1 &lt; t2&lt; t3. 只有一个消息越过了分发栏栅,这个栏栅代表当前时间.能够被分发的消息的时间是小于当前时间的.</p><p><img src="//jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-6.png" alt></p><p>图 4-6 队列中的处于等待状态的消息.最右边的消息,是队列中最先被处理的.队列中的消息的箭头指向队列中的下一个消息.</p><p>如果没有消息被越过分发栏栅,而Looper以及做好获取下一个消息的转呗,消费者者线程会阻塞. 执行会在消息被发送到分发栏栅的时候恢复.</p><p>生产者能能够在任意时间以及队列的任意位置插入一个新的消息.队列中插入的位置是由时间戳决定的.如果跟等待的消息比,新的消息由最小的时间戳,那么它就会占据队列的第一个位置,将被下一个分发.插入总是遵循时间戳的顺序的.关于消息插入的部分会在 Hanlder这节进一步分析.</p><h2 id="MessageQueue-IdleHandler"><a href="#MessageQueue-IdleHandler" class="headerlink" title="MessageQueue.IdleHandler"></a>MessageQueue.IdleHandler</h2><p>如果没有消息要处理,消费者线程就会有一些空闲时间.例如,图4-7,显示了当消费者线程空闲的时候,由一段时间槽.默认情况下,消费者线程只会在空闲时间期间等待新的消息,但是处了等待,在空闲槽期间线程能被分配去执行其它任务.这个特性能够让非重要的任务让出它们的执行时间,直到没有其它消息竞争执行时间. </p><p><img src="//jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-7.png" alt></p><p>图 4-7. 如果没有消息被传到分发栏栅,在下一个等待消息被执行之前,就存在一段时间槽能用来执行.</p><p>当等待的消息被分发之后,没有其它消息被传到分发栏栅,就会有一段时间槽,期间消费者线程能利用它来执行其它任务.应用通过 android.os.Message.IdleHandler 接口来获取着的时间槽. IdleHanlder 接口,值当线程空闲的时候的一个监听回调.监听被附加到消息队列上并以如下调用的方式从队列上脱离出来:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Get the message queue of the current thread.</span><br><span class="line">Message mq=Looper.myQueue();</span><br><span class="line">//Create and register and idle listener</span><br><span class="line">MessageQueue.IdleHandler idleHanlder=new MessageQueue.IldeHandler();</span><br><span class="line">mq.addIdleHandler(idlehandler)</span><br><span class="line">//Unregister an idle Handler</span><br><span class="line">mq.removeIdleHanlder(idleHanlder)</span><br></pre></td></tr></table></figure><p>idle hanlder 接口只包含了一个 callback 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IdleHandler &#123;</span><br><span class="line">     boolean queueIdle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当消息队列监测到消息队列的空闲时间的时候,它会调用所有注册过 IdleHanlder 实例地方的 queueIdle().实现callback的责任就交给了应用.你应该避免运行长时间运行的任务,因为在它们运行的时候,它们会推迟等待中的消息.</p><p>queue() 的实现必须返回一个布尔值,具体含义如下:</p><p>true</p><p>&emsp;&emsp;&emsp;&emsp; idle hanlder 处于活跃态,它会继续在接下来的时间槽中接收回调.</p><p>false</p><p>&emsp;&emsp;&emsp;&emsp; idle handler 已经不活跃了,就接下去又时间槽,他也不会接受到回调了.这个效用是更通过 MessageQueue.removeIdleHanlder()移除监听是一样的.</p><h3 id="例子-使用-Idle-Hanlder-来终止一个不再使用的线程"><a href="#例子-使用-Idle-Hanlder-来终止一个不再使用的线程" class="headerlink" title="例子:使用 Idle Hanlder 来终止一个不再使用的线程"></a>例子:使用 Idle Hanlder 来终止一个不再使用的线程</h3><p>当线程又空闲时间槽的时候,所有在 MessageQueue 上注册过 IdleHanlders 的,都会被调用,期间他在等待要处理的新消息. 空闲时间槽能够发生在第一个消息之前,消息之前,以及最后一个消息之后.如果多个内容提供者应该在消费者线程上按序处理数据, IdleHandler 可以用来终止消费者线程,当消息都处理完了,线程在内存中就没有用处了.有了 IdleHanlder,没有必要记录最后一个插入的消息去得知什么时候线程能被终止.</p><p>这只在生产者线程没有延迟地插入消息到队列中才有效,因为这样直到最后一个消息插入之后消费者线程才会进入空闲状态.</p><p>ConsumeAndQuitThread 方法展示了 带有 Looper和消息队列的线程的结构,这个线程会在没有消息要处理的时候被终止:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private static class ConsumeAndQuitThread extends Thread implements MessageQueue.IdleHandler &#123;</span><br><span class="line"></span><br><span class="line">        private static final String THREAD_NAME = &quot;ConsumeAndQuitThread&quot;;</span><br><span class="line"></span><br><span class="line">        public Handler mConsumerHandler;</span><br><span class="line">        private boolean mIsFirstIdle = true;</span><br><span class="line"></span><br><span class="line">        public ConsumeAndQuitThread() &#123;</span><br><span class="line">            super(THREAD_NAME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Looper.prepare();</span><br><span class="line"></span><br><span class="line">            mConsumerHandler = new Handler() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void handleMessage(Message msg) &#123;</span><br><span class="line">                    // Consume data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Looper.myQueue().addIdleHandler(this);//1</span><br><span class="line">            Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean queueIdle() &#123;</span><br><span class="line">            if (mIsFirstIdle) &#123;//2</span><br><span class="line">                mIsFirstIdle = false;</span><br><span class="line">                return true;//3</span><br><span class="line">            &#125;</span><br><span class="line">            mConsumerHandler.getLooper().quit();//4</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void enqueueData(int i) &#123;</span><br><span class="line">            mConsumerHandler.sendEmptyMessage(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>当天启动的时候在后台线程注册IdleHanlder,然后Looper就准备好了,然后消息队列就设置好了.</p></li><li><p>让第一个 queueIdle 调用通过,因此它会在首个消息到达之前发生</p></li><li><p>在一次调用的时候返回true,所以IdleHandler仍然是注册着的</p></li><li><p>终止线程</p><p>消息插入是由多个线程并发插入的,并且模拟一个随机的插入时间:</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final ConsumeAndQuitThread consumeAndQuitThread = new ConsumeAndQuitThread();</span><br><span class="line">        consumeAndQuitThread.start();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                        SystemClock.sleep(new Random().nextInt(10));</span><br><span class="line">                        consumeAndQuitThread.enqueueData(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="消息-Message"><a href="#消息-Message" class="headerlink" title="消息(Message)"></a>消息(Message)</h1><p>消息队列上的每一项都是 android.os.Message 类,这是一个运送数据或任务,或什么也不运的容器对象.数据由消费者线程处理,然而任务只是在出队列的时候执行,你不需要做其它处理:</p><p>消息知道他的接受处理者Hanlder,并通过Message.sendToTarget()将其自身入队:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message m=Message.obtain(hanlder,runnable);</span><br><span class="line">m.sendToTarget();</span><br></pre></td></tr></table></figure><p>正如我们会在handler这一节会看到的,handler 最常用来进行消息入队,同时就消息插入提供了更多的灵活性.</p><h2 id="数据消息-Data-Message"><a href="#数据消息-Data-Message" class="headerlink" title="数据消息(Data Message)"></a>数据消息(Data Message)</h2><p>数据集有着多个能够被传递给消费者线程的参数,如表 4-2 所示:</p><p>表 4-2 消息参数</p><table><thead><tr><th>参数名称</th><th>类型</th><th>用途</th></tr></thead><tbody><tr><td>what</td><td>int</td><td>消息标识.消息的通讯意图</td></tr><tr><td>arg1,arg2</td><td>int</td><td>用于传递整型的简单数据,如果最多只有两个整数值要被传递到消费者线程,这些参数比分配一个bundle来传递更为高效.</td></tr><tr><td>obj</td><td>Object</td><td>任意对象.如果一个对象要传递到另一个进程的线程中,它必须实现 Parcelable</td></tr><tr><td>data</td><td>Bundle</td><td>任意数据值的容器</td></tr><tr><td>replyTo</td><td>Messager</td><td>指向其它进程中的Hanlder.使跨进程消息通讯成为可能</td></tr><tr><td>callback</td><td>Runnable</td><td>在线程上执行的任务.这是一个持有来自Hanlder.post 方法的 Runnable 对象的内部实例域.</td></tr></tbody></table><h2 id="任务消息-Task-Message"><a href="#任务消息-Task-Message" class="headerlink" title="任务消息(Task Message)"></a>任务消息(Task Message)</h2><p>任务由运行在消费者线程的java.lang.Runnable 对象代表.任务对象除了任务本身之外不能包含任何数据.</p><p>消息队列可以包含仍以数据和任务消息的组合.消费者线程以线性的方式对它们进行处理,不管它们是什么类型.如果消息是数据消息,消费者线程会处理数据.任务消息的处理方式是让Runnable执行在消费者线程上,但是消费者线程没有像数据消息一样在Handler.handleMessage(Message)中收到任何消息.</p><p>消息的生命周期是简单的:生产者创建消息,并且最终消息由消费者线程处理.这样的描述适用于大部分使用场景,但是出问题的时候,对消息处理的进一步理解就很有价值了.让我们看看在它的生命周期中,在消息身上到底发生了什么,这个过程可以分为如图4-8中的最重要的4步.运行时将消息对象存储到一个应用范围的对象池,从而使得能对之前的消息进行复用.这个避免了在每个处理的时候创建新的实例的消耗.消息对象的处理时间通常是很短的,并且许多消息在在一个时间单位就处理完了.</p><p><img src="//jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-8.png" alt></p><p>图 4-8 消息生命周期状态</p><p>状态转换部分由应用控制,部分由平台控制.注意状态不是可观察的,并且应用不能观察到从一个状态到另一个状态的变化.因此,应用不应该对于消息的当前状态作出任何假定.</p><h2 id="初始化-Initialized"><a href="#初始化-Initialized" class="headerlink" title="初始化(Initialized)"></a>初始化(Initialized)</h2><p>在初始化状态,一个可修改状态的消息对象已经被创建,并且如果它是数据对象的话,已经被数据填充了.应用负责使用以下的调用来创建消息对象.它们能够从对象池中获取一个对象:</p><ul><li><p>明确的对象构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message m=new Message();</span><br></pre></td></tr></table></figure></li><li><p>工厂方法:</p><ul><li><p>空消息:</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message m=Message.obtain();</span><br></pre></td></tr></table></figure></code></pre></li><li><p>数据消息:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Message m=Message.obtain(Handler h);</span><br><span class="line">Message m=Message.obtain(Hanlder h,int what);</span><br><span class="line">Message m=Message.obtain(Handler h,int what, object o);</span><br><span class="line">Message m=Message.obtain(Handler h,int what, int arg1, int arg2);</span><br><span class="line">Message m=Message.obtain(Hanlder,int what,int arg1,int arg2,Object o);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>任务消息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message m=Message.obtain(Handler h,Runnable task);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>拷贝构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message m=Message.obtain(Message originMsg);</span><br></pre></td></tr></table></figure></li></ul><h2 id="等待-Pending"><a href="#等待-Pending" class="headerlink" title="等待(Pending)"></a>等待(Pending)</h2><p>消息已经由生产者线程插入队列,并且它正等待着被分发到消费者线程.</p><h2 id="已分发-Dispatched"><a href="#已分发-Dispatched" class="headerlink" title="已分发(Dispatched)"></a>已分发(Dispatched)</h2><p>在此状态下,Looper已经获取并从队列中移除了消息.消息已经被分发到了消费者线程,并且正在被处理.对于这部操作没有应用api,因为分发是由Looper控制的,而不受应用的影响.当Looper分发一个消息,它会检查消息的分发信息然后分发消息到正确的接受者.一旦分发了,消息是在消费者线程上执行的.</p><h2 id="已回收-Recycled"><a href="#已回收-Recycled" class="headerlink" title="已回收(Recycled)"></a>已回收(Recycled)</h2><p>在生命周期的这一时刻,消息的状态已经被清理了并且实例已经被交还给了消息池.当它结束在消费者线程的执行,Looper 处理了消息的回收.消息的回收是由运行时处理的,并且不应该由应用显式地完成.</p><p>一旦消息被插入了队列,内容应该不应在被修改了.理论上,在消息处理之前修改内容是合法的.但是,因为状态是不可观察的,在变更数据的时候,消息已经可能被消费者线程处理的,就会导致线程安全问题.更糟糕的是,消息可能已经被回收,因为它已经被交还给了消息池并且被另一个生产者传入到另一个队列中.</p><h1 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h1><p>android.os.Looper 类负责将队列中的消息分发到相关联的 handler.就如图4-6所示,所有的消息都得发送到分发栏栅,从而能够被Looper进行分发.只要队列中有消息能被分发,Looper就能保证消费者线程能收到消息.当没有消息被传到分发栏栅的时候,消费者线程就会阻塞直到有消息传到分发栏栅.</p><p>消费者线程并不直接和消息队列交互来获取消息.而是,在Looper添加到线程之后,消息队列才添加到线程.Looper对消息队列进行管理并促进消息到消费者线程的分发.</p><p>默认情况下,只有UI线程会有Looper,在应用中创建的线程需要获取looper并显式地进行关联.当Thread上的Looper创建好了,他就被连接到了消息队列.Looper就成了队列和线程之前的中介.设置过程是在线程的run方法中完成的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ConsumerThread extends Thread &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void run()&#123;</span><br><span class="line">        Looper.prepare();//1</span><br><span class="line">        </span><br><span class="line">        //Handler creation omitted.</span><br><span class="line">        </span><br><span class="line">        Looper.loop();//2</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>第一步是创建Looper,这一步是由静态的 prepare() 方法完成的;它会创建一个消息队列并将当前的线程与之关联.此时,队列已经做了了消息插入的准备,但是它们没有被分发到消费者线程.</li><li>开始在消息队列中处理消息.这是一个阻塞方法,从而确保run()方法不会终止,当run()阻塞的时候,Looper分发消息到消费者线程进行处理.</li></ol><p>一个线程只能有一个相关的Looper,当应用尝试设置第二个Looper的时候会发生运行时错误.因此,一个线程只有有一个消息队列,意味着有多个生产者线程发送的消息在消费者线程中是顺序处理的.<br>因此,当前的消息在它被执行之前都会推迟后续消息的执行.需要长时间执行的消息不能被使用,因为它们可能对队列中其它重要的消息造成延迟.</p><h2 id="Looper-终止"><a href="#Looper-终止" class="headerlink" title="Looper 终止"></a>Looper 终止</h2><p>Looper如果要停止执行消息的话,就要使用 quit 或者 quitSafely. quit()让looper停止对队列中的其余消息进行分发,所有队列中等待的消息包括那些已经到到分发栏栅的,都会被丢弃.另一方面,quitSafely,只会丢弃那些没有到达分发栏栅的消息.在Looper终止之前,符合分发条件的等待消息会被处理掉. quitSafely 是在api 18添加的,之前的api只支持quit.</p><p>终止Looper并没有终止线程,它只是跳出了Looper.loop()并让线程恢复运行在调用loop的方法.但是你不能启动旧的Looper或新建一个looper,所以线程就不能在入队和处理消息了.如果你调用Looper.prepare(),它会抛出运行时异常,因为线程已经有Looper附加了.如果你调用Looper.loop,它会阻塞,但是没有消息会从队列中分发出来.</p><h2 id="UI-线程-Looper"><a href="#UI-线程-Looper" class="headerlink" title="UI 线程 Looper"></a>UI 线程 Looper</h2><p>UI 线程是唯一一个默认就有相关联Looper的线程.和其它由应用本身创建的线程一样,它是一个常规的线程,但是Looper是在应用组件初始化之前就被关联到线程的.</p><p>UI 线程 Looper和其它应用线程Looper还是由一些实际区别的:</p><ul><li>它能通过Looper.getMainLooper()方法从任意地方访问.</li><li>它不能被终止.调用Looper.quit()会抛出运行时异常.</li><li>运行时通过Looper.prepareMainLoop()将Looper和UI线程关联在一起.每一个应用只能执行一次.正因如此,尝试附加主线程Looper到其它线程或抛出异常.</li></ul><h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><p>目前为止,关注点在于Android线程通讯的内部机制,但是应用大部分是和android.os.Hanlder打交道的.它是一个双侧的API,既要处理消息的插入队列也要进行消息的处理.如同 4-5所示,它同时由生产者线程和消费者线程调用来进行以下处理:</p><ul><li>创建消息</li><li>插入消息到队列中</li><li>在消费者线程处理消息</li><li>队列中消息的管理</li></ul><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>谈及到Hanlder的职责,handler 与 Looper ,消息队列以及消息都有交互.如图4-4所示:handler唯一直接的关系是和Looper,Looper是和消息队列连接的.如果没有Looper,handler就不能工作,它们不能与队列组合来插入消息,因此它们不能收到任何消息进行处理.因此,handler实例是构造的时候与Looper 实例绑定的:</p><ul><li><p>没有显式Looper的构造器绑定的是当前线程的Looper:UI线程由平台内部的类android.app.ActivityThread 管理</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Hanlder();</span><br><span class="line">new Hanlder(Hanlder.Callback)</span><br></pre></td></tr></table></figure></li><li><p>在构造器中显式指定Looper进行绑定</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Handler(Looper);</span><br><span class="line">new Hanlder(Looper,Hanlder.Callback);</span><br></pre></td></tr></table></figure></li></ul><p>如果没有显式构造器的Looper在一个没有Looper的线程被调用(例如:它没有调用Looper.prepare()),就没东西让Hanlder绑定了,就会导致运行时异常.一旦handler绑定到了一个Looper,这个绑定是不可变的.</p><p>一个线程能够有多个handler,来自这些hanlder的消息共存于消息中,但是能够被分发到正确的Handler实例.如图 4-9所示:</p><p><img src="//jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-9.png" alt></p><p>图4-9 多个handler使用同一个Looper,插入消息的handler和处理消息的handler是同一个.</p><p>多个hanlder了并没有导致并发执行,消息仍然在一个队列中并按序被处理.</p><h2 id="消息创建"><a href="#消息创建" class="headerlink" title="消息创建"></a>消息创建</h2><p>为简单起见,Handler类提供了如下所示的工产方法封装用来创建Message类的对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Message obtainMessage(int what, int arg1,int arg2);</span><br><span class="line">Message obtainMessage()</span><br><span class="line">Message obtainMessage(int what,int arg1,int arg2,Object obj)</span><br><span class="line">Message obtainMessage(int what,Object obj)</span><br></pre></td></tr></table></figure><p>从Handler获取的message是从消息池获取而来的,并且与请求它的Hanlder实例隐式连接.这个连接使Looper能将每个消息分发到正确的Hanlder成为可能.</p><h2 id="消息插入"><a href="#消息插入" class="headerlink" title="消息插入"></a>消息插入</h2><p>根据消息类型的不同,Hanlderyou着多种插入队列的不同方式.插入任务消息的方法是以post为前缀的,而数据消息是以send为前缀的:</p><ul><li><p>添加一个任务到消息队列当中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean post(Runnable r)</span><br><span class="line">boolean postAtFrontQueue(Runnable r)</span><br><span class="line">boolean postAtTime(Runnable r, Object token,long uptimeMillis)</span><br><span class="line">boolean postAtTime(Runnable r,long uptimeMills)</span><br><span class="line">boolean postDealyed(Runnable r,long dealyMillis)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>添加一个数据对象到消息队列中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean sendMessage(Message msg)</span><br><span class="line">boolean sendMessageAtFrontOfQueue(Message msg)</span><br><span class="line">boolean sendMessageAtTime(Message msg,long uptimeMillis)</span><br><span class="line">boolean sendMessageDelayed(Messsage msg,long delayMillis)</span><br></pre></td></tr></table></figure></li><li><p>添加一个简单数据对象到消息队列中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean sendEmptyMessage(int what)</span><br><span class="line">boolean sendEmptyAtTime(int what, long uptimeMillis)</span><br><span class="line">boolean sendEmptyDelayed(int what, long delayMillis)</span><br></pre></td></tr></table></figure></li></ul><p>所有的插入方法都会放一个消息到队列中,即使应用没有显式地创建消息对象.post系列中的Runnable, send 系列中的 what,都被包含在Message对象中,因为消息是队列中唯一可以包含的对象.</p><p>每个插入消息的队列都有会有个指示消息能够被分发到消费者线程的的时间参数.队列的排序是基于时间参数的,并且踏实应用唯一能影响分发顺序的方式:</p><p>default:</p><p>&emsp;&emsp;&emsp;&emsp; 立即能够被分发</p><p>at_front    </p><p>&emsp;&emsp;&emsp;&emsp; 消息在时间为0的时候被分发.因此,它是下一个被分发的消息,除非有另一个消息在它被处理之前插入了.</p><p>delay</p><p>&emsp;&emsp;&emsp;&emsp; 在能够被分发之前延长一定的时间</p><p>uptime</p><p>&emsp;&emsp;&emsp;&emsp; 消息能够被分发的绝对时间</p><p>尽管显式的延迟和运行时间是可以指定的,但是咩哥消息的处理时间是不确定的.这依赖于已有消息的处理时间和操作系统调度情况.</p><p>插入消息到队列中不是保险的.如下表4-3所示的一些常见错误会发生.</p><p>表4-3.消息插入错误</p><table><thead><tr><th>错误</th><th>错误返回</th><th>常见的应用问题</th></tr></thead><tbody><tr><td>消息没有Hanlder</td><td>RuntimeException</td><td>消息是从一个没有Hanlder的Message.obtain()方法创建的.</td></tr><tr><td>Message已经被分发了并且已经被处理了</td><td>RuntimeExeception</td><td>同样的消息被插入了两次</td></tr><tr><td>Looper已经退出</td><td>返回 false</td><td>在Looper.quit()被调用之后消息被插入了</td></tr></tbody></table><p>Handler类的dispatchMessage()方法是用来让Looper分发消息到消费者线程的.如果由应用直接使用,消息会在调用的线程处理而不是在消费者线程处理.</p><h2 id="例子-双向消息传递"><a href="#例子-双向消息传递" class="headerlink" title="例子: 双向消息传递"></a>例子: 双向消息传递</h2><p>HanlderExampleActivity 模拟了一个长时间运行的操作,这个操作是在用户点击按钮的时候启动的.长时间运行的任务在后台线程运行,与此同时,用户界面上展示了一个进度条,这个进度条会在结果返回UI线程的时候被移除.</p><p>首先,设置Activity:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class HanlderExampleActivity entends Activity&#123;</span><br><span class="line">   </span><br><span class="line">     private final static int SHOW_PROGRESS_BAR=1;</span><br><span class="line">     private final static int HIDE_PROGRESS_BAR=0;</span><br><span class="line">     private BackgroundThread mBackgroundThread;</span><br><span class="line">     </span><br><span class="line">     private TextView mText;</span><br><span class="line">     private Button mButton;</span><br><span class="line">     private ProgressBar mProgressBar;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     @Override</span><br><span class="line">     public void onCreate(Bundle savedInstanceState)&#123;</span><br><span class="line">         super.onCreate(savedInstanceState);</span><br><span class="line">         setContentView(R.layout.activity_handler_example);</span><br><span class="line">         </span><br><span class="line">         mBackgroundThread=new BackgroundThread();</span><br><span class="line">         mBackgroundThread.start();//1</span><br><span class="line">         </span><br><span class="line">         mText=(TextView)findViewById(R.id.text);</span><br><span class="line">         mProgressBar=(ProgressBar)findViewById(R.id.progress);</span><br><span class="line">         mButton.setOnClickListener(new OnClickListener()&#123;</span><br><span class="line">         </span><br><span class="line">             @Override</span><br><span class="line">             public void onClick(View v)&#123;</span><br><span class="line">                 </span><br><span class="line">                 @Override</span><br><span class="line">                 public void click(View v)&#123;</span><br><span class="line">                 </span><br><span class="line">                    mBackgroundThread.doWork(); //2</span><br><span class="line">                 &#125;</span><br><span class="line">         </span><br><span class="line">         &#125;);</span><br><span class="line">          </span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();   </span><br><span class="line">        mBackgroundThread.exit();//3</span><br><span class="line">    &#125;</span><br><span class="line">    //... The rest of the Activity is defined futher down</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>带有消息队列的后台线程是在HanlderExampleActivity创建的时候启动的.它处理了来自UI线程的任务.</li><li>当用户点击按钮,一个新的任务就被发送到后续线程.因为任务在后台线程是线性处理的,在它们被处理完之前,多次按钮点击可能导致排队.</li><li>当 HanlderExampleActivity 被销毁的时候,后台线程被终止了.</li></ol><p>后台线程是用来承载来自UI线程的任务的.当它运行的时候,在HanlderExampleActivity生命周期期间它就能接受消息.它并没有暴露出它内部的Hanlder, 而是将所有对Handler的访问封装成公有方法 doWork 和 exit:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private class BackgroundThread extends Thread &#123;</span><br><span class="line">   </span><br><span class="line">   private Handler mBackgroundHanlder;</span><br><span class="line">   </span><br><span class="line">   public void run()&#123; //1</span><br><span class="line">      Looper.prepare();</span><br><span class="line">      mBackgroundHanlder=new Hander();//2</span><br><span class="line">      Looper.loop()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void doWork()&#123;</span><br><span class="line">      mBackgroundHanlder.post(new Runnable()&#123;//3</span><br><span class="line">          @Override</span><br><span class="line">          public void run()&#123;</span><br><span class="line">             Message uiMsg=mUiHanlder.obtainMessage(</span><br><span class="line">                SHOW_PROGRESS_BAR,0,0,null);//4</span><br><span class="line">             mUiHanlder.sendMessage(uiMsg);//5</span><br><span class="line">             </span><br><span class="line">             Random r=new Random();</span><br><span class="line">             int randomInt=r.next(5000);</span><br><span class="line">             SystemClock.sleep(randomInt);//6</span><br><span class="line">             </span><br><span class="line">             uiMsg=mUiHanlder.obtainMessage(</span><br><span class="line">                  HIDE_PROGERSSS_BAR,randomInt,0,null);//7</span><br><span class="line">                  mUiHanlder.sendMessage(uiMsg);//8</span><br><span class="line">                </span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">      &#125;);</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void exit()&#123;//9</span><br><span class="line">       mBackgroundHanlder.getLooper().quit()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将Looper与线程相关联</li><li>Handler只处理Runnable.因此,它不需要实现Hanlder.handleMessage.</li><li>发出一个需要在后台线程执行的长时间任务</li><li>创建一个只包含一个what参数以及一个SHOW_PROGRESS_BAR命令的的消息对象给到UI线程,从而它能够显示进度条.</li><li>发送消息到UI线程</li><li>模拟一个随机时间长度的长时间任务</li><li>创建一个带有randomInt的消息对象,它被传入arg1参数.what参数包含了一个命令-HIDE_PROGRESS_BAR 来移除进度条.</li><li>最后消息通知UI线程任务结束了,并分发出一个结果</li><li>退出Looper,从而线程能终止</li></ol><p>UI线程定义了它自己的Hanlder,从而它能接收命令来控制进度条来用来自后台线程的结果来更新ui界.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private final Handler mUiHanlder =new Hanlder() &#123;</span><br><span class="line"></span><br><span class="line">    public void hanldeMessage(Message msg)&#123;</span><br><span class="line">        </span><br><span class="line">        switch(msg.what)&#123;</span><br><span class="line">           case SHOW_PROGRESS_BAR:</span><br><span class="line">             mProgressbar.setVisibility(View.VISIBLE);</span><br><span class="line">             break;</span><br><span class="line">           case HIDE_PROGRESS_BAR:</span><br><span class="line">             mText.setText(String.valueOf(msg.arg1));</span><br><span class="line">             mProgress.setVisibility(View.INVISIBLE)</span><br><span class="line">              break;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>显示进度条</li><li>隐藏进度条并用处理好的结果更新TextView</li></ol><h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p>被Looper分发的消息由Hanlder在消费者线程处理,消息类型决定了处理过程:</p><p><em>任务消息</em></p><p>消息对象只包含了一个Runnable并且没有数据.因此,处理过程定义在Runnable的在run()方法中,这个过程自动地是在消费者线程执行的,而不用调用Hanlder.handleMessage().</p><p><em>数据消息</em></p><p>当消息包含数据的时候,Hanlder是数据的接收者并负责对它进行处理.消费者线程以重载hanlder.handleMessage(Message msg) 方法来处理数据.如下所示有两种方式:</p><p>其中一种是将定义handlerMessage作为创建Handler的一部分.这个方法应该在消息队列准备好的时候就定义(在Looper.prepare()调用之后)但是在消息获取开始之前(在Looper.loop()被调用之前).</p><p>以下是一个设置数据消息处理的模版:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ConsumerThread extends Thread &#123;</span><br><span class="line">    Hanlder mHandler;</span><br><span class="line">    @Overide</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mHanlder=new Hanlder()&#123;</span><br><span class="line">           public void hanldeMessage(Mssage msg)&#123;</span><br><span class="line">              //Process data message here</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;;) </span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这份代码中, Handler是以匿名内部类的形式定义的,但是它也能够被定义成常规的内部类.</p><p>有一种替代扩展Handler类的替代方式是使用Hanlder.Callback.它定义了一个handleMessage()方法以及一个hanlder.hanldeMessage()所有没有的返回参数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Callback&#123;</span><br><span class="line">    public boolean hanldeMessage(Message msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了Callback接口,就没有必要去扩展Hanlder类了.实际上,Callback实现能够被传递到Hanlder构造器中,然后它会接收被分发的消息进行处理:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class HanlderCallbackActivity extends Activity implements Hanlder.Callback &#123;</span><br><span class="line">   Hanlder mUiHanlder;</span><br><span class="line">   </span><br><span class="line">   @Override </span><br><span class="line">   public void onCreate(Bundle savedInstanceState)&#123;</span><br><span class="line">       super.onCreate(savedInstance);</span><br><span class="line">       mUiHanlder=new Hanlder(this);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">   public boolean handleMessage(Message message)&#123;</span><br><span class="line">       //Process messages</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果消息被处理了,Callback.HandleMessage()应该返回true,它保证了消息完成处理后不再进行处理.但是,如果返回了false,消息被传入了Handler.hanldeMessage()方法来进一步处理,它添加了一个消息处理者,这个调用过程在Handler自己的方法之前.Callback 处理者能够在Hanlder接收到消息之前对消息进行拦截和修改.以下的代码展示了用Callback()方法拦截消息的原则:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class HanlderCallbackActivity entends Activity implements Hanlder.Callback&#123;//1</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">   public boolean hanldeMessage(Message msg)&#123;//2</span><br><span class="line">       switch(msg.what)&#123;</span><br><span class="line">          case 1:</span><br><span class="line">             msg.what=11;</span><br><span class="line">             return true;</span><br><span class="line">          default:</span><br><span class="line">              msg.what=22;</span><br><span class="line">             return false;    </span><br><span class="line">       &#125; </span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   //Invoked a button click</span><br><span class="line">   </span><br><span class="line">   public void onHanlderCallback(View v)&#123;</span><br><span class="line">       Hanlder hanlder=new Hanlder(this)&#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void handleMessage(Message msg)&#123;</span><br><span class="line">             //Procress message//3</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       handler.sendEmptyMessage(1);//4</span><br><span class="line">       hanlder.sendEmptyMessage(2);//5</span><br><span class="line">         </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>HanlderCallbackActivity 实现了 Callback接口来拦截消息</li><li>Callback 实现拦截了消息.如果 msg.what 是1,它就返回true-消息就被处理了.否则的话,它就会将msg.what的值修改为22并返回false,消息没有被处理,所以它被传递到了Hanlder的handle实现.</li><li>在第二个Hanlder中处理消息</li><li>插入一个msg.what=1的消息,这个消息被Callback拦截并返回true.</li><li>插入一个msg.what=2的消息.这个消息被Callback改变然后传递给Hanlder,从属Hanlder 出来的msg=22</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)添加 Flutter 到已有的应用</title>
      <link href="/2020/03/23/Flutter/development/add-flutter-to-existing-app/add-to-app/"/>
      <url>/2020/03/23/Flutter/development/add-flutter-to-existing-app/add-to-app/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/development/add-to-app" target="_blank" rel="noopener">原文链接</a></p><p>有时候,短时间内用 Flutter 重写你整个应用是不切实际的. 对于这些情况来说,Flutter 能够以库或者模块的形式嵌入到你已有的应用中.然后这个模块就能够导入到你的 Android 或 iOS应用中,使得你的应用的部分UI用 Flutter 进行渲染.或者,只是运行共享Dart的逻辑.</p><p>区区几步,你就能把 Flutter的生产力和表现力带到你的应用中.</p><p>在 Flutter 1.12 版本中,支持的基本场景是一个应用同一时刻支持集成一个全屏的 Flutter 实例. 它当前有着以下的限制:</p><ul><li>运行多个Flutter实例或运行部分的界面视图可能会有未知的行为</li><li>在后台模式中使用 Flutter 仍然处于过程阶段</li><li>将Flutter库打包进另一个共享的库或者打包多个Flutter库到应用中目前是不支持的.</li><li>在向 Android 添加 flutter 中使用的插件应该经受<a href="https://flutter.dev/go/android-plugin-migration" target="_blank" rel="noopener">https://flutter.dev/go/android-plugin-migration</a>这一步,并使用基于 FlutterPlugin 的 API. 不支持 Flutter 插件 可能有未知的行为如果它们作出的假定在 add-to-app 中不成立的(例如假定 Flutter Activity 是一直在的)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 混合开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/02/19/DesignPattern/start/"/>
      <url>/2020/02/19/DesignPattern/start/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h2><p>在软件工程领域,设计模式其实就是前人总结的一些关于编写代码的一些套路.所谓套路就是针对不同问题而提出的最佳实践方案.而这里的问题都归于面向对象编程领域,对于过程编程来说就不是特别适用了.</p><p>然后设计模式的目标是什么呢? 我们可以用这本书的书名来回答,设计模式-可复用面向对象软件的基础.复用,这是一个贯穿设计模式始终的东西.对于码农的日常来说,也是说的通的,我们的目标是少写代码,甚至是不写代码,代码的可复用性就显得尤为重要.而此书中的设计模式,指的是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述.而这些设计模式的同样是要基于面向对象的,而对于面向对象来说,“继承”、“封装”、“多态”则是逃不开的机制.</p><a id="more"></a><h2 id="知道什么是设计模式-我们还需要用统一的格式描述它"><a href="#知道什么是设计模式-我们还需要用统一的格式描述它" class="headerlink" title="知道什么是设计模式,我们还需要用统一的格式描述它."></a>知道什么是设计模式,我们还需要用统一的格式描述它.</h2><p>模式名和分类-模式名简洁地描述模式的本质。</p><p>意图-设计模式是做什么的？它的基本原理和意图是什么？</p><p>别名-模式的其他名称</p><p>动机-用以说明一个设计问题以及如何使用模式中的类、对象来解决该问题的特定情景。</p><p>适用性-什么情况下可以使用该设计模式</p><p>结构-对象建模技术</p><p>参与者-指设计模式中的类和或对象以及它们各自的职责。</p><p>效果-模式怎么支持他的目标。</p><p>实现、代码示例、已知应用、</p><h2 id="编目："><a href="#编目：" class="headerlink" title="编目："></a>编目：</h2><p>Abstract Factory- 提供一个创建一系列相关或相互依赖的接口，而无须指定它们的具体的类。</p><p>Adapter- 将一个类的接口转换成客户希望的另一个接口。</p><p>Bridge- 将抽象部分与它的实现部分分离，使它们都可以独立变化</p><p>Builder- 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><p>Chain of Responsibility- 为解除请求的发送者和接收者之前的耦合,而使多个对象都有机会处理这个请求.将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它.</p><p>Command- 将一个请求封装为一个对象,从而使你可用不同的请求对客户进行参数化,对请求排队或记录请求日志,以及支持可取消的操作.</p><p>Composite- 将对象组合成树形结构以表示“部分-整体”的层次结构.Composite 使得客户对单个对象和符合对象的使用具有一致性.</p><p>Decorator-动态地给一个对象添加一些额外的职责.就扩展功能而言,Decorator模式比生成字累方式更为灵活.</p><p>Facade: 为子系统中的一组接口提供一个一致的界面,Facade模式定义了一个高层的接口,这个接口使得对单个对象和符合对象的使用具有一致性.</p><p>Flyweight: 运用共享技术有效地支持大量细粒度的对象</p><p>Interpreter: 给定一个语言,定义它的文法的表示,并定义一个解释器,并解释适用该表示来解释语言中的句子</p><p>Iterator: 提供一方法顺序访问一个聚合对象中的各个元素,而由不需要暴露该对象的内部表示.</p><p>Mediator: 用一个中介对象来封装一系列的对象交互.中介者使各对象不需要显式地相互引用,从而使其耦合松散,而且可以独立改变它们之间的交互.</p><p>Memento: 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态,这样以后就可将该对象恢复到保存的状态</p><p>Observer: 定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新</p><p>Prototype: 用原型实例指定创建对象的种类,并且通过拷贝这个原型来创建新的对象</p><p>Proxy: 为其他对象提供一个代理以控制对这个对象访问</p><p>Singleton: 保证一个类仅有一个实例,并提供一个访问它的全局访问点.</p><p>State: 允许一个对象在其内部状态改变时改变它的行为.</p><p>Strategy: 定义一系列的算法,把它们一个个封装起来,并且使它们可相互替换.本模式是的算法的变化可独立于适用它的客户</p><p>Template Method: 定义一个操作中算法的骨架,而将一些步骤延迟到子类中.</p><p>Visitor: 表示一个作用于某对象结构中的各元素的操作.</p><p>目的(创建型、结构型、行为型)</p><p>范围(用于类还是用于对象)</p><p>模式关系</p><p>设计模式怎样解决设计问题:</p><p>寻找合适的对象</p><p>决定对象的粒度</p><p>指定对象接口</p>]]></content>
      
      
      <categories>
          
          <category> reuse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 移动开发者之问</title>
      <link href="/2019/11/16/Thinking/AndroidOrJava/"/>
      <url>/2019/11/16/Thinking/AndroidOrJava/</url>
      
        <content type="html"><![CDATA[<h2 id="移动开发黄金十年"><a href="#移动开发黄金十年" class="headerlink" title="移动开发黄金十年"></a>移动开发黄金十年</h2><p>对于移动开发者来说,现在这个时代是最坏的时代,同时也是最坏的时代.</p><a id="more"></a><p>移动开发高速发展十年之后,移动开发的各项生态已经非常完善,对于技术解决方案来说,你总是很快地就能从 stackoverflow 找到方案, 然后面向 CV 编程就可以实现了.</p><p>事物的两面性总是同时存在的,高速发展的过程中,移动业务的高速发展带来开发人员的过度膨胀,然而潮水过去之后,也就剩下那么几个抓住移动流量入口的巨头活了下来,我们已经很少看到新的有意思的平台性的应用了.</p><p>移动原生的开发需求进一步缩减,react native 以及 flutter 这些大厂产品的跨平台解决方则进一步掠夺原生移动开发者的生存空间.</p><p>同时业务方也发现,他们可能其实都不需要去做一个原生应用,考虑了推广成本等因素之后,在验证业务可行性方面,小程序是绝佳的选择.需要做能够做移动应用的厂家所剩无几了,也就是市场上对于移动开发的需求是减少了的,再也不是给我个一两百万,然后砸出个移动应用的时代了.因为,似乎所有的移动应用的机会都已经被腾讯、阿里以及字节跳动这个移动应用工厂所把持了.</p><h2 id="需求的变化"><a href="#需求的变化" class="headerlink" title="需求的变化"></a>需求的变化</h2><p>在 2014 年的时候,市场对于移动开发者的需求的量是巨大的,所以那时候似乎是会写list就能够找到一份移动开发者的工作了.然后万事万物都是动态变化的,大量的开发者使市场有了更多的选择,于是他们开始更挑了.</p><p>单纯的功能上的实现已经满足不了他们的胃口了,或者说功能上其实已经都实现的都差不多了.就像我们的社会的主要矛盾,已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾一样,市场与移动开发者之间的矛盾在于,应用已经都开发得差不多了,我们需要的是变得更好,于是乎电量优化、内存优化、性能优化、启动优化各种可能的优化,被列入了要求中.</p><p>同样,平平淡淡的清水交互已经不能够满足了,他们需要更炫酷的东西,自定义控件什么的当然也要在射程范围之内.</p><p>此外,随着网络速度的发展,图片和音视频的处理这方面的需求也是日益增长的.</p><h2 id="以不变应万变"><a href="#以不变应万变" class="headerlink" title="以不变应万变"></a>以不变应万变</h2><p>想来想去,前端界实在是太乱了,各种框架更新的步伐,真的是让人学不动了.还不如搞后端,毕竟这么多年了,Spring 还是那个 Spring,但是如果只是从界面的铺设到数据的增删改查,那未免显得有点悲凉.都是工具,谈什么本质上的区别呢.</p><p>其实抛开所有上层的实现方式的不同,计算机背后的东西其实一直没有变过,数据,数据还是数据.<br>以及围绕数据所展开的处理和结构组织.</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关于技术的一些思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)状态管理参考</title>
      <link href="/2019/05/30/Flutter/development/data-and-backend/state-mgmt/options/"/>
      <url>/2019/05/30/Flutter/development/data-and-backend/state-mgmt/options/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/options" target="_blank" rel="noopener">原文链接</a></p><blockquote><p>译者序：官方关于状态管理，也就是架构的一份参考,并添加了一些前后相关的文章。从简单的 setState,到稍微复杂的 InheritedWidget 和 Scoped model，到足以应对大型项目的 Redux 和 Bloc，都给出了来自社区的技术分享博客。其中带有灰色背景的为中文翻译版本，没有灰色背景的为视频、github项目地址或者尚未翻译的博客。</p></blockquote><p>状态管理是一个复杂的话题。 如果你认为某些问题没有得到解答，或者这些页面上描述的方法对你的用例不可行，那么你可能是对的。</p><p>通过以下链接了解更多信息，其中许多链接由 Flutter 社区提供：</p><a id="more"></a><h2 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h2><p><a href="https://www.youtube.com/watch?v=RS36gBEp8OI&feature=youtu.be" target="_blank" rel="noopener">使用 Flutter 构建响应式应用</a>,一个来自 Google I/O 2018的视频，以及<a href="https://medium.com/flutter-io/build-reactive-mobile-apps-in-flutter-companion-article-13950959e381" target="_blank" rel="noopener">一篇随附的文章</a>。<a href="http://fluttersamples.com/" target="_blank" rel="noopener">Flutter架构样例</a>,作者 Brian Egan。</p><h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><ul><li><a href="/2019/04/18/Flutter/development/ui/interactive/"><code>添加交互性到你的 Flutter 应用中去</code></a>，一篇Flutter教程</li><li><a href="/2019/04/18/Flutter/development/data-and-backend/state-mgmt/options/setState/Basic%20state%20management%20in%20Google%20Flutter/"><code>Google Flutter 中的基础状态管理</code></a>，作者 Agung Surya</li></ul><h2 id="InheritedWidget-和-Scoped-model"><a href="#InheritedWidget-和-Scoped-model" class="headerlink" title="InheritedWidget 和 Scoped model"></a>InheritedWidget 和 Scoped model</h2><ul><li><a href="/2019/04/18/Flutter/development/data-and-backend/state-mgmt/options/InheritedWidget-Scopedmodel/Using%20Flutter%20Inherited%20Widgets%20Effectively/"><code>高效地使用 Flutter 的 InheritedWidget</code></a>，作者 Eric windmill</li><li><a href="/2019/04/18/Flutter/development/data-and-backend/state-mgmt/options/InheritedWidget-Scopedmodel/YouMightNotNeedReduxThe%20FlutterEdition/"><code>你可能不需要 Redux：Flutter 版本</code></a>，作者 Ryan Edge</li><li><a href="https://www.youtube.com/watch?v=-MCeWP3rgI0" target="_blank" rel="noopener">在 Dart 的 Flutter 框架中使用 scoped model 模式管理状态</a>,一个来自 Tensor Programming 的视频</li><li><a href="https://www.youtube.com/watch?v=j-27MZwRbFw" target="_blank" rel="noopener">Flutter：InheritedWidget 和 Scoped model 解析，第一部分</a>，一个由 MtechViral 制作的视频</li><li><a href="https://www.youtube.com/watch?v=Oql5bU-Uvso" target="_blank" rel="noopener">Flutter 状态管理-scoped model</a></li><li><a href="https://pub.dartlang.org/packages/scoped_model" target="_blank" rel="noopener">Scoped model 包</a></li><li><a href="/2019/04/12/Flutter/development/data-and-backend/state-mgmt/options/InheritedWidget-Scopedmodel/Widget-State-BuildContext-InheritedWidget/"><code>Widget-State-Context-InheritedWidget</code></a>,作者 Didier Bolelens</li></ul><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><ul><li><a href="https://www.youtube.com/watch?v=9ZkLtr0Fbgk" target="_blank" rel="noopener">使用 Redux和Flutter进行动画管理</a>,一个来自 DartConf 2018 的视频,<a href="https://medium.com/flutter/animation-management-with-flutter-and-flux-redux-94729e6585fa" target="_blank" rel="noopener">Medium上配套文章</a>。</li><li><a href="https://pub.dev/" target="_blank" rel="noopener">发布网站</a>上的<a href> Flutter Redux 包</a></li><li><a href="/2019/04/20/Flutter/development/data-and-backend/state-mgmt/options/Redux/introduction%20to%20Redux%20in%20Flutter/"><code>Flutter 中的 Redux 介绍</code></a>,作者 Xavi Rigau</li><li><a href="/2019/04/21/Flutter/development/data-and-backend/state-mgmt/options/Redux/Flutter%20+%20Redux%E2%80%8A%E2%80%94%E2%80%8AHow%20to%20make%20Shopping%20List%20App/"><code>Flutter + Redux-如何做出一个购物清单应用</code></a>，一篇Paulina Szklarska在 Hackernoon上的文章。</li><li><a href="https://www.youtube.com/watch?v=Wj216eSBBWs" target="_blank" rel="noopener">在 Flutter 中用 Redux 构建一个TODO应用(CRUD)-第一部分</a>，一个来自 Tensor Programming 的视频</li><li><a href="https://medium.com/flutterpub/flutter-redux-thunk-27c2f2b80a3b" target="_blank" rel="noopener">Flutter Redux Thunk的一个例子</a>,作者 Jack Wong</li><li><a href="https://hillel.dev/2018/06/01/building-a-large-flutter-app-with-redux/" target="_blank" rel="noopener">使用 Redux 构建一个大型应用</a>,作者 Hillel Coren</li><li><a href="https://github.com/alibaba/fish-redux/" target="_blank" rel="noopener">基于 Redux 数据管理的组装式 flutter 应用框架</a>,作者 Alibaba闲鱼团队</li></ul><h2 id="BLoc-Rx"><a href="#BLoc-Rx" class="headerlink" title="BLoc/Rx"></a>BLoc/Rx</h2><ul><li><a href="/2019/04/15/Flutter/development/data-and-backend/state-mgmt/options/BloC/Architect%20your%20Flutter%20project%20using%20BLOC%20pattern/"><code>使用 BLoc 模式架构你的 Flutter 应用</code></a>,作者Sagar Suri</li><li><a href="/2019/04/15/Flutter/development/data-and-backend/state-mgmt/options/BloC/Architect%20your%20Flutter%20project%20using%20BLOC%20pattern/"><code>使用 BLoc 模式架构你的 Flutter 应用第二部分</code></a>,作者Sagar Suri</li><li><a href="https://felangel.github.io/bloc" target="_blank" rel="noopener">Bloc 库</a>,作者Felix Angelov</li><li><a href="/2019/04/13/Flutter/development/data-and-backend/state-mgmt/options/BloC/ReactiveProgramming-Streams-BLoC/"><code>Flutter中的响应式编程(Reactive Programming)、流(Streams)以及业务逻辑组件(BloC)</code></a>，作者Didier Boelens</li><li><a href="/2019/04/13/Flutter/development/data-and-backend/state-mgmt/options/BloC/ReactiveProgramming-Streams-BLoC-PracticalUseCases/"><code>响应式编程-流-Bloc-实例</code></a>，作者Didier Boelens</li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Futures - Isolates - Event Loop</title>
      <link href="/2019/05/12/Flutter/Dart/Async/Futures%20-%20Isolates%20-%20Event%20Loop%20/"/>
      <url>/2019/05/12/Flutter/Dart/Async/Futures%20-%20Isolates%20-%20Event%20Loop%20/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.didierboelens.com/2019/01/futures---isolates---event-loop/" target="_blank" rel="noopener">原文链接</a></p><p>单线程，多线程，同步和异步。本文介绍了 Flutter 中的不同代码执行模式。</p><p>难度：中级</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我最近收到了一些与 <code>Future</code> ，<code>async</code>，<code>await</code>，<code>Isolate</code> 和并行处理概念相关的问题。</p><p>除了这些问题，一些人在处理代码序列的顺序执行的时候遭遇到了问题。</p><p>我认为利用一篇文章的机会来弄清楚这些概念是非常有用的，文章主要是围绕异步和并行处理的概念展开的。</p><h2 id="Dart是一种单线程语言"><a href="#Dart是一种单线程语言" class="headerlink" title="Dart是一种单线程语言"></a>Dart是一种单线程语言</h2><p>首先，每个人都需要记住，Dart 是单线程，并且 Flutter 依赖于  Dart。</p><blockquote><p>重要</p></blockquote><blockquote><p>Dart一次执行一个操作，一个接一个地，意味着只要一个操作正在执行，它就不会被任何其他Dart代码中断。</p></blockquote><p>换句话说，如果你考虑一个纯粹的同步方法，后者将是唯一一个在完成之前执行的方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myBigLoop()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</span><br><span class="line">        _doSomethingSynchronously();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，myBigLoop() 方法的执行在完成之前永远不会被中断。因此，如果此方法需要一些时间，则在整个方法执行期间将“阻塞”应用程序。</p><h2 id="Dart-执行模型"><a href="#Dart-执行模型" class="headerlink" title="Dart 执行模型"></a>Dart 执行模型</h2><p>表象背后，Dart 实际上是如何管理要执行的操作序列的？</p><p>为了回答这个问题，我们需要看看 Dart 代码定序器，被称为<code>事件循环</code>。</p><p>当你启动 Flutter (或任何 Dart)应用程序时，将创建并启动新的 Thread 进程（在Dart语言中等价于“Isolate”）。该线程将是整个应用程序中你唯一需要关注的线程。</p><p>因此，创建此线程时，Dart 自动</p><ol><li>初始化2个队列，即 “<strong>MicroTask</strong>” 和 “<strong>Event</strong>” FIFO队列;</li><li>执行<code>main()</code>方法，并且一旦代码执行完成，</li><li>就启动 <code>Event Loop</code></li></ol><p>在线程的整个生命周期中，单个内部和不可见的进程（被称为“事件循环”）将驱动代码按顺序排列执行，具体取决于微任务队列和事件队列的内容。</p><p>事件循环对应于某种无限循环，节奏由内部时钟控制，在每次滴答时，如果没有其他 Dart 代码被执行，则执行如下操作：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> eventLoop()&#123;</span><br><span class="line">    <span class="keyword">while</span> (microTaskQueue.isNotEmpty)&#123;</span><br><span class="line">        fetchFirstMicroTaskFromQueue();</span><br><span class="line">        executeThisMicroTask();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventQueue.isNotEmpty)&#123;</span><br><span class="line">        fetchFirstEventFromQueue();</span><br><span class="line">        executeThisEventRelatedCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我们所看到的，微任务队列优先于事件队列，但这2个队列的用途是什么？</p><h3 id="MicroTask-Queue"><a href="#MicroTask-Queue" class="headerlink" title="MicroTask Queue"></a>MicroTask Queue</h3><p>微任务队列用于非常短的需要异步运行的内部操作，就在其他操作完成后，并且在交还给事件队列之前。</p><p>作为微任务的一个例子，你可以想象必须在资源关闭后立即处置它。由于关闭过程可能需要一些时间才能完成，你可以编写如下内容：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MyResource myResource;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> closeAndRelease() &#123;</span><br><span class="line">        scheduleMicroTask(_dispose);</span><br><span class="line">        _close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _close()&#123;</span><br><span class="line">        <span class="comment">// The code to be run synchronously</span></span><br><span class="line">        <span class="comment">// to close the resource</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _dispose()&#123;</span><br><span class="line">        <span class="comment">// The code which has to be run</span></span><br><span class="line">        <span class="comment">// right after the _close()</span></span><br><span class="line">        <span class="comment">// has completed</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是大多数时候你不必使用的东西。例如，整个 Flutter 源代码仅引​​用scheduleMicroTask()方法7次。</p><p>所以，最好考虑使用事件队列。</p><h3 id="Event-Queue"><a href="#Event-Queue" class="headerlink" title="Event Queue"></a>Event Queue</h3><p>事件队列用于引用由此产生的操作</p><ul><li>外部事件如<ul><li>I/O;</li><li>手势;</li><li>绘制;</li><li>计时器;</li><li>流;</li><li>…</li></ul></li><li>futures</li></ul><p>实际上，每次触发外部事件时，要执行的相应代码都会被引用到事件队列中。</p><p>一旦不再运行任何微任务，事件循环将考虑事件队列中的第一项并执行它。</p><p>值得注意的是，Futures 也通过事件队列处理。</p><h3 id="Futures"><a href="#Futures" class="headerlink" title="Futures"></a>Futures</h3><p>Future 对应于一个异步运行的任务，并且这个任务会在将来某个时间点完成(或失败)。</p><p>当你实例化一个新的 Future 时：</p><ul><li>该 Future 的一个实例被创建并记录在由 Dart 管理的内部数组中;</li><li>需要由此 Future 执行的代码直接推送到事件队列中;</li><li>future 的实例返回状态（=未完成）;</li><li>如果有的话，执行下一个同步代码（而不是 Future 的代码）</li></ul><p>只要事件循环从事件队列中获取它，Future 将引用的代码将像任何其他Event一样执行。</p><p>当该代码将被执行并将完成(或失败)时，将直接执行 then() 或 catchError()。</p><p>为了说明这一点,我们来看下面的例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Before the Future'</span>);</span><br><span class="line">    Future(()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Running the Future'</span>);</span><br><span class="line">    &#125;).then((_)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Future is complete'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'After the Future'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们运行此代码，输出将如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Before the Future</span><br><span class="line">After the Future</span><br><span class="line">Running the Future</span><br><span class="line">Future is complete</span><br></pre></td></tr></table></figure><p>这完全正常，因为执行流程如下：</p><ul><li>打印（’Before the Future’）</li><li>将”(）{print（’Running the Future’）;}”添加到事件队列中;</li><li>打印（’After the Future’）</li><li>事件循环获取代码（在 bullet2 中引用）并运行它</li><li>当代码执行时，它会查找 then() 语句并运行它</li></ul><p>要记住一些非常重要的事情：</p><blockquote><p>Future 不是并行执行的，而是遵循事件循环处理的常规事件序列</p></blockquote><h3 id="Async-方法"><a href="#Async-方法" class="headerlink" title="Async 方法"></a>Async 方法</h3><p>当你使用 <code>async</code> 关键字为方法声明添加后缀时，Dart知道：</p><ul><li>该方法的结果是 Future ;</li><li>它同步运行该方法的代码直到第一个<code>await</code>关键字，然后它暂停执行该方法的其余部分;</li><li>一旦由 <code>await</code> 关键字引用的Future将完成，下一行代码将立即运行。</li></ul><p>理解这一点非常重要，因为许多开发人员，认为 <code>await</code> 会暂停执行整个流程，直到它完成。但事实并非如此。他们忘记了事件循环的工作方式。</p><p>为了更好地说明这个语句，让我们采取以下示例，让我们试着找出其执行的结果。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() <span class="keyword">async</span> &#123;</span><br><span class="line">  methodA();</span><br><span class="line">  <span class="keyword">await</span> methodB();</span><br><span class="line">  <span class="keyword">await</span> methodC(<span class="string">'main'</span>);</span><br><span class="line">  methodD();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methodA()&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'A'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methodB() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'B start'</span>);</span><br><span class="line">  <span class="keyword">await</span> methodC(<span class="string">'B'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'B end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methodC(<span class="built_in">String</span> from) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'C start from <span class="subst">$from</span>'</span>);</span><br><span class="line">  </span><br><span class="line">  Future(()&#123;                <span class="comment">// &lt;== This code will be executed some time in the future</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'C running Future from <span class="subst">$from</span>'</span>);</span><br><span class="line">  &#125;).then((_)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'C end of Future from <span class="subst">$from</span>'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'C end from <span class="subst">$from</span>'</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methodD()&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'D'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的顺序如下：</p><ol><li>A</li><li>B start</li><li>C start from B</li><li>C end from B</li><li>B end</li><li>C start from main</li><li>C end from main</li><li>D</li><li>C running Future from B</li><li>C end of Future from B</li><li>C running Future from main</li><li>C end of Future from main</li></ol><p>现在，让我们考虑上面代码中的 “methodC()” 对应于对服务器的调用，这可能需要不均匀的时间来响应。我相信很明显地说，预测确切的执行流程可能变得非常困难。</p><p>如果您对示例代码的初始期望是仅在所有内容的末尾执行 methodD()，那么你应该这么编写代码，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() <span class="keyword">async</span> &#123;</span><br><span class="line">  methodA();</span><br><span class="line">  <span class="keyword">await</span> methodB();</span><br><span class="line">  <span class="keyword">await</span> methodC(<span class="string">'main'</span>);</span><br><span class="line">  methodD();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methodA()&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'A'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methodB() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'B start'</span>);</span><br><span class="line">  <span class="keyword">await</span> methodC(<span class="string">'B'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'B end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methodC(<span class="built_in">String</span> from) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'C start from <span class="subst">$from</span>'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> Future(()&#123;                  <span class="comment">// &lt;== modification is here</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'C running Future from <span class="subst">$from</span>'</span>);</span><br><span class="line">  &#125;).then((_)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'C end of Future from <span class="subst">$from</span>'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'C end from <span class="subst">$from</span>'</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methodD()&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'D'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这给出了以下顺序：</p><ol><li>A</li><li>B start</li><li>C start from B</li><li>C running Future from B</li><li>C end of Future from B</li><li>C end from B</li><li>B end</li><li>C start from main</li><li>C running Future from main</li><li>C end of Future from main</li><li>C end from main</li><li>D</li></ol><p>在 methodC() 中在 Future 级别添加简单等待的事实会改变整个行为。</p><p>同样非常重要的是要记住：</p><blockquote><p>异步方法不是并行执行，而是遵循事件循环处理的常规事件序列。</p></blockquote><p>我想告诉你的最后一个例子如下。<br>运行 method1 和 method2 的输出是什么？它们会一样吗？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> method1()&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; myArray = &lt;<span class="built_in">String</span>&gt;[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'before loop'</span>);</span><br><span class="line">  myArray.forEach((<span class="built_in">String</span> value) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> delayedPrint(value);</span><br><span class="line">  &#125;);  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'end of loop'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> method2() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; myArray = &lt;<span class="built_in">String</span>&gt;[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'before loop'</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;myArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">await</span> delayedPrint(myArray[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'end of loop'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; delayedPrint(<span class="built_in">String</span> value) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'delayedPrint: <span class="subst">$value</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Answer:</p><table><thead><tr><th>method1()</th><th>method2()</th></tr></thead><tbody><tr><td>before loop</td><td>before loop</td></tr><tr><td>end of loop</td><td>delayedPrint: a (after 1 second)</td></tr><tr><td>delayedPrint: a (after 1 second)</td><td>delayedPrint: b (1 second later)</td></tr><tr><td>delayedPrint: b (directly after)</td><td>delayedPrint: c (1 second later)</td></tr><tr><td>delayedPrint: c (directly after)</td><td>end of loop (right after)</td></tr></tbody></table><p>你是否看到了他们的行为不一样的区别和原因？</p><p>解决方案在于，method1 使用函数 forEach() 来迭代数组。每次迭代时，它都会调用一个新的回调，它被标记为异步（因此是一个 Future )。它执行它直到它到达等待然后它将剩余的代码推送到事件队列。一旦迭代完成，它就会执行下一个语句 “print（’loop of loop’）”。完成后，事件循环将处理3个回调。</p><p>关于方法2，一切都在相同的代码“块”内运行，因此一行一行地运行（在这个例子中）。</p><p>正如你所看到的，即使在看起来非常简单的代码中，我们仍然需要记住事件循环的工作方式。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>因此，我们如何在 Flutter 中运行并行代码？这可能吗？</p><p>是的，多亏了<a href="https://api.dartlang.org/stable/2.1.0/dart-isolate/Isolate-class.html" target="_blank" rel="noopener">Isolates</a>的概念。</p><h3 id="什么是-Isolate"><a href="#什么是-Isolate" class="headerlink" title="什么是 Isolate?"></a>什么是 Isolate?</h3><p>如前所述，Isolate 对应于 Thread 概念的 Dart 版本。</p><p>然而，与“线程”的通常实现存在重大差异，这就是它们被命名为“隔离”的原因。</p><blockquote><p>Flutter中的 “Isolates” 不共享内存。不同 “Isolate” 之间的交互是通过“消息”在通信方面进行的。</p></blockquote><h3 id="每个Isolate都有自己的“事件循环”"><a href="#每个Isolate都有自己的“事件循环”" class="headerlink" title="每个Isolate都有自己的“事件循环”"></a>每个Isolate都有自己的“事件循环”</h3><p>每个“Isolate”都有自己的“事件循环”和队列（微任务和事件）。这意味着代码在Isolate内运行时，与另一个Isolate无关。</p><p>多亏了这一点，我们可以获得并行处理。</p><h3 id="如何启动隔离？"><a href="#如何启动隔离？" class="headerlink" title="如何启动隔离？"></a>如何启动隔离？</h3><p>根据你运行 Isolate 的需要，你可能需要考虑不同的方法。</p><h4 id="1-低级解决方案"><a href="#1-低级解决方案" class="headerlink" title="1.低级解决方案"></a>1.低级解决方案</h4><p>第一个解决方案不使用任何软件包，完全依赖 Dart 提供的低级 API。</p><h4 id="1-1。第1步：创造和握手"><a href="#1-1。第1步：创造和握手" class="headerlink" title="1.1。第1步：创造和握手"></a>1.1。第1步：创造和握手</h4><p>正如我之前所说，Isolates不共享任何内存并通过消息进行通信，因此，我们需要找到一种方法来在“调用者”和新 Isolate 之间建立这种通信。</p><p>每个 Isolate 都公开一个端口，用于将消息传递给该 Isolate 。这个端口叫做“SendPort”（我个人觉得这个名字有点误导，因为它是一个旨在接收/收听的端口，但这是官方名称）。</p><p>这意味着“调用者”和“新隔离者”都需要知道彼此的端口才能进行通信。这个握手的过程如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The port of the new isolate</span></span><br><span class="line"><span class="comment">// this port will be used to further</span></span><br><span class="line"><span class="comment">// send messages to that isolate</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SendPort newIsolateSendPort;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Instance of the new Isolate</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Isolate newIsolate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Method that launches a new isolate</span></span><br><span class="line"><span class="comment">// and proceeds with the initial</span></span><br><span class="line"><span class="comment">// hand-shaking</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> callerCreateIsolate() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Local and temporary ReceivePort to retrieve</span></span><br><span class="line">    <span class="comment">// the new isolate's SendPort</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ReceivePort receivePort = ReceivePort();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Instantiate the new isolate</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    newIsolate = <span class="keyword">await</span> Isolate.spawn(</span><br><span class="line">        callbackFunction,</span><br><span class="line">        receivePort.sendPort,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Retrieve the port to be used for further</span></span><br><span class="line">    <span class="comment">// communication</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    newIsolateSendPort = <span class="keyword">await</span> receivePort.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The entry point of the new isolate</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> callbackFunction(SendPort callerSendPort)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Instantiate a SendPort to receive message</span></span><br><span class="line">    <span class="comment">// from the caller</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ReceivePort newIsolateReceivePort = ReceivePort();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Provide the caller with the reference of THIS isolate's SendPort</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    callerSendPort.send(newIsolateReceivePort.sendPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Further processing</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>约束<br>隔离的“入口点”必须是顶级函数或STATIC方法。</p></blockquote><h4 id="1-2。第2步：向隔离区提交消息"><a href="#1-2。第2步：向隔离区提交消息" class="headerlink" title="1.2。第2步：向隔离区提交消息"></a>1.2。第2步：向隔离区提交消息</h4><p>现在我们有了用于向 Isolate 发送消息的端口，让我们看看如何做到这一点：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Method that sends a message to the new isolate</span></span><br><span class="line"><span class="comment">// and receives an answer</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// In this example, I consider that the communication</span></span><br><span class="line"><span class="comment">// operates with Strings (sent and received data)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; sendReceive(<span class="built_in">String</span> messageToBeSent) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We create a temporary port to receive the answer</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ReceivePort port = ReceivePort();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We send the message to the Isolate, and also</span></span><br><span class="line">    <span class="comment">// tell the isolate which port to use to provide</span></span><br><span class="line">    <span class="comment">// any answer</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    newIsolateSendPort.send(</span><br><span class="line">        CrossIsolatesMessage&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">            sender: port.sendPort,</span><br><span class="line">            message: messageToBeSent,</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Wait for the answer and return it</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> port.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Extension of the callback function to process incoming messages</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> callbackFunction(SendPort callerSendPort)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Instantiate a SendPort to receive message</span></span><br><span class="line">    <span class="comment">// from the caller</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ReceivePort newIsolateReceivePort = ReceivePort();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Provide the caller with the reference of THIS isolate's SendPort</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    callerSendPort.send(newIsolateReceivePort.sendPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Isolate main routine that listens to incoming messages,</span></span><br><span class="line">    <span class="comment">// processes it and provides an answer</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    newIsolateReceivePort.listen((<span class="keyword">dynamic</span> message)&#123;</span><br><span class="line">        CrossIsolatesMessage incomingMessage = message <span class="keyword">as</span> CrossIsolatesMessage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Process the message</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="built_in">String</span> newMessage = <span class="string">"complemented string "</span> + incomingMessage.message;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Sends the outcome of the processing</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        incomingMessage.sender.send(newMessage);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Helper class</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrossIsolatesMessage</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SendPort sender;</span><br><span class="line">    <span class="keyword">final</span> T message;</span><br><span class="line"></span><br><span class="line">    CrossIsolatesMessage(&#123;</span><br><span class="line">        <span class="meta">@required</span> <span class="keyword">this</span>.sender,</span><br><span class="line">        <span class="keyword">this</span>.message,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-Step-3-destruction-of-the-new-Isolate"><a href="#1-3-Step-3-destruction-of-the-new-Isolate" class="headerlink" title="1.3. Step 3: destruction of the new Isolate"></a>1.3. Step 3: destruction of the new Isolate</h5><p>当你不再需要新的Isolate实例时，最好通过以下方式释放它：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Routine to dispose an isolate</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    newIsolate?.kill(priority: Isolate.immediate);</span><br><span class="line">    newIsolate = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-4-特别说明-单侦听器流"><a href="#1-4-特别说明-单侦听器流" class="headerlink" title="1.4. 特别说明 - 单侦听器流"></a>1.4. 特别说明 - 单侦听器流</h5><p>您可能已经注意到我们正在使用Streams在“调用者”和新隔离之间进行通信。这些Streams的类型为：“Single-Listener”Streams。</p><h3 id="2-一次性计算"><a href="#2-一次性计算" class="headerlink" title="2.一次性计算"></a>2.一次性计算</h3><p>如果你只需要运行一些代码来完成一些特定的工作，并且在完成工作后不需要与那个Isolate交互，那么就会有一个非常方便的Helper，称为<a href="https://docs.flutter.io/flutter/foundation/compute.html" target="_blank" rel="noopener">compute</a>。</p><p>这个功能：</p><ul><li>产生隔离，</li><li>在该隔离上运行一个回调函数，传递一些数据，</li><li>返回值，回调结果，</li><li>并在执行回调时终止Isolate。</li></ul><blockquote><p>约束<br>“回调”函数必须是顶级函数，不能是闭包或类的方法（静态或非静态）</p></blockquote><h3 id="3-重要限制"><a href="#3-重要限制" class="headerlink" title="3.重要限制"></a>3.重要限制</h3><p>在撰写本文时，请务必注意这一点</p><blockquote><p>平台通道仅由主隔离支持。此主隔离对应于启动应用程序时创建的隔离。</p></blockquote><p>换句话说，通过编程创建的隔离实例，无法实现平台通道通信…</p><p>然而，有一个解决方法…请参阅<a href="https://github.com/flutter/flutter/issues/13937" target="_blank" rel="noopener">此链接</a>以获得有关此主题的讨论。</p><h3 id="我什么时候应该使用-Futures-和-Isolates-？"><a href="#我什么时候应该使用-Futures-和-Isolates-？" class="headerlink" title="我什么时候应该使用 Futures 和 Isolates ？"></a>我什么时候应该使用 Futures 和 Isolates ？</h3><p>用户将根据不同因素评估应用程序的质量，例如：</p><ul><li>特征</li><li>外观</li><li>用户友好性</li><li>…</li></ul><p>你的应用程序可以满足所有这些因素，但如果用户在某些处理过程中遇到滞后，则很可能会对您不利。</p><p>因此，以下是你在开发过程中应系统考虑的一些提示：</p><ol><li>如果代码片段不能被中断，请使用正常的同步过程（一种方法或多种相互调用的方法）;</li><li>如果代码片段可以独立运行而不影响应用程序的流动性，请考虑通过使用Futures使用Event Loop;</li><li>如果繁重的处理可能需要一些时间才能完成并且可能会影响应用程序的流动性，请考虑使用Isolates。</li></ol><p>换句话说，建议尽可能多地使用 Futures 的概念（直接或间接通过异步方法），因为一旦事件循环有时间了，这些 Futures 的代码就会运行。这将使用户感觉事物正在被并行处理（而我们现在知道情况并非如此）。</p><p>另一个可以帮助你决定是使用 Future 还是 Isolate 的因素是运行某些代码所需的平均时间。</p><ul><li>如果一个方法需要几毫秒 =&gt; Future</li><li>如果处理可能需要几百毫秒 =&gt; Isolate</li></ul><p>以下是Isolates的一些很好的候选者：</p><ul><li>JSON解码</li></ul><p>解码JSON（HttpRequest的结果）可能需要一些时间=&gt;使用 compute</p><ul><li>加密</li></ul><p>加密可能非常消耗=&gt; Isolate</p><ul><li>图像处理</li></ul><p>处理图像（例如，裁剪）确实需要一些时间来完成=&gt; Isolate</p><ul><li>从Web加载图像</li></ul><p>在这种情况下，为什么不将它委托给一个 Isolate ，它会在完全加载后返回完整的图像？</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我认为了解事件循环的工作原理至关重要。</p><p>同样重要的是要记住 Flutter(Dart）是单线程因此，为了取悦用户，开发人员必须确保应用程序尽可能顺利运行。Futures 和 Isolates 是非常强大的工具，可以帮助你实现这一目标。</p><p>请继续关注新文章，同时……祝你编程愉快！</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Slivers 揭秘</title>
      <link href="/2019/05/07/Flutter/development/ui/Advanced%20UI/Slivers/"/>
      <url>/2019/05/07/Flutter/development/ui/Advanced%20UI/Slivers/</url>
      
        <content type="html"><![CDATA[<p>如何在你的应用中使用Flutter去做出你想要的滑动效果。</p><p>你好，无畏的 Flutter 爱好者！今天我们要探索一个高度专业的话题-这是大部分应用开发者可以无忧无虑忽略的并且在无需知晓的情况下就能做出好看的应用。通常来说，你需要通过东西来进行滚动的话，<a href="https://docs.flutter.io/flutter/widgets/ListView-class.html" target="_blank" rel="noopener">ListView</a> 和 <a href="https://docs.flutter.io/flutter/widgets/GridView-class.html" target="_blank" rel="noopener">GridView</a> 就能胜任这份工作。这就完了。但是，如果你想要寻求更深入的知识并想增强你的滚动能力：</p><p>那就继续读下去</p><a id="more"></a><p>或者等一下…如果你讨厌阅读，你可以快速的看下这两个视频，对本文的思想进行了总结，</p><iframe width="700" height="393" src="https://www.youtube.com/embed/R9C5KMJKluE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><iframe width="700" height="393" src="https://www.youtube.com/embed/ORiTTaVY6mM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2 id="什么是-Sliver-为什么要使用它？"><a href="#什么是-Sliver-为什么要使用它？" class="headerlink" title="什么是 Sliver ,为什么要使用它？"></a>什么是 Sliver ,为什么要使用它？</h2><p>在网上我可以看到大量的 FOS 。那些因为不了解Slivers而害怕 Slivers 的人。但是Sliver 只是可滑动区域的一部分。仅此而已！揭开面纱的话，所有你使用的可以滚动的视图，像 ListView 和 GridView ,实际上是使用 Slivers 实现的。你可以把 Sliver 当成较为底层的接口，在实现可滚动区域方面提供更加细腻化的控制。因为 Slivers 可以在每个条目被滚动到的时候对其进行懒构建，</p><p>slivers尤其对包含大量子视图的情形的高效滚动有用。</p><p>在滚动的时候你可能要以下的额外控制：</p><ul><li>想要带有一个非标准行为的 app bar（在你滚动的时候），</li><li>想要列表和表格作为一个整体一起滚动（当然，你可以在listView中放一个表格但是效率上就差很多了，特别是当你有一个很大的表格的时候。）</li><li>做些怪异的事情，比如带有headers的可折叠列表（看下这页顶部右侧的gif图片）</li></ul><h2 id="我该如何使用它？"><a href="#我该如何使用它？" class="headerlink" title="我该如何使用它？"></a>我该如何使用它？</h2><p>所有这些Sliver组件都是在<a href>CustomScrollView</a>中使用的，剩下的就是让你来决定如何组合你的sliver列表来组成你的自定义的可滚动区域。你可以通过把一个SliverList放入CustomScrollView然后不用做其他事情就可以完成对ListView的彻底改造。</p><h2 id="SliverList"><a href="#SliverList" class="headerlink" title="SliverList"></a>SliverList</h2><p>SliverList把deledate作为参数，这个参数提供了在视图中滚动的列表中的条目。你可以用SliverChildListDelegate来指定实际的孩子列表，或者使用SliverChildBuilderDelegate对它们进行懒构建。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孩子的显式列表. 没有性能的节省</span></span><br><span class="line"><span class="comment">// 因为孩子已经构建完成了。</span></span><br><span class="line">SliverList(</span><br><span class="line">    delegate: SliverChildListDelegate(</span><br><span class="line">      [</span><br><span class="line">        Container(color: Colors.red, height: <span class="number">150.0</span>),</span><br><span class="line">        Container(color: Colors.purple, height: <span class="number">150.0</span>),</span><br><span class="line">        Container(color: Colors.green, height: <span class="number">150.0</span>),</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 无限滚动的不同颜色容器的列表</span></span><br><span class="line">SliverList(</span><br><span class="line">    delegate: SliverChildBuilderDelegate((BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">      <span class="comment">// 要把这个无限的列表转换为三个条目的列表</span></span><br><span class="line">      <span class="comment">// 对下面这行取消注释</span></span><br><span class="line">      <span class="comment">// if (index &gt; 3) return null;</span></span><br><span class="line">      <span class="keyword">return</span> Container(color: getRandomColor(), height: <span class="number">150.0</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 或者对下面这行取消注释</span></span><br><span class="line">    <span class="comment">// childCount: 3,</span></span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="SliverGrid"><a href="#SliverGrid" class="headerlink" title="SliverGrid"></a>SliverGrid</h2><p>SliverGrid就像SliverList也可以用deledate指定孩子。但是还有一个网格上cross-axis dimension的一些额外格式化。有三种方式能让你对你的表格布局进行指定：</p><ol><li>Count 构造器来数有多少个条目在，在此例中，在横轴上：SliverGrid.count(children:scrollItem,crossAxisCount:4)</li><li>对Constructor进行扩展指定条目宽度来适应网格。这在你的网格中大小不是固定的时候特别有用，你可以限制它们占据多大的空间（在此例中，是在水平方向上限制）。SliverGrid.extent(children: scrollItems, maxCrossAxisExtent: 90.0) // 90 logical pixels</li><li>默认构造器，传入一个明确的gridDelegate参数：</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Re-implementing the above SliverGrid.count example:</span></span><br><span class="line">SliverGrid(</span><br><span class="line">  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">    crossAxisCount: <span class="number">4</span>,</span><br><span class="line">  ),</span><br><span class="line">  delegate: SliverChildBuilderDelegate(</span><br><span class="line">    (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">        color: randomColor(),</span><br><span class="line">        height: <span class="number">150.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="SliverAppBar"><a href="#SliverAppBar" class="headerlink" title="SliverAppBar"></a>SliverAppBar</h2><p>好了，好了，已经说的够多了。我知道你在等待什么了。我该如何却做出这些华丽伸缩的app-bar呢？密码就是同时设置flexibleSpace参数和expandedHeight参数。<br>当应用栏扩展到完整大小而不是“压缩”版本时，您可以为应用栏设置不同的高度和外观。</p><p>这是以上例子的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CustomScrollView(</span><br><span class="line">    slivers: &lt;Widget&gt;[</span><br><span class="line">      SliverAppBar(</span><br><span class="line">        title: Text(<span class="string">'SliverAppBar'</span>),</span><br><span class="line">        backgroundColor: Colors.green,</span><br><span class="line">        expandedHeight: <span class="number">200.0</span>,</span><br><span class="line">        flexibleSpace: FlexibleSpaceBar(</span><br><span class="line">          background: Image.asset(<span class="string">'assets/forest.jpg'</span>, fit: BoxFit.cover),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      SliverFixedExtentList(</span><br><span class="line">        itemExtent: <span class="number">150.0</span>,</span><br><span class="line">        delegate: SliverChildListDelegate(</span><br><span class="line">          [</span><br><span class="line">            Container(color: Colors.red),</span><br><span class="line">            Container(color: Colors.purple),</span><br><span class="line">            Container(color: Colors.green),</span><br><span class="line">            Container(color: Colors.orange),</span><br><span class="line">            Container(color: Colors.yellow),</span><br><span class="line">            Container(color: Colors.pink),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>有一些额外的你可以加到 SliverAppBar 的定制。你可以把 floating 参数设置成为true ，使app bar在你往下滚动的时候再次出现，即使你还没有达到列表的顶部。</p><p>如果同时使用浮动参数添加 snap 参数，则可以在向下滚动时使应用栏完全捕捉回视图。</p><h2 id="把所有这些放到一起：带有Sliver固定标题的可折叠滚动列表"><a href="#把所有这些放到一起：带有Sliver固定标题的可折叠滚动列表" class="headerlink" title="把所有这些放到一起：带有Sliver固定标题的可折叠滚动列表"></a>把所有这些放到一起：带有Sliver固定标题的可折叠滚动列表</h2><p>我试着想象一下我能想到的最不寻常但仍然可能有用的滚动行为。我想出了这个滚动的可折叠列表：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span> <span class="keyword">as</span> math;</span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(<span class="string">'Collapsing List Demo'</span>)),</span><br><span class="line">        body: CollapsingList(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_SliverAppBarDelegate</span> <span class="keyword">extends</span> <span class="title">SliverPersistentHeaderDelegate</span> </span>&#123;</span><br><span class="line">  _SliverAppBarDelegate(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.minHeight,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.maxHeight,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> minHeight;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> maxHeight;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> minExtent =&gt; minHeight;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> maxExtent =&gt; math.max(maxHeight, minHeight);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(</span><br><span class="line">      BuildContext context, </span><br><span class="line">      <span class="built_in">double</span> shrinkOffset, </span><br><span class="line">      <span class="built_in">bool</span> overlapsContent) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SizedBox.expand(child: child);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldRebuild(_SliverAppBarDelegate oldDelegate) &#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeight != oldDelegate.maxHeight ||</span><br><span class="line">        minHeight != oldDelegate.minHeight ||</span><br><span class="line">        child != oldDelegate.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollapsingList</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  SliverPersistentHeader makeHeader(<span class="built_in">String</span> headerText) &#123;</span><br><span class="line">    <span class="keyword">return</span> SliverPersistentHeader(</span><br><span class="line">      pinned: <span class="keyword">true</span>,</span><br><span class="line">      delegate: _SliverAppBarDelegate(</span><br><span class="line">        minHeight: <span class="number">60.0</span>,</span><br><span class="line">        maxHeight: <span class="number">200.0</span>,</span><br><span class="line">        child: Container(</span><br><span class="line">            color: Colors.lightBlue, child: Center(child:</span><br><span class="line">                Text(headerText))),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> CustomScrollView(</span><br><span class="line">      slivers: &lt;Widget&gt;[</span><br><span class="line">        makeHeader(<span class="string">'Header Section 1'</span>),</span><br><span class="line">        SliverGrid.count(</span><br><span class="line">          crossAxisCount: <span class="number">3</span>,</span><br><span class="line">          children: [</span><br><span class="line">            Container(color: Colors.red, height: <span class="number">150.0</span>),</span><br><span class="line">            Container(color: Colors.purple, height: <span class="number">150.0</span>),</span><br><span class="line">            Container(color: Colors.green, height: <span class="number">150.0</span>),</span><br><span class="line">            Container(color: Colors.orange, height: <span class="number">150.0</span>),</span><br><span class="line">            Container(color: Colors.yellow, height: <span class="number">150.0</span>),</span><br><span class="line">            Container(color: Colors.pink, height: <span class="number">150.0</span>),</span><br><span class="line">            Container(color: Colors.cyan, height: <span class="number">150.0</span>),</span><br><span class="line">            Container(color: Colors.indigo, height: <span class="number">150.0</span>),</span><br><span class="line">            Container(color: Colors.blue, height: <span class="number">150.0</span>),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        makeHeader(<span class="string">'Header Section 2'</span>),</span><br><span class="line">        SliverFixedExtentList(</span><br><span class="line">          itemExtent: <span class="number">150.0</span>,</span><br><span class="line">          delegate: SliverChildListDelegate(</span><br><span class="line">            [</span><br><span class="line">              Container(color: Colors.red),</span><br><span class="line">              Container(color: Colors.purple),</span><br><span class="line">              Container(color: Colors.green),</span><br><span class="line">              Container(color: Colors.orange),</span><br><span class="line">              Container(color: Colors.yellow),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        makeHeader(<span class="string">'Header Section 3'</span>),</span><br><span class="line">        SliverGrid(</span><br><span class="line">          gridDelegate: </span><br><span class="line">              <span class="keyword">new</span> SliverGridDelegateWithMaxCrossAxisExtent(</span><br><span class="line">            maxCrossAxisExtent: <span class="number">200.0</span>,</span><br><span class="line">            mainAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">            crossAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">            childAspectRatio: <span class="number">4.0</span>,</span><br><span class="line">          ),</span><br><span class="line">          delegate: <span class="keyword">new</span> SliverChildBuilderDelegate(</span><br><span class="line">            (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">                alignment: Alignment.center,</span><br><span class="line">                color: Colors.teal[<span class="number">100</span> * (index % <span class="number">9</span>)],</span><br><span class="line">                child: <span class="keyword">new</span> Text(<span class="string">'grid item <span class="subst">$index</span>'</span>),</span><br><span class="line">              );</span><br><span class="line">            &#125;,</span><br><span class="line">            childCount: <span class="number">20</span>,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        makeHeader(<span class="string">'Header Section 4'</span>),</span><br><span class="line">        <span class="comment">// Yes, this could also be a SliverFixedExtentList. Writing </span></span><br><span class="line">        <span class="comment">// this way just for an example of SliverList construction.</span></span><br><span class="line">        SliverList(</span><br><span class="line">          delegate: SliverChildListDelegate(</span><br><span class="line">            [</span><br><span class="line">              Container(color: Colors.pink, height: <span class="number">150.0</span>),</span><br><span class="line">              Container(color: Colors.cyan, height: <span class="number">150.0</span>),</span><br><span class="line">              Container(color: Colors.indigo, height: <span class="number">150.0</span>),</span><br><span class="line">              Container(color: Colors.blue, height: <span class="number">150.0</span>),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步留给读者，就是添加一个 GestureDetector, 那么当你点击标题的时候，就能允许你跳转到列表中的这部分。带着你新发现的关于 Slivers 的知识并把它运用到GestureDetection 上去来做出一个炫酷的可折叠列表吧。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Slivers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Dart语言异步支持：阶段二</title>
      <link href="/2019/05/04/Flutter/Dart/Async/Dart%20Language%20Asynchrony%20SupportPhase2/"/>
      <url>/2019/05/04/Flutter/Dart/Async/Dart%20Language%20Asynchrony%20SupportPhase2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.dartlang.org/articles/language/beyond-async" target="_blank" rel="noopener">原文链接</a></p><h2 id="Async-sync-以及剩余部分"><a href="#Async-sync-以及剩余部分" class="headerlink" title="Async*, sync*, 以及剩余部分"></a>Async*, sync*, 以及剩余部分</h2><p>作者 Gilad Bracha，作于2015年三月。</p><p>在之前的文章中，我们谈及了异步方法和等待表达式。这些功能是Dart中支持异步编程和生成器的完整计划的一部分。</p><a id="more"></a><h2 id="生成器-Generators"><a href="#生成器-Generators" class="headerlink" title="生成器(Generators)"></a>生成器(<code>Generators</code>)</h2><p>Dart 1.9引入了生成器功能。这些方法能惰性地计算出一系列的结果。有两种生成器 - 同步的和异步的。同步生成器按需生成值 - 消费者从生成器中拉取值。异步生成器按照自己的速度生成值，并将它们推送到消费者可以找到的位置。</p><h3 id="为什么在语言中支持生成器"><a href="#为什么在语言中支持生成器" class="headerlink" title="为什么在语言中支持生成器"></a>为什么在语言中支持生成器</h3><p>人们可以手动实现生成器，但这可能很棘手，而且肯定是乏味的。</p><p>要实现同步生成器，您需要定义自己的可迭代类。你可以继承IterableBase，但你仍然需要声明该类并实现迭代器方法，该方法必须返回一个新的迭代器。要做到这一点，你必须声明自己的迭代器类。您需要实现成员moveNext()和current，它们跟踪并更新迭代器的位置，检测你何时到达底层迭代的末尾（以及它是否为空开始）。这没什么大不了的 - 我们知道你喜欢编程，这是一个很棒的CS101练习。但是，也许，只是也许，你想花时间编程别的东西。同步发生器功能是用于实现这种可迭代的语法糖。</p><p>手动编写异步生成器更有趣。您可以编写棘手的样板，而不仅仅是样板文件。例如，当流被暂停或取消时，您必须确保一切正常。</p><p>Dart新的内置生成器支持使事情变得更加容易，我们将在下面看到。</p><h3 id="同步生成器：sync"><a href="#同步生成器：sync" class="headerlink" title="同步生成器：sync"></a>同步生成器：sync</h3><p>使用sync*修饰符标记方法体将该方法标识为同步生成器，并减轻程序员手动定义迭代所涉及的大部分样板。</p><p>假设我们想要产生前n个自然数。使用同步生成器很容易做到这一点。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span> naturalsTo(n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时，naturalsTo立即返回一个iterable（很像标记为async的函数，立即返回一个<code>future</code>）,从中可以提取迭代器。在迭代器上调用moveNext之前，函数体不会开始运行。它将一直运行，直到它第一次达到yield语句。 yield语句包含一个表达式，它会对其进行求值。然后，函数挂起，moveNext将true返回给它的调用者。</p><p>该函数将在下次调用moveNext时继续执行。当循环结束时，该方法隐式执行return，导致它终止。此时，moveNext将false返回给其调用者。</p><p>使用普通迭代器，这可能会非常繁琐，因为必须定义专门的迭代器和可迭代类并实现完整的Iterable API。</p><h4 id="魔鬼的细节"><a href="#魔鬼的细节" class="headerlink" title="魔鬼的细节"></a>魔鬼的细节</h4><p>您可以将同步与*分开;他们是不同的符号。如果你有使用同步作为标识符的现有代码，则可以继续这样做。单词sync不是真正的保留字。类似的解释适用于<code>async</code>, <code>await</code>, 以及 <code>yield</code>。它们仅被视为异步或生成器函数内的保留字（即标记为async，sync*或异步async*的那些）。</p><p>请记住，遵守严格的兼容性需要付出代价。假设你忘记在函数上使用诸如sync *之类的修饰符，并在其中使用<code>yield</code>语句。解析器可能会非常困惑，并给出相当令人困惑的错误消息。</p><h3 id="异步生成器-async"><a href="#异步生成器-async" class="headerlink" title="异步生成器:async*"></a>异步生成器:async*</h3><p>为了异步生成序列，我们使用了流。可以使用Stream和联合类手动实现流。异步生成器函数是用于实现此类流的糖。使用async*修饰符标记函数体将该函数标识为异步生成器。</p><p>让我们尝试再次生成自然数，这次是异步的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream asynchronousNaturalsTo(n) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用此函数会立即返回一个流 - 正如调用sync*函数会立即返回一个迭代器，并且调用异步函数会立即返回一个<code>future</code>（也许你可以在这里看到一个模式）。</p><p>一旦你监听到流，函数体的执行就开始了。 yield语句执行时，会将其表达式的计算结果添加到流中。它不一定是暂停的（尽管在当前的实现中它确实如此）。</p><p>在任何情况下，所有监听着流的方法都会在某个节点有新值的时候被调用。然而，主动权不在消费者手中;流将其值乐此不彼推送到监听器函数。</p><h4 id="难懂的条文"><a href="#难懂的条文" class="headerlink" title="难懂的条文"></a>难懂的条文</h4><p>作为变体，请考虑</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream <span class="keyword">get</span> naturals <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>; <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="keyword">yield</span> <span class="keyword">await</span> k++; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子提出了一个有趣的问题：因为代码在一个紧密的无限循环中运行而yield不会挂起，什么时候任何监听器都要运行来查看结果？我们可能要求产量总是暂停，但这可能会损害性能。唯一的要求是函数最终会暂停，以便其他一些代码可以运行并从流中提取值。</p><p>与async*函数关联的流可能会暂停或取消。如果async*函数执行yield并且其流已被取消，则控制转移到最近的封闭finally子句。如果流已暂停，则执行在yield之前暂停，直到恢复流。有关所有血腥细节，请参阅<a href="https://www.dartlang.org/guides/language/spec" target="_blank" rel="noopener">Dart语言规范</a>。</p><h2 id="await-for"><a href="#await-for" class="headerlink" title="await-for"></a>await-for</h2><p>正如每个Dart程序员都知道的那样，for-in循环可以与iterables一起使用。类似地，await-for循环旨在与流良好匹配。</p><p>给定一个流，可以循环其值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">for</span> (<span class="built_in">int</span> i <span class="keyword">in</span> naturals) &#123; <span class="built_in">print</span>(‘event loop $i’); &#125;</span><br></pre></td></tr></table></figure><p>每次将元素添加到流中时，都会运行循环体。在每次迭代之后，包含循环的函数将暂停，直到下一个元素可用或流完成为止。就像await表达式一样，await-for循环只能出现在异步函数中。</p><h2 id="yeild"><a href="#yeild" class="headerlink" title="yeild*"></a>yeild*</h2><p>虽然yield的使用很有吸引力，但你可能会遇到问题。如果你正在编写递归函数，则可以获得二次方行为。考虑以下功能，旨在从n向后计数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span> naturalsDownFrom(n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">yield</span> n;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">int</span> i <span class="keyword">in</span> naturalsDownFrom(n<span class="number">-1</span>)) &#123; <span class="keyword">yield</span> i; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在功能上是正确的，但是以二次方式运行。请注意，<code>yeild i</code>;对于序列中的第n个元素执行n-1次：在每个递归级别执行一次;第一个元素3仅由产量n产生;声明;第二个元素2由<code>yield n</code>产生一次;并且一次产量i;第三个元素是1，由yield n产生一次;产量两倍;总共我们有n(n-1）次执行<code>yield i</code>;，即O（n2）。</p><p>yield*（发音为yield-each）语句旨在解决此问题。 yield *之后的表达式必须表示另一个（子）序列。 yield*的作用是将子序列的所有元素插入到当前正在构造的序列中，就好像我们每个元素都有一个单独的yield。我们可以使用yield-each重写我们的代码，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span> naturalsDownFrom(n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> ( n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n;</span><br><span class="line">    <span class="keyword">yield</span>* naturalsDownFrom(n<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后一版本以线性时间运行。</p><h4 id="难懂的条文-1"><a href="#难懂的条文-1" class="headerlink" title="难懂的条文"></a>难懂的条文</h4><p>在sync*函数中，子序列必须是可迭代的;在async*方法中，子序列必须是流。如果不是，则会有运行时错误。当然，在这种情况下，您也会收到静态警告。</p><p>子序列可以为空。在这种情况下，yield *会跳过它而不会挂起。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Dart语言异步支持：阶段一</title>
      <link href="/2019/05/04/Flutter/Dart/Async/Dart%20Language%20Asynchrony%20Support-%20Phase%201/"/>
      <url>/2019/05/04/Flutter/Dart/Async/Dart%20Language%20Asynchrony%20Support-%20Phase%201/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.dartlang.org/articles/language/await-async" target="_blank" rel="noopener">原文链接</a></p><p>由Gilad Bracha撰写</p><p>2014年10月</p><p>Dart即将推出支持异步编程的新语言功能。这些功能将逐渐上线。在本文中，我们将讨论最基本的补充：<code>await</code> 表达式和 <code>async</code> 方法。这些是与异步相关的最常用功能。</p><a id="more"></a><blockquote><p>注意：本文假设你已熟悉Dart中的异步编程。</p></blockquote><blockquote><p>版本说明：在 Dart 1.x 中，异步函数立即暂停执行。在 Dart 2 中，异步函数不是立即挂起，而是同步执行，直到第一个 <code>await</code> 或 <code>return</code> 出现才会暂停执行。</p></blockquote><h2 id="Async-函数"><a href="#Async-函数" class="headerlink" title="Async 函数"></a>Async 函数</h2><p>异步函数是主体标有异步修饰符的函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo() <span class="keyword">async</span> =&gt; <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>当你调用异步函数时，它会立即返回一个Future;该函数的主体被安排稍后执行。当主体执行时，调用返回的Future将使用结果完成 - 无论主体是否成功运行，或引发异常。在提供的简单示例中，调用 foo()会产生 Future。Future 最终以数字42完成。</p><p>你可以在没有async修饰符的情况下编写类似的函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo() =&gt; <span class="keyword">new</span> Future(() =&gt; <span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>修饰符为你节省了一些样板，但真正的一点是，它允许你在函数内部使用 <code>await</code> 表达式，我们很快就会看到。稍后，我们将返回异步函数以更全面地理解它们。</p><h2 id="Await-表达式"><a href="#Await-表达式" class="headerlink" title="Await 表达式"></a>Await 表达式</h2><p>Await 表达式允许你编写异步代码，就像它是同步的一样。假设你有一个引用文件的变量myFile。（有关文件的详细信息，请参阅dart：io中的File类。）你决定将其复制到新位置newPath，声明为</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> newPath = <span class="string">'/some/where/out/there'</span>;</span><br></pre></td></tr></table></figure><p>你希望以下是true的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFile.copy(newPath).path == newPath;</span><br></pre></td></tr></table></figure><p>不幸的是，这不会奏效。由于Dart的 I/O API是异步的，因此复制操作返回 Future ，并且你无法在其上调用路径。你必须在从 copy() 返回的 Future 上安排回调，并且该回调执行与其传入参数f的比较：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFile.copy(newPath).then((f) =&gt; f.path == newPath);</span><br></pre></td></tr></table></figure><p>这有点乏味，但是你的代码涉及的越多，情况就越糟糕。你真正想要做的是等待异步文件复制操作完成，获取结果并继续执行。 await 表达式可以让你做到这一点：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">await</span> myFile.copy(newPath)).path == newPath;</span><br></pre></td></tr></table></figure><p>当 <strong>await</strong> 表达式运行时，调用 myFile.copy()，产生一个 Future。执行然后暂停，等待 Future 完成。在 Future 完成文件后，执行恢复。await 表达式的值是 Future 的完成 - 我们正在等待的文件。现在我们可以提取它的路径并将其与 newPath 进行比较。</p><p>通常，await表达式具有以下形式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> e</span><br></pre></td></tr></table></figure><p>其中  e是一元表达式。通常，e 是异步计算，并且期望评估为 Future。 await 表达式计算 e，然后挂起当前运行的函数，直到结果准备好 - 也就是说，直到 Future 完成。await 表达式的结果是 Future 的完成。</p><blockquote><p>注意：暂停后，执行将在事件循环的后续周期中恢复。有关Dart事件循环的说明，请参阅<a href="/dart/async/2019/04/29/The-Event-Loop-and-Dart/">事件循环和 Dart </a>。</p></blockquote><p>如果 Future 使用错误而不是值来完成，则 await 表达式会在执行恢复时抛出相同的错误，这极大地简化了异步代码中异常的处理。</p><p>如果 e 没有被评估成 Future 怎么办？好吧，无论如何 <strong>await</strong> 会等待（技术上，它将结果包装在 Future 中并等待它在事件循环周期中完成）。这是Dart与其他语言中类似功能之间的差异之一。在 Dart 中，<strong>await</strong> 总是等待。这使得行为更具可预测性。特别是，如果你有一个无条件等待内部的循环，你总是可以确保你将在每次迭代时暂停。</p><p>如果 e 本身会引发异常怎么办(请注意，这与使用错误完成对  Future的求值不同。）抛出的异常包含在 Future 中，执行挂起。当我们恢复时，抛出异常。同样，暂停是可预测的。</p><p>最后一个但是很关键的点：你只能在异步函数中使用 <strong>await</strong> 表达式。如果你尝试在普通函数中使用 <strong>await</strong> ，则会出现编译错误。如果你要暂停一个普通的函数，它将不再是同步的。</p><h2 id="Async-函数：难懂的条文"><a href="#Async-函数：难懂的条文" class="headerlink" title="Async 函数：难懂的条文"></a>Async 函数：难懂的条文</h2><p>现在我们已经了解了 <strong>await</strong> 表达式是如何工作的，让我们重新审视异步函数，以便我们清楚一些重要的细节。</p><p>首先，注意修饰符介于函数签名和它的主体之间。我们也可以将foo()写成</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo() <span class="keyword">async</span> &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br></pre></td></tr></table></figure><p>简而言之，修饰符位于=&gt;或打开函数体的大括号之前。</p><p>修饰符不是签名的一部分;它只是函数的实现细节。从调用者的角度来看，调用异步函数与调用传统函数没什么不同。</p><p>由于同样的原因，<strong>async</strong> 修饰符对函数的声明返回类型也没有影响。但是，它确实会改变实际返回的对象类型。请注意，return 语句返回一个整数，但该函数已经将 Future 返回给它的调用者！在异步函数内部，return 语句的操作方式与常规函数不同。在异步函数中，return 完成函数在调用时返回给调用者的 Future。 Future 将使用返回的表达式的值完成。</p><p>同样，如果在异步函数中抛出(或重新抛出)异常，则抛出的对象将用于完成 Future 并出现错误。</p><p>如果返回的表达式具有类型 T，则该函数应具有返回类型 Future&lt;T&gt;（或其超类型）。否则，发出静态警告。我们的示例不声明返回类型，因此它们具有返回类型动态 - 因此不会给出警告。</p><p>如果 return 语句中的表达式是 Future&lt;T&gt;，则函数返回类型应保留为 Future&lt;T&gt; 而不是 Future&lt;Future<t>&gt;。除了等待更多之外，对于已经完成另一个 Future 的 Future ，你可以做的事情并不多，因此异步库消除了 Futures 层。类型准则旨在识别这一事实。</t></p><p>最后，请注意 Dart 中的异步函数始终是异步的。这与其他语言中的异步函数不同，在某些情况下，函数可能完全同步。在 Dart 中，你知道异步函数的每个部分在调用它的调用返回给调用者之后执行。</p><h2 id="把所有东西放在一起"><a href="#把所有东西放在一起" class="headerlink" title="把所有东西放在一起"></a>把所有东西放在一起</h2><p>这是一个结合我们迄今为止所学到的内容的例子。假设我们正在运行一个简单的动画，它会更新每一帧的显示。</p><p>不使用 <code>async</code> 和 <code>await</code> ，代码可能如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"dart:html"</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> context = <span class="built_in">querySelector</span>(<span class="string">"canvas"</span>).context2D;</span><br><span class="line">  <span class="keyword">var</span> running = <span class="keyword">true</span>;    <span class="comment">// Set false to stop.</span></span><br><span class="line"></span><br><span class="line">  tick(time) &#123;</span><br><span class="line">    context.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">    context.fillRect(time % <span class="number">450</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (running) <span class="built_in">window</span>.animationFrame.then(tick);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.animationFrame.then(tick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它不是太复杂，但也不是很简单。我们生成帧;当帧完成时，我们期望调用一个回调函数tick()，它产生下一帧（如果动画还没有停止),并递归自身作为回调，使进程永久化。函数tick()表示计算的延续，我们都知道延续是多么直观和容易。</p><p>使用我们的新语言功能，我们可以编写以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"dart:html"</span>;</span><br><span class="line"></span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> context = <span class="built_in">querySelector</span>(<span class="string">"canvas"</span>).context2D;</span><br><span class="line">  <span class="keyword">var</span> running = <span class="keyword">true</span>;    <span class="comment">// Set false to stop game.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (running) &#123;</span><br><span class="line">    <span class="keyword">var</span> time = <span class="keyword">await</span> <span class="built_in">window</span>.animationFrame;</span><br><span class="line">    context.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">    context.fillRect(time % <span class="number">450</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码是自我解释的。在动画运行时，我们计算一个帧。这是你的选择;选择你觉得比较容易理解的版本。</p><h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>有关更高级异步主题的信息，例如async*，sync*，yield和yield*，请参阅<a href="/dart/async/2019/05/04/Dart-Language-Asynchrony-SupportPhase2/">Dart语言异步支持：阶段二</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)dart:async - 异步编程</title>
      <link href="/2019/05/04/Flutter/Dart/Async/dart-async%20-%20asynchronous%20programming/"/>
      <url>/2019/05/04/Flutter/Dart/Async/dart-async%20-%20asynchronous%20programming/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.dartlang.org/guides/libraries/library-tour#dartasync---asynchronous-programming" target="_blank" rel="noopener">原文链接</a></p><p>异步编程通常使用回调函数，但 Dart 提供了备选：<a href="https://api.dartlang.org/stable/dart-async/Future-class.html" target="_blank" rel="noopener">Future</a> 和 <a href="https://api.dartlang.org/stable/dart-async/Stream-class.html" target="_blank" rel="noopener">Stream</a> 对象。Future 就像是对将来某个时候提供结果的承诺。Stream 是一种获取值序列的方法，例如事件。 Future，Stream 等都在dart:async库(<a href="https://api.dartlang.org/stable/dart-async/dart-async-library.html" target="_blank" rel="noopener">API参考</a>）中。</p><a id="more"></a><blockquote><p>注意：你并不总是需要直接使用 Future 或 Stream API。 Dart 语言支持使用 <code>async</code> 和 <code>await</code> 等关键字进行异步编码。有关详细信息，请参阅语言导览中的<a href="/dart/async/2019/05/04/Asynchrony-support/">异步支持</a>。</p></blockquote><p>dart:async 库适用于 Web 应用程序和命令行应用程序。要使用它，请导入 dart:async ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>版本说明：从 Dart 2.1 开始，你无需导入 dart:async 即可使用 Future 和 Stream API，因为 dart:core 会导出这些类。</p></blockquote><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>Future 对象出现在 Dart 库中，通常作为异步方法返回的对象。当 future 完成后，其值即可使用。</p><h3 id="使用-await"><a href="#使用-await" class="headerlink" title="使用 await"></a>使用 await</h3><p>在直接使用Future API之前，请考虑使用 <code>await</code> 。使用 <code>await</code> 表达式的代码比使用 Future API的代码更容易理解。</p><p>考虑以下功能。它使用 Future 的 then() 方法连续执行三个异步函数，在执行下一个函数之前要等待每个函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runUsingFuture() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  findEntryPoint().then((entryPoint) &#123;</span><br><span class="line">    <span class="keyword">return</span> runExecutable(entryPoint, args);</span><br><span class="line">  &#125;).then(flushThenExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具有await表达式的等效代码看起来更像是同步代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runUsingAsyncAwait() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> entryPoint = <span class="keyword">await</span> findEntryPoint();</span><br><span class="line">  <span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entryPoint, args);</span><br><span class="line">  <span class="keyword">await</span> flushThenExit(exitCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步函数可以捕获Futures的异常。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entryPoint = <span class="keyword">await</span> findEntryPoint();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entryPoint, args);</span><br><span class="line">  <span class="keyword">await</span> flushThenExit(exitCode);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// Handle the error...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重要提示：异步函数返回 Futures。如果你不希望函数返回 Future，请使用其他解决方案。例如，你可以从函数中调用异步函数。</p></blockquote><p>有关使用<code>await</code>和相关Dart的语言功能的更多信息，请参阅<a href="/dart/async/2019/05/04/Asynchrony-support/">异步支持</a>。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>你可以使用 <code>then()</code> 来安排将来完成时运行的代码。例如，<code>HttpRequest.getString()</code> 返回一个 Future，因为HTTP请求可能需要一段时间。使用 <code>then()</code> 可以在 Future 完成并且承诺的字符串值可用时运行一些代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest.getString(url).then((<span class="built_in">String</span> result) &#123;</span><br><span class="line">  <span class="built_in">print</span>(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用<code>catchError()</code>来处理Future对象可能抛出的任何错误或异常。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest.getString(url).then((<span class="built_in">String</span> result) &#123;</span><br><span class="line">  <span class="built_in">print</span>(result);</span><br><span class="line">&#125;).catchError((e) &#123;</span><br><span class="line">  <span class="comment">// Handle or ignore the error.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>then().catchError() 模式是 try-catch 的异步版本。</p><p>重要说明：确保对 <code>then()</code> 的结果调用 <code>catchError()</code> - 而不是原始<code>Future</code>的结果。否则，<code>catchError()</code> 只能处理原始 Future 的计算中的错误，而不能处理<code>then()</code>注册的处理程序中的错误。</p><h3 id="链接多个异步函数"><a href="#链接多个异步函数" class="headerlink" title="链接多个异步函数"></a>链接多个异步函数</h3><p>then() 方法返回一个 Future，提供了一种以特定顺序运行多个异步函数的有用方法。如果使用then() 注册的回调返回 Future，then() 返回等效的 Future。如果回调返回任何其他类型的值，then() 创建一个使用该值完成的新Future。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future result = costlyQuery(url);</span><br><span class="line">result</span><br><span class="line">    .then((value) =&gt; expensiveWork(value))</span><br><span class="line">    .then((_) =&gt; lengthyComputation())</span><br><span class="line">    .then((_) =&gt; <span class="built_in">print</span>(<span class="string">'Done!'</span>))</span><br><span class="line">    .catchError((exception) &#123;</span><br><span class="line">  <span class="comment">/* Handle exception... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在前面的示例中，方法按以下顺序运行：</p><ol><li>costlyQuery()</li><li>expensiveWork()</li><li>lengthyComputation()</li></ol><p>这是使用await编写的相同代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> value = <span class="keyword">await</span> costlyQuery(url);</span><br><span class="line">  <span class="keyword">await</span> expensiveWork(value);</span><br><span class="line">  <span class="keyword">await</span> lengthyComputation();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Done!'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">/* Handle exception... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等待多个feature"><a href="#等待多个feature" class="headerlink" title="等待多个feature"></a>等待多个feature</h3><p>有时您的算法需要调用许多异步函数并等待它们全部完成才能继续。使用<a href="https://api.dartlang.org/stable/dart-async/Future/wait.html" target="_blank" rel="noopener">Future.wait()</a>静态方法管理多个Futures并等待它们完成：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future deleteLotsOfFiles() <span class="keyword">async</span> =&gt;  ...</span><br><span class="line">Future copyLotsOfFiles() <span class="keyword">async</span> =&gt;  ...</span><br><span class="line">Future checksumLotsOfOtherFiles() <span class="keyword">async</span> =&gt;  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> Future.wait([</span><br><span class="line">  deleteLotsOfFiles(),</span><br><span class="line">  copyLotsOfFiles(),</span><br><span class="line">  checksumLotsOfOtherFiles(),</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Done with all the long steps!'</span>);</span><br></pre></td></tr></table></figure><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>流对象出现在整个 Dart API 中，表示数据序列。例如，按钮点击等HTML事件是使用流传递的。你还可以将文件作为流读取。</p><h3 id="使用异步for循环"><a href="#使用异步for循环" class="headerlink" title="使用异步for循环"></a>使用异步for循环</h3><p>有时你可以使用异步for循环(<code>await for</code>)而不是使用 Stream API。</p><p>考虑以下功能。它使用Stream的 <code>listen()</code> 方法订阅文件列表，传入一个搜索每个文件或目录的函数文字。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; arguments) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  FileSystemEntity.isDirectory(searchPath).then((isDir) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDir) &#123;</span><br><span class="line">      <span class="keyword">final</span> startingDir = Directory(searchPath);</span><br><span class="line">      startingDir</span><br><span class="line">          .list(</span><br><span class="line">              recursive: argResults[recursive],</span><br><span class="line">              followLinks: argResults[followLinks])</span><br><span class="line">          .listen((entity) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entity <span class="keyword">is</span> File) &#123;</span><br><span class="line">          searchFile(entity, searchTerms);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      searchFile(File(searchPath), searchTerms);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带有await表达式的等效代码，包括异步for循环（<code>await for</code>），看起来更像是同步代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Future main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; arguments) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">await</span> FileSystemEntity.isDirectory(searchPath)) &#123;</span><br><span class="line">    <span class="keyword">final</span> startingDir = Directory(searchPath);</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> entity <span class="keyword">in</span> startingDir.list(</span><br><span class="line">        recursive: argResults[recursive],</span><br><span class="line">        followLinks: argResults[followLinks])) &#123;</span><br><span class="line">      <span class="keyword">if</span> (entity <span class="keyword">is</span> File) &#123;</span><br><span class="line">        searchFile(entity, searchTerms);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    searchFile(File(searchPath), searchTerms);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重要提示：在使用 <code>await for</code> 之前，请确保它使代码更清晰，并且你确实希望等待所有流的结果。例如，你通常不应该使用等待DOM事件监听器，因为DOM会发送无穷无尽的事件流。如果你使用 <code>await for</code> 来连续注册两个DOM事件监听器，则永远不会处理第二种事件。</p></blockquote><p>有关使用<code>await</code>和相关Dart语言功能的更多信息，请参阅<a href="/dart/async/2019/05/04/Asynchrony-support/">异步支持</a>。</p><h2 id="监听流数据"><a href="#监听流数据" class="headerlink" title="监听流数据"></a>监听流数据</h2><p>要在到达时获取每个值，请使用<code>await for</code>或使用<code>listen()</code>方法订阅流：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a button by ID and add an event handler.</span></span><br><span class="line"><span class="built_in">querySelector</span>(<span class="string">'#submitInfo'</span>).onClick.listen((e) &#123;</span><br><span class="line">  <span class="comment">// When the button is clicked, it runs this code.</span></span><br><span class="line">  submitData();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在此示例中，<code>onClick</code>属性是“submitInfo”按钮提供的Stream对象。</p><p>如果你只关心一个事件，则可以使用诸如 <code>first</code> ，<code>last</code> 或 <code>single</code> 之类的属性来获取它。要在处理事件之前测试事件，请使用 <code>firstWhere()</code> ，<code>lastWhere()</code> 或 <code>singleWhere()</code> 等方法。</p><p>如果你关心事件的子集，则可以使用诸如 <code>skip()</code> ，<code>skipWhile()</code> ，<code>take()</code>，<code>takeWhile()</code> 和 <code>where()</code> 之类的方法。</p><h3 id="转换流数据"><a href="#转换流数据" class="headerlink" title="转换流数据"></a>转换流数据</h3><p>通常，您需要先更改流数据的格式，然后才能使用它。使用 <code>transform()</code> 方法生成具有不同类型数据的流：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lines = inputStream</span><br><span class="line">    .transform（utf8.decoder）</span><br><span class="line">    .transform（LineSplitter（））;</span><br></pre></td></tr></table></figure><p>此示例使用两个变换器。首先，它使用 utf8.decoder 将整数流转换为字符串流。然后，它使用一个 LineSplitter将字符串流转换为单独的行流。这些变换器来自dart:convert库（参见<a href="https://www.dartlang.org/guides/libraries/library-tour#dartconvert---decoding-and-encoding-json-utf-8-and-more" target="_blank" rel="noopener">dart:convert部分</a>）。</p><h3 id="处理错误和完成"><a href="#处理错误和完成" class="headerlink" title="处理错误和完成"></a>处理错误和完成</h3><p>如何指定错误和完成处理代码取决于你是使用异步 for 循环(<code>await for</code>)还是Stream API。</p><p>如果使用异步 for 循环，则使用 try-catch 来处理错误。关闭流后执行的代码将在异步for循环之后执行。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Future readFileAwaitFor() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> config = File(<span class="string">'config.txt'</span>);</span><br><span class="line">  Stream&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; inputStream = config.openRead();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> lines = inputStream</span><br><span class="line">      .transform(utf8.decoder)</span><br><span class="line">      .transform(LineSplitter());</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> line <span class="keyword">in</span> lines) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Got <span class="subst">$&#123;line.length&#125;</span> characters from stream'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'file is now closed'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用Stream API，则通过注册 <code>onError</code> 监听器来处理错误。通过注册 <code>onDone</code> 监听器关闭流后运行代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config = File(<span class="string">'config.txt'</span>);</span><br><span class="line">Stream&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; inputStream = config.openRead();</span><br><span class="line"></span><br><span class="line">inputStream</span><br><span class="line">    .transform(utf8.decoder)</span><br><span class="line">    .transform(LineSplitter())</span><br><span class="line">    .listen((<span class="built_in">String</span> line) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Got <span class="subst">$&#123;line.length&#125;</span> characters from stream'</span>);</span><br><span class="line">&#125;, onDone: () &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'file is now closed'</span>);</span><br><span class="line">&#125;, onError: (e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更多信息<br>有关在命令行应用程序中使用 Future 和 Stream 的一些示例，请参阅<a href="https://www.dartlang.org/server/io-library-tour" target="_blank" rel="noopener">dart:io导览</a>。另请参阅这些文章和教程：</p><ul><li><a href="/dart/async/2019/04/28/AsynchronousProgrammingFutures/">异步编程: Futures</a></li><li><a href="/dart/async/2019/04/29/Futures-and-Error-Handling/">Futures 和错误处理</a></li><li><a href="/dart/async/2019/04/29/The-Event-Loop-and-Dart/">事件循环和 Dart</a></li><li><a href="/dart/async/2019/04/28/AsynchronousProgrammingStreams/">异步编程：Streams</a></li><li><a href="/dart/async/2019/04/30/Creating-Streams-in-Dart/">在 Dart 中创建流</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)异步支持</title>
      <link href="/2019/05/04/Flutter/Dart/Async/Asynchrony%20support/"/>
      <url>/2019/05/04/Flutter/Dart/Async/Asynchrony%20support/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">原文链接</a></p><p>Dart 库充满了返回 <a href="https://api.dartlang.org/stable/dart-async/Future-class.html" target="_blank" rel="noopener">Future</a> 或 <a href="https://api.dartlang.org/stable/dart-async/Stream-class.html" target="_blank" rel="noopener">Stream</a> 对象 的 函数。这些函数是异步的：它们在设置可能耗时的操作（例如 I/O )后返回，而不等待该操作完成。</p><p><code>async</code> 和 <code>await</code> 关键字支持异步编程，允许你编写看起来类似于同步代码的异步代码。</p><a id="more"></a><h2 id="处理-Futures"><a href="#处理-Futures" class="headerlink" title="处理 Futures"></a>处理 Futures</h2><p>当你需要完成的 Future 的结果时，你有两个选择：</p><ul><li>使用 <code>async</code> 和 <code>await</code></li><li>使用 Future API , 如<a href="https://www.dartlang.org/guides/libraries/library-tour#future" target="_blank" rel="noopener">库导览</a>中所述</li></ul><p>使用 <code>async</code> 和 <code>await</code> 的代码是异步的，但它看起来很像同步代码。例如，这里有一些代码使用 <code>await</code> 来等待异步函数的结果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> lookUpVersion();</span><br></pre></td></tr></table></figure><p>要使用 <code>await</code> ，代码必须位于异步函数中 - 标记为 async 的函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="comment">// Do something with version</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：虽然异步函数可能会执行耗时的操作，但它不会等待这些操作。相反，异步函数只在遇到第一个 <code>await</code> 表达式（<a href="https://github.com/dart-lang/sdk/blob/master/docs/newsletter/20170915.md#synchronous-async-start" target="_blank" rel="noopener">详细信息</a>）时才会执行。然后它返回一个 Future 对象，仅在 <code>await</code> 表达式完成后才恢复执行。</p></blockquote><p>使用try，catch，最后在使用await的代码中处理错误和清理：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// React to inability to look up the version</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在异步函数中多次使用 <code>await</code>。例如，以下代码等待了函数的结果三次：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entrypoint = <span class="keyword">await</span> findEntrypoint();</span><br><span class="line"><span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entrypoint,args);</span><br><span class="line"><span class="keyword">await</span> flushThenExit(exitCode)<span class="string">'</span></span><br></pre></td></tr></table></figure><p>在 <code>await</code> 表达式中，表达式的值通常是 Future ;如果不是，那么该值将自动包装在Future中。此 Future 对象表示的是返回一个对象的承诺。 await 表达式的值是返回的对象。 await 表达式使执行暂停，直到该对象可用。</p><p>如果在使用 <code>await</code> 时遇到编译时错误，请确保 <code>await</code> 在异步函数中。例如，要在应用程序的 <code>main()</code> 函数中使用 <code>await</code> ，<code>main()</code> 的主体必须标记为 <code>async</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  checkVersion();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'In main: version is <span class="subst">$&#123;await lookUpVersion()&#125;</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明异步函数"><a href="#声明异步函数" class="headerlink" title="声明异步函数"></a>声明异步函数</h2><p>异步函数是一个函数，其主体用async修饰符标记。</p><p>将 <code>async</code> 关键字添加到函数使其返回一个 Future 。例如，考虑这个同步函数，它返回的是一个 String：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> lookUpVersion() =&gt; <span class="string">'1.0.0'</span>;</span><br></pre></td></tr></table></figure><p>如果将其更改为异步函数 - 例如，因为将来的实现将非常耗时 - 返回的值是一个 Future：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; lookUpVersion() <span class="keyword">async</span> =&gt; <span class="string">'1.0.0'</span>;</span><br></pre></td></tr></table></figure><p>请注意，函数的主体不需要使用Future API。如有必要，Dart会创建 <code>Future</code> 对象。</p><p>如果您的函数没有返回有用的值，请使其返回类型为 <code>Future&lt;void&gt;</code>。</p><h2 id="处理-Streams"><a href="#处理-Streams" class="headerlink" title="处理 Streams"></a>处理 Streams</h2><p>当你需要从 Stream 获取值时，你有两个选择：</p><ul><li>使用 <code>async</code> 和一个异步for循环(await for)。</li><li>使用Stream API，如<a href="https://www.dartlang.org/guides/libraries/library-tour#stream" target="_blank" rel="noopener">库导览</a>中所述。</li></ul><blockquote><p>注意：在使用 <code>await for</code> 之前，请确保它使代码更清晰了，并且你确实希望等待所有流的结果。例如，你通常不应该针对UI事件监听器使用 <code>await for</code> ，因为UI框架会发送无穷无尽的事件流。</p></blockquote><p>异步for循环具有以下形式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">for</span> (varOrType identifier <span class="keyword">in</span> expression) &#123;</span><br><span class="line">  <span class="comment">// Executes each time the stream emits a value.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式的值必须具有类型化的Stream。执行过程如下：</p><ol><li>等到流发出一个值。</li><li>执行for循环的主体，将变量设置为该发出的值。</li><li>重复1和2，直到关闭流。</li></ol><p>要停止监听流，可以使用 <code>break</code> 或 <code>return</code> 语句，该语句会中断 for 循环并从流中取消取消。</p><p>如果在实现异步for循环时遇到编译时错误，请确保 <code>await for</code> 是异步函数。例如，要在 app 的<code>main()</code> 函数中使用异步for循环，<code>main()</code>的主体必须标记为 <code>async</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> request <span class="keyword">in</span> requestServer) &#123;</span><br><span class="line">    handleRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关异步编程的更多信息，请参阅库导览的<a href="/dart/async/2019/05/04/dart-async-asynchronous-programming/">dart:async</a>部分。另请参阅文章<a href="/dart/async/2019/05/04/Dart-Language-Asynchrony-Support-Phase-1/">Dart语言异步支持：阶段一</a>和<a href="/dart/async/2019/05/04/Dart-Language-Asynchrony-SupportPhase2/">Dart语言异步支持：阶段二</a>和<a href="https://www.dartlang.org/guides/language/spec" target="_blank" rel="noopener">Dart语言规范</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)在Dart中创建流</title>
      <link href="/2019/04/30/Flutter/Dart/Async/Creating%20Streams%20in%20Dart/"/>
      <url>/2019/04/30/Flutter/Dart/Async/Creating%20Streams%20in%20Dart/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.dartlang.org/articles/libraries/creating-streams" target="_blank" rel="noopener">原文链接</a></p><p>由 Lasse Nielsen 撰写</p><p>2013年4月(2018年10月更新)</p><p>dart:async 库包含两种对许多 Dart API 很重要的类型： <a href="https://api.dartlang.org/stable/dart-async/Stream-class.html" target="_blank" rel="noopener">Stream</a> 和 <a href="https://api.dartlang.org/stable/dart-async/Future-class.html" target="_blank" rel="noopener">Future</a> 。如果Future表示单次计算的结果，则流是一系列结果。你在流上监听以获得结果（数据和错误）以及流关闭的通知。你也可以在监听时暂停或在流完成之前停止监听流。</p><a id="more"></a><p>但是这篇文章不是关于使用流。这是关于创建自己的流。你可以通过以下几种方式创建流：</p><ul><li>转换现有流。</li><li>使用 <code>async *</code> 函数从头开始创建流。</li><li>使用 <code>StreamController</code> 创建流。</li></ul><p>本文介绍了每种方法的代码，并提供了帮助你正确实现流的提示。</p><p>有关使用流的帮助，请参阅<a href="/dart/async/2019/04/28/AsynchronousProgrammingStreams/">异步编程:Streams</a>。</p><h2 id="转换现有流"><a href="#转换现有流" class="headerlink" title="转换现有流"></a>转换现有流</h2><p>创建流的常见情况是你已经拥有流，并且你希望基于原始流的事件创建新流。例如，你可能有一个字节流，你希望通过 UTF-8 解码输入来转换为字符串流。最通用的方法是创建一个等待原始流上的事件然后输出新事件的新流。例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Splits a stream of consecutive strings into lines.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The input string is provided in smaller chunks through</span></span><br><span class="line"><span class="comment">/// the `source` stream.</span></span><br><span class="line">Stream&lt;<span class="built_in">String</span>&gt; lines(Stream&lt;<span class="built_in">String</span>&gt; source) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="comment">// Stores any partial line from the previous chunk.</span></span><br><span class="line">  <span class="keyword">var</span> partial = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// Wait until a new chunk is available, then process it.</span></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> chunk <span class="keyword">in</span> source) &#123;</span><br><span class="line">    <span class="keyword">var</span> lines = chunk.split(<span class="string">'\n'</span>);</span><br><span class="line">    lines[<span class="number">0</span>] = partial + lines[<span class="number">0</span>]; <span class="comment">// Prepend partial line.</span></span><br><span class="line">    partial = lines.removeLast(); <span class="comment">// Remove new partial line.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> line <span class="keyword">in</span> lines) &#123;</span><br><span class="line">      <span class="keyword">yield</span> line; <span class="comment">// Add lines to output stream.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Add final partial line to output stream, if any.</span></span><br><span class="line">  <span class="keyword">if</span> (partial.isNotEmpty) <span class="keyword">yield</span> partial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于许多常见的转换，您可以使用 Stream 提供的转换方法，例如 map() ，where() ，expand() 和 take() 。</p><p>例如，假设你有一个stream，counterStream 流，它每秒发出一个递增计数器。以下是它的实现方式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counterStream =</span><br><span class="line">    Stream&lt;<span class="built_in">int</span>&gt;.periodic(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), (x) =&gt; x).take(<span class="number">15</span>);</span><br></pre></td></tr></table></figure><p>要快速查看事件，你可以使用以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counterStream.forEach(<span class="built_in">print</span>); <span class="comment">// Print an integer every second, 15 times.</span></span><br></pre></td></tr></table></figure><p>要转换流事件，可以在监听流之前调用流上的转换方法(如map()。该方法返回一个新流。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Double the integer in each event.</span></span><br><span class="line"><span class="keyword">var</span> doubleCounterStream = counterStream.map((<span class="built_in">int</span> x) =&gt; x * <span class="number">2</span>);</span><br><span class="line">doubleCounterStream.forEach(<span class="built_in">print</span>);</span><br></pre></td></tr></table></figure><p>你可以使用任何其他转换方法，而不是map()，例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.where((<span class="built_in">int</span> x) =&gt; x.isEven) <span class="comment">// Retain only even integer events.</span></span><br><span class="line">.expand((<span class="keyword">var</span> x) =&gt; [x, x]) <span class="comment">// Duplicate each event.</span></span><br><span class="line">.take(<span class="number">5</span>) <span class="comment">// Stop after the first five events.</span></span><br></pre></td></tr></table></figure><p>通常，你只需要一种转换方法。但是，如果你需要更多地控制转换，可以使用 Stream 的transform() 方法指定 StreamTransformer 。平台库为许多常见任务提供流变换器。例如，以下代码使用 dart:convert 库提供的 utf8.decoder 和 LineSplitter 转换器。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; content = File(<span class="string">'someFile.txt'</span>).openRead();</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; lines =</span><br><span class="line">    <span class="keyword">await</span> content.transform(utf8.decoder).transform(LineSplitter()).toList();</span><br></pre></td></tr></table></figure><h2 id="从头创建流"><a href="#从头创建流" class="headerlink" title="从头创建流"></a>从头创建流</h2><p>创建新流的一种方法是使用异步生成器(async *）函数。调用函数时会创建流，并且在监听流时函数的主体开始运行。函数返回时，流关闭。在函数返回之前，它可以使用 yield 或 yield * 语句在流上发出事件。</p><p>这是一个以固定间隔发出数字的原始示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">int</span>&gt; timedCounter(<span class="built_in">Duration</span> interval, [<span class="built_in">int</span> maxCount]) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> Future.delayed(interval);</span><br><span class="line">    <span class="keyword">yield</span> i++;</span><br><span class="line">    <span class="keyword">if</span> (i == maxCount) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[PENDING：显示使用它的代码，所以我们有一些提及 StreamSubscription 的上下文？]</p><p>此函数返回一个 Stream 。当监听该流时，正文开始运行。它反复延迟请求的间隔，然后产生下一个数字。如果省略count参数，则循环上没有停止条件，因此流将永远输出越来越大的数字 - 或者直到监听器器取消其订阅。</p><p>当监听器取消（通过对listen（）方法返回的 StreamSubscription 对象调用cancel()）时，下一次正文到达 yield 语句时，yield 将作为 return 语句。执行任何封闭的 finally 块，并退出该函数。如果函数在退出之前尝试生成一个值，那么它将失败并充当返回值。</p><p>当函数最终退出时，cancel() 方法返回的 future 将完成。如果函数以错误退出，则将来会以该错误完成;否则,它以 null 结束。</p><p>另一个更有用的示例是将 future 序列转换为流的函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; streamFromFutures&lt;T&gt;(<span class="built_in">Iterable</span>&lt;Future&lt;T&gt;&gt; futures) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> future <span class="keyword">in</span> futures) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> future;</span><br><span class="line">    <span class="keyword">yield</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数要求future可迭代新的future，等待该future，发出结果值，然后循环。如果将来因错误而完成，则流将以该错误完成。</p><p>很少有异步*函数从无到有构建流。它需要从某个地方获取数据，而且通常在某个地方是另一个流。在某些情况下，与上面的future序列一样，数据来自其他异步事件源。但是，在许多情况下，async*函数过于简单，无法轻松处理多个数据源。这就是 StreamController 类的用武之地。</p><h2 id="使用StreamController"><a href="#使用StreamController" class="headerlink" title="使用StreamController"></a>使用StreamController</h2><p>如果你的流的事件来自程序的不同部分，而不仅仅是来自异步函数可以遍历的流或future，那么使用 StreamController 来创建和填充流。</p><p>StreamController 为你提供了一个新的流，以及一种在任何地方和任何地方向流添加事件的方法。该流具有处理监听器和暂停所需的所有逻辑。您返回流并将控制器保留给自己。</p><p>以下示例（来自 stream_controller_bad.dart ）展示了 StreamController 的一个基本但有缺陷的用法，用于实现前面示例中的 timedCounter() 函数。此代码创建一个要返回的流，然后根据计时器事件将数据提供给它，这些事件既不是 future 也不是流事件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> This implementation is FLAWED!</span></span><br><span class="line"><span class="comment">// It starts before it has subscribers, and it doesn't implement pause.</span></span><br><span class="line">Stream&lt;<span class="built_in">int</span>&gt; timedCounter(<span class="built_in">Duration</span> interval, [<span class="built_in">int</span> maxCount]) &#123;</span><br><span class="line">  <span class="keyword">var</span> controller = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">  <span class="built_in">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> tick(Timer timer) &#123;</span><br><span class="line">    counter++;</span><br><span class="line">    controller.add(counter); <span class="comment">// Ask stream to send counter values as event.</span></span><br><span class="line">    <span class="keyword">if</span> (maxCount != <span class="keyword">null</span> &amp;&amp; counter &gt;= maxCount) &#123;</span><br><span class="line">      timer.cancel();</span><br><span class="line">      controller.close(); <span class="comment">// Ask stream to shut down and tell listeners.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Timer.periodic(interval, tick); <span class="comment">// BAD: Starts before it has subscribers.</span></span><br><span class="line">  <span class="keyword">return</span> controller.stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和以前一样，你可以使用 timedCounter() 返回的流，如下所示：[PENDING：我们之前是否显示过这个？]</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counterStream = timedCounter(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), <span class="number">15</span>);</span><br><span class="line">counterStream.listen(<span class="built_in">print</span>); <span class="comment">// Print an integer every second, 15 times.</span></span><br></pre></td></tr></table></figure><p>timedCounter() 的这个实现有几个问题：</p><ul><li>它在订阅者之前就开始制作活动。</li><li>即使订阅者请求暂停，它也会不断产生事件。</li></ul><p>如下一节所示，您可以通过在创建StreamController时指定回调（如 onListen 和onPause ）来解决这两个问题。</p><h3 id="等待订阅"><a href="#等待订阅" class="headerlink" title="等待订阅"></a>等待订阅</h3><p>通常，流应该在开始工作之前等待订阅者。 async * 函数会自动执行此操作，但在使用StreamController 时，您可以完全控制并且即使不应该也可以添加事件。当流没有订阅者时，其 StreamController 会缓冲事件，如果流永远不会获得订阅者，则会导致内存泄漏。</p><p>尝试将使用该流的代码更改为以下内容：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> listenAfterDelay() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> counterStream = timedCounter(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">await</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// After 5 seconds, add a listener.</span></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="built_in">int</span> n <span class="keyword">in</span> counterStream) &#123;</span><br><span class="line">    <span class="built_in">print</span>(n); <span class="comment">// Print an integer every second, 15 times.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当此代码运行时，前5秒没有打印任何内容，尽管流正在运行。然后添加侦听器，并且一次打印前5个左右的事件，因为它们由 StreamController 缓冲。</p><p>要获得订阅通知，请在创建 StreamController 时指定 onListen 参数。当流获得其第一个订阅者时，将调用 onListen 回调。如果指定 onCancel 回调，则在控制器丢失其最后一个订阅者时调用它。在前面的示例中，Timer.periodic() 应该移动到onListen处理程序，如下一节所示。</p><h3 id="尊重暂停状态"><a href="#尊重暂停状态" class="headerlink" title="尊重暂停状态"></a>尊重暂停状态</h3><p>当监听器器请求暂停时，避免产生事件。当流订阅暂停时，async*函数会在yield语句中自动暂停。另一方面，StreamController 在暂停期间缓冲事件。如果提供事件的代码不遵循暂停，则缓冲区的大小可以无限增长。此外，如果监听器在暂停后立即停止监听，则浪费了创建缓冲区所花费的工作。</p><p>要查看没有暂停支持会发生什么，请尝试将使用该流的代码更改为以下内容：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> listenWithPause() &#123;</span><br><span class="line">  <span class="keyword">var</span> counterStream = timedCounter(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), <span class="number">15</span>);</span><br><span class="line">  StreamSubscription&lt;<span class="built_in">int</span>&gt; subscription;</span><br><span class="line"></span><br><span class="line">  subscription = counterStream.listen((<span class="built_in">int</span> counter) &#123;</span><br><span class="line">    <span class="built_in">print</span>(counter); <span class="comment">// Print an integer every second.</span></span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="comment">// After 5 ticks, pause for five seconds, then resume.</span></span><br><span class="line">      subscription.pause(Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">5</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当五秒钟暂停时，在此期间触发的事件都会立即收到。发生这种情况是因为流的源不支持暂停并且不断向流添加事件。因此，流缓冲事件，然后在流取消暂停时清空其缓冲区。</p><p>以下版本的 timedCounter()（来自stream_controller.dart）通过使用StreamController 上的 onListen，onPause ，onResume 和 onCancel 回调来实现暂停。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">int</span>&gt; timedCounter(<span class="built_in">Duration</span> interval, [<span class="built_in">int</span> maxCount]) &#123;</span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; controller;</span><br><span class="line">  Timer timer;</span><br><span class="line">  <span class="built_in">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> tick(_) &#123;</span><br><span class="line">    counter++;</span><br><span class="line">    controller.add(counter); <span class="comment">// Ask stream to send counter values as event.</span></span><br><span class="line">    <span class="keyword">if</span> (counter == maxCount) &#123;</span><br><span class="line">      timer.cancel();</span><br><span class="line">      controller.close(); <span class="comment">// Ask stream to shut down and tell listeners.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> startTimer() &#123;</span><br><span class="line">    timer = Timer.periodic(interval, tick);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> stopTimer() &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">      timer.cancel();</span><br><span class="line">      timer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  controller = StreamController&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">      onListen: startTimer,</span><br><span class="line">      onPause: stopTimer,</span><br><span class="line">      onResume: startTimer,</span><br><span class="line">      onCancel: stopTimer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> controller.stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上面的 listenWithPause() 函数运行此代码。你会看到它在暂停时停止计数，然后它恢复得很好。</p><p>必须使用所有监听器- onListen，onCancel，onPause 和 onResume-来通知暂停状态的更改。原因是如果订阅和暂停状态同时发生变化，则仅调用 onListen 或 onCancel 回调。</p><h2 id="最后的提示"><a href="#最后的提示" class="headerlink" title="最后的提示"></a>最后的提示</h2><p>在不使用async *函数的情况下创建流时，请记住以下提示：</p><ul><li><p>使用同步控制器时要小心 - 例如，使用 StreamController 创建的同步控制器（sync：true）。在未调用的同步控制器上发送事件时（例如，使用由 EventSink 定义的 add()，addError()或close()方法），事件将立即发送到流上的所有监听器。在添加监听器的代码完全返回之前，永远不能调用流监听器，并且在错误的时间使用同步控制器可能会破坏此承诺并导致良好的代码失败。避免使用同步控制器。</p></li><li><p>如果使用 StreamController ，则在 listen 调用返回 StreamSubscription 之前调用 onListen 回调。不要让 onListen 回调依赖于已存在的订阅。例如，在以下代码中，在订阅变量具有有效值之前触发 onListen 事件（并调用处理程序）。</p></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscription = stream.listen（handler）;</span><br></pre></td></tr></table></figure><ul><li><p>StreamController 定义的 onListen，onPause ，onResume 和 onCancel 回调在流的监听器状态更改时由流调用，但从不在事件触发期间或在调用另一个状态更改处理程序期间调用。在这些情况下，状态更改回调会延迟，直到上一次回调完成。</p></li><li><p>不要尝试自己实现 Stream 接口。很容易获得事件，回调之间的交互，以及添加和删除侦监听的巧妙错误。始终使用可能来自 StreamController 的现有流来实现新流的监听调用。</p></li><li><p>虽然可以通过扩展 Stream 类并在顶部实现 listen 方法和额外功能来创建扩展 Stream功能和更多功能的类，但通常不建议这样做，因为它引入了用户必须考虑的新类型。相反，你通常可以创建一个具有 Stream（和更多）的类 - 而不是一个Stream（以及更多）。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)单订阅流 vs. 广播流</title>
      <link href="/2019/04/29/Flutter/Dart/Async/Single-Subscription%20vs.%20Broadcast%20Streams/"/>
      <url>/2019/04/29/Flutter/Dart/Async/Single-Subscription%20vs.%20Broadcast%20Streams/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.dartlang.org/articles/libraries/broadcast-streams" target="_blank" rel="noopener">原文链接</a></p><p>由Florian Loitsch撰写</p><p>写于2014年一月</p><p>Dart具有两种不同风格的 Streams ：单订阅流和广播流。本文讨论了两者之间的差异，并提供了何时使用哪个的建议。</p><p>如果你还不熟悉Dart流，可以从教程<a href="/2019/04/28/Dart/Async/AsynchronousProgrammingStreams/">异步编程：Streams</a>中学习基础知识。</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>单订阅和广播流旨在用于不同的上下文并具有不同的要求。在许多方面，它们类似于TCP和UDP：单订阅流是稳定的，具有保证的属性（如TCP），而广播流可能丢失事件，而监听器与源没有紧密的连接（如UDP）。</p><p>以下列表总结了两者之间的主要区别：</p><table><thead><tr><th></th><th>Single subscription</th><th>Broadcast</th></tr></thead><tbody><tr><td>监听者的数量</td><td>1</td><td>∞</td></tr><tr><td>是否可以丢失事件</td><td>否</td><td>是</td></tr><tr><td>良好定义的生命周期</td><td>是</td><td>否</td></tr><tr><td>易用性</td><td>难</td><td>简单</td></tr></tbody></table><p>让我们详细看看每个差异。</p><p><strong>监听者数量</strong></p><p>单订阅流只允许监听流一次。这包括内部监听调用（例如对isNotEmpty的调用)。广播流没有此限制。</p><p><strong>可以丢失事件</strong></p><p>单订阅流不会丢失事件。如有必要，他们会缓冲数据直到监听者出现。如果没有任何监听器，广播流可以自由地丢弃事件。</p><p><strong>定义明确的生命周期</strong></p><p>单订阅流具有明确定义的生命周期：它们在用户开始监听时启动，并在用户取消或流发送关闭事件时结束。广播流通常不会给监听者由监听者结束影响其生命周期的方法。</p><p>正确获取流的生命周期非常重要：在 dart 中：io 流的生命周期决定了Dart程序对其用于传递数据的系统资源的持有时间。流类型的错误选择可能导致资源泄漏。</p><p><strong>易用性</strong></p><p>在内部，许多Stream成员（例如第一个）开始监听流。由于单订阅流只允许一个监听器，因此在它们上调用getter和方法可以自动使用该流。因此，单一订阅流不如广播流使用方便，广播流没有这种限制。</p><p>然而，广播流有其自身的陷阱。例如，isEmpty仅在使用元素后返回false。然后，用户可以继续收听流，但第一个事件将丢失。</p><p>在详细讨论流类型之前，让我们仔细看看订阅，这对于理解两种流的工作方式至关重要。</p><h2 id="订阅-Subscriptions"><a href="#订阅-Subscriptions" class="headerlink" title="订阅(Subscriptions)"></a>订阅(Subscriptions)</h2><p>从流（单订阅和广播）接收事件的最简单方法是调用其listen方法：stream.listen（onDataCallback）。实际上，listen实际上是不同流的实现方式不同的唯一方法。它将流的侦听器连接到其事件源。所有其他方法都可以（通常是）在listen方法之上实现。</p><p>listen方法创建新的流订阅，将其连接到流的事件源，并在订阅中安装回调（如果给定）。然后从listen调用返回该流订阅。回调的安装只是为了方便。订阅的处理程序可以在以后更改。通常只是为了接收流订阅而看到stream.listen（null）并不罕见。</p><p>一旦流创建了流订阅，它就会将事件生成和传播移交给订阅。大多数Stream的实现甚至都没有跟踪他们的听众。一旦流创建订阅，流就不再需要知道有关侦听器的任何信息。</p><p>下图解释了listen调用：</p><p><img src="//jinyulei.cn/2019/04/29/Flutter/Dart/Async/Single-Subscription vs. Broadcast Streams/listen.png" alt></p><p>请注意，一旦调用了listen方法，单个订阅流就不需要保留对事件源的引用。这就是为什么从Stream到事件源的箭头在“after”图片中被破坏的原因。另请注意，事件源永远不会看到（或需要查看）流。事件源仅需要对其订阅的引用。作为回报，流订阅需要指向其事件源的指针，以便它可以取消其订阅，从而关闭事件源。</p><p>此设置的另一个结果是 Stream 实例不知道事件源的状态。特别是，他们不知道事件源是否暂停。 StreamSubscription 实例接管此任务。实际上，流订阅可确保遵循暂停请求。如果无法暂停实际事件源（无论出于何种原因），则流订阅必须缓冲事件。通常，如果创建的订阅能够暂停其事件源，则流应通知其用户。不知道的话很容易导致过多的内存使用。</p><h2 id="单订阅流"><a href="#单订阅流" class="headerlink" title="单订阅流"></a>单订阅流</h2><p>单订阅流只允许一个订阅者。当消费者可以触发事件的生成（“生产”）并且丢失事件将是错误时，使用单订阅流。这种流的最佳示例是 File.openRead()：用户通过监听来启动流，并且用户通常不希望丢失事件。</p><p>单一订阅流只能被听一次这一事实具有一些重要意义。首先，最重要的是，对于单一订阅流，当流应该生成事件时，以及何时应该停止这样做时，这是非常明显的。其次，更令人讨厌的是，许多 Stream getter 和方法对于单订阅流不太有用。例如，只需使用 isNotEmpty getter在内部监听流并在获取数据后取消其订阅。此时，单订阅流已完成：流已经有一个监听器（isNotEmpty getter），并且不允许其他监听。同样，第一个getter只能被调用一次。</p><h3 id="创建单订阅流"><a href="#创建单订阅流" class="headerlink" title="创建单订阅流"></a>创建单订阅流</h3><p>创建流的最简单方法是使用 StreamController ，其中默认构造函数使用单订阅流实例化控制器。</p><p>控制器使用add，addError 和 close 等方法实现 StreamSink 接口。事件源（例如本机I / O扩展）只在具有新数据时调用相应的函数。 StreamControllers为流的实现者提供了一个简单的抽象，但从根本上说，订阅部分中解释的概念仍然有效，如下图所示。</p><p><img src="//jinyulei.cn/2019/04/29/Flutter/Dart/Async/Single-Subscription vs. Broadcast Streams/listen-with-controller.png" alt></p><p>由于控制器在用户侦听其流之前存在，因此事件源可以在用户开始监听之前将数据添加到控制器。为避免数据丢失，控制器会缓冲数据，直到用户开始收听。</p><p>此安全措施是流控制器中滥用最多的功能之一。在实例化控制器时，您可以注册onListen回调以在侦听器存在时得到通知。只有在调用此回调之后，才应将事件源添加到控制器。同样，您应该注册一个关闭流的onCancel回调。当用户取消订阅时，或者使用close（）关闭控制器时，将调用onCancel回调。</p><p>请注意，仅在流具有侦听器时生成事件不是严格的规则，而是一个很好的准则。存在一些完全有效的用例，用于在任何订阅者收听之前向控制器添加数据。但请注意，StreamSubscription的缓冲方法仅针对少数事件进行了优化，并且不会滥用它。</p><p>通常，避免数据生成的一种好方法是延迟计算直到监听器存在。例如，在侦听器存在之前，File.openRead（）不会触及文件系统。这个事实的一个奇怪的含义是File.openRead（）如果在不存在的文件上调用它就不会抛出。仅当用户开始侦听文件内容时，流才会打开硬盘驱动器上的文件。如果在侦听器订阅之前的时间（通过其他方式）创建文件，则流正常工作。直接的推论是调用File.openRead（）不会将文件锁定在硬盘驱动器上。</p><p>作为一个很好的指导原则，假设从未收听过流。此规则的例外是小型本地代码片段，例如测试，其中保证订阅发生。如果必须侦听流（以避免内存泄漏），请在创建流的函数的注释中明确说明此事实。</p><h2 id="广播流"><a href="#广播流" class="headerlink" title="广播流"></a>广播流</h2><p>作为单订阅流的对应物，Dart还带有广播流。它们的预期用途是用于独立于听众产生输出的事件源，并且缺少某些事件不是问题。通常，所有DOM事件源都是广播流。</p><p>我们可以在多次监听呼叫后扩展我们的广播流订阅图：<br><img src="//jinyulei.cn/2019/04/29/Flutter/Dart/Async/Single-Subscription vs. Broadcast Streams/broadcast-listen.png" alt></p><p>StreamSubscription实例再次负责确保暂停请求得到遵守。由于流订阅通常彼此不了解，因此最简单的解决方案是在订阅级别缓冲所有传入事件。如果订阅未恢复或取消，这可能导致内存泄漏。</p><p>能够多次收听流有一些很好的含义。其中一个是第一个，isEmpty，等等不要使流无法使用。作为回报，确定流的生命周期更加困难。流应该关闭吗？如果是，它应该在它丢失所有订阅之后关闭（只有在拥有至少一个订阅者的情况下才使流多订阅），或者只有在特定的关键数据事件没有时才允许订阅者被排出？所有这些提议都是有效的，因此广播流应记录其结束行为。通常我们假设没有文档意味着流具有无限的生命周期。</p><h3 id="创建广播流"><a href="#创建广播流" class="headerlink" title="创建广播流"></a>创建广播流</h3><p>StreamController 类附带了一个专为广播流设计的工厂构造函数StreamController.broadcast。与单订阅流相反，它不会缓冲事件。它或者直接向订阅者发送事件，或者如果没有，则丢弃事件。</p><blockquote><p>注意：没有缓冲，广播控制器似乎更简单，因此实现更快。但是，他们需要处理在上一个事件尚未分发时添加到控制器的事件。因此，当前的广播实现比单订阅流的实现更复杂。</p></blockquote><p>StreamController.broadcast构造函数还有两个回调：onListen和onCancel。只要控制器分别从未订阅切换到订阅，从订阅切换到取消订阅，都会调用它们（包括当流从事件源端关闭时）。</p><p>创建流控制器的一种更危险的方法是通过 asBroadcastStream() 查看单订阅控制器。调用asBroadcastStream 基本上告诉用户想要接管流的生命周期管理的单订阅流。与cancelOnError 订阅者一起使用时，这很容易导致从未关闭的单流订阅，从而泄漏内存或资源。</p><p>以下示例演示了这种情况：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  ServerSocket.bind(<span class="string">"localhost"</span>, <span class="number">4999</span>).then((socket) &#123;</span><br><span class="line">    socket.asBroadcastStream()  <span class="comment">// &lt;== asBroadcastStream.</span></span><br><span class="line">       .map((x) &#123; <span class="keyword">throw</span> <span class="string">"oops, my mistake"</span>; &#125;)</span><br><span class="line">       .listen(<span class="built_in">print</span>)</span><br><span class="line">       .asFuture()  <span class="comment">// Automatically cancels on error.</span></span><br><span class="line">       .catchError((_) &#123; <span class="built_in">print</span>(<span class="string">"caught error"</span>); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此示例中，单订阅流套接字被视为广播流。 asBroadcastStream在其唯一的侦听器取消后不会关闭，并且套接字保持打开状态。这是资源泄漏的典型情况。如果省略了asBroadcastStream()调用，则会通知单订阅流其订户已​​消失并将关闭套接字。</p><p>请记住：asBroadcastStream 很危险。仅在极少数情况下使用它。我们已经看到asBroadcastStream 在监听器更改和 StreamIterators 是更好的选择的情况下使用。有关示例，请参阅下一节。</p><p>或者，使用可以给 asBroadcastStream 的回调。它们允许管理订阅更改（类似于StreamController.broadcast构造函数），并提供取消订阅单订阅流的方法。</p><h3 id="asBroadcastStream的替代品"><a href="#asBroadcastStream的替代品" class="headerlink" title="asBroadcastStream的替代品"></a>asBroadcastStream的替代品</h3><p>通常asBroadcastStream是（ab）使用的，因此可以多次调用 Stream getter 和方法，例如first和take。如上所示，这是一个危险的权衡。本节介绍一些更安全的替代方案。</p><h4 id="监听者交换"><a href="#监听者交换" class="headerlink" title="监听者交换"></a>监听者交换</h4><p>流订阅允许交换他们的听众。您可以经常只在订阅上交换监听器回调，而不是在流上多次调用。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bstream = stream.asBroadcastStream();</span><br><span class="line">bstream.first.then((x) &#123;</span><br><span class="line">  handleFirstMessage();</span><br><span class="line">  <span class="keyword">return</span> bstream.first;</span><br><span class="line">&#125;).then((x) &#123;</span><br><span class="line">  handleSecondMessage();</span><br><span class="line">  bstream.listen(handleAllOtherMessages);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StreamSubscription subscription = stream.listen(null);</span><br><span class="line">subscription.onData((x) &#123;</span><br><span class="line">  handleFirstMessage();</span><br><span class="line">  subscription.onData((x) &#123;</span><br><span class="line">    handleSecondMessage();</span><br><span class="line">    subscription.onData(handleAllOtherMessages);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这引入了一些嵌套，但是一些抽象（或使用方法而不是匿名闭包）可以轻松地摆脱它们。一种流行的抽象是，例如，状态机。另一个是StreamIterator类。</p><h4 id="StreamIterator"><a href="#StreamIterator" class="headerlink" title="StreamIterator"></a>StreamIterator</h4><p>通常，异步流的不同事件将发往系统的不同部分。在这种情况下，StreamIterator通常很方便。 StreamIterators的事件被逐一拉出，每个部分都可以单独拉出它需要的事件。但是，该操作仍然是异步的：与同步迭代器相反，移动到下一个事件可能需要一些时间，因此moveNext函数返回一个未来。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Future moveNextAssert(iterator) &#123;</span><br><span class="line">  <span class="keyword">var</span> future = iterator.moveNext();</span><br><span class="line">  <span class="keyword">return</span> future.then((hasNext) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNext) <span class="keyword">throw</span> <span class="keyword">new</span> StateError(<span class="string">"missing element"</span>);</span><br><span class="line">    <span class="keyword">return</span> iterator.current;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lines = <span class="keyword">new</span> File(...).openRead()</span><br><span class="line">    .transform(utf8.decoder)</span><br><span class="line">    .transform(<span class="keyword">new</span> LineSplitter());</span><br><span class="line"><span class="keyword">var</span> iterator = <span class="keyword">new</span> StreamIterator(lines);</span><br><span class="line">moveNextAssert(iterator)</span><br><span class="line">  .then((line) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"First line: <span class="subst">$line</span>"</span>);</span><br><span class="line">    <span class="keyword">return</span> moveNextAssert(iterator);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((fileName) &#123;  <span class="comment">// Assume second line is a file.</span></span><br><span class="line">    <span class="keyword">return</span> handleFile(fileName)  <span class="comment">// Wait for it to finish.</span></span><br><span class="line">      .then((_) =&gt; moveNextAssert(iterator));</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((line) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Last line: <span class="subst">$line</span>"</span>);</span><br><span class="line">    <span class="keyword">return</span> iterator.moveNext();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((hasNext) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasNext) <span class="keyword">throw</span> <span class="string">"More lines than expected"</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>尽管它们有相似之处，但单一订阅和广播流有重要区别。您需要了解这些差异，这样可以避免资源泄漏和不必要的内存消耗。</p><p>单订阅流是为不必丢失事件和/或流必须具有明确定义的生命周期的用例而设计的。广播流针对不一定由监听器控制的事件源以及某些事件可能丢失或被忽略的事件进行调整。</p><p>在单订阅流上使用 asBroadcastStream 可能导致资源泄漏。考虑更安全的替代方案，例如监听器交换和 StreamIterators。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Event Loop 和 Dart</title>
      <link href="/2019/04/29/Flutter/Dart/Async/The%20Event%20Loop%20and%20Dart/"/>
      <url>/2019/04/29/Flutter/Dart/Async/The%20Event%20Loop%20and%20Dart/</url>
      
        <content type="html"><![CDATA[<p><a href="https://webdev.dartlang.org/articles/performance/event-loop#annotated-sample-and-output" target="_blank" rel="noopener">原文链接</a></p><p>由 Kathy Walrath 撰写</p><p>2013年9月(2013年10月更新）</p><p>Dart中的异步代码无处不在。许多库函数返回 Future 对象，你可以注册处理程序以响应鼠标单击，文件 I/O 完成和计时器到期等事件。</p><p>本文介绍了 Dart 的事件循环体系结构，以便你可以编写更好的异步代码，减少意外。你将学习调度 future 任务的选项，并且你将能够预知执行的顺序。</p><a id="more"></a><blockquote><p>注意：本文中的所有内容都适用于原生运行的 Dart 应用程序（使用Dart VM）和已编译为JavaScript 的 Dart 应用程序（ dart2js 的输出结果）。本文使用术语Dart来区分 Dart 应用程序和用其他语言编写的软件。</p></blockquote><p>在阅读本文之前，你应该熟悉<a href="/2019/04/29/Dart/Async/Futures%20and%20Error%20Handling/"> futures 和错误处理</a>的基础知识。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>如果你编写过 UI 代码，那么你可能熟悉事件循环和事件队列的概念。它们确保图形操作和鼠标点击等事件能一次被处理。</p><h3 id="事件循环和队列"><a href="#事件循环和队列" class="headerlink" title="事件循环和队列"></a>事件循环和队列</h3><p>事件循环的作用是从事件队列中获取一个条目并处理它，只要队列中有条目，就重复这两个步骤。</p><p><img src="//jinyulei.cn/2019/04/29/Flutter/Dart/Async/The Event Loop and Dart/event_queue1.webp" alt></p><p>队列中的项可能表示用户输入，文件 I/O 通知，计时器等。例如，这是包含计时器和用户输入事件的事件队列的图片：</p><p><img src="//jinyulei.cn/2019/04/29/Flutter/Dart/Async/The Event Loop and Dart/event_queue2.webp" alt></p><p>所有这些可能可能跟你熟悉的非 Dart 语言是类似的。现在让我们来谈谈它如何融入 Dart 平台。</p><h3 id="Dart-的单线程执行"><a href="#Dart-的单线程执行" class="headerlink" title="Dart 的单线程执行"></a>Dart 的单线程执行</h3><p>一旦 Dart 函数开始执行，它将继续执行直到它退出。换句话说，Dart 函数不能被其他 Dart 代码中断。</p><blockquote><p>注意：Dart 命令行应用程序可以通过创建隔离来并行运行代码。(Dart Web应用程序目前无法创建其他隔离区，但它们可以创建子线程。）隔离区不共享内存;它们就像是通过传递消息相互通信的独立应用程序。除了应用程序明确在其他隔离区或工作程序中运行的代码之外，所有应用程序的代码都在应用程序的主隔离区中运行。有关详细信息，请参阅本文后面的“<a href="https://webdev.dartlang.org/articles/performance/event-loop#use-isolates-or-workers-if-necessary" target="_blank" rel="noopener">在必要的时候使用隔离或子线程</a>”。</p></blockquote><p>如下图所示，Dart 应用程序在其主隔离执行应用程序的 <code>main()</code> 函数时开始执行。<code>main()</code> 退出后，主隔离的线程开始逐个处理应用程序事件队列中的任何项目。</p><p><img src="//jinyulei.cn/2019/04/29/Flutter/Dart/Async/The Event Loop and Dart/event-loop-and-main.webp" alt></p><p>实际上，这有点过度简化。</p><h3 id="Dart-的事件循环和队列"><a href="#Dart-的事件循环和队列" class="headerlink" title="Dart 的事件循环和队列"></a>Dart 的事件循环和队列</h3><p>Dart 应用程序具有单个事件循环，其中包含两个队列 - 事件队列和微任务队列。</p><p>事件队列包含所有外部事件：I/O，鼠标事件，绘图事件，计时器，Dart隔离之间的消息等。</p><p>微任务队列是必要的，因为事件处理代码有时需要稍后完成任务，但在将控制权返回给事件循环之前。例如，当可观察对象发生更改时，它会将多个突变更改组合在一起并以异步方式报告它们。微任务队列允许可观察对象在 DOM 显示不一致状态之前报告这些突变变化。</p><p>事件队列包含来自 Dart 和系统中其他位置的事件。目前，微任务队列仅包含源自 Dart 代码的条目，但我们希望 Web 实现插入浏览器微任务队列。(有关最新状态，请参阅dartbug.com/13433。）</p><p>如下图所示，当 main() 退出时，事件循环开始工作。首先，它按 FIFO 顺序执行任何微任务。然后它出列并处理事件队列中的第一个项目。然后它重复循环：执行所有微任务，然后处理事件队列中的下一个项目。一旦两个队列都为空并且不再需要更多事件，应用程序的嵌入器（例如浏览器或测试框架）就可以处置该应用程序。</p><p>注意：如果 Web 应用程序的用户关闭其窗口，则 Web 应用程序可能会在其事件队列为空之前退出。</p><p><img src="//jinyulei.cn/2019/04/29/Flutter/Dart/Async/The Event Loop and Dart/both-queues.webp" alt></p><blockquote><p>重要提示：当事件循环从微任务队列执行任务时，事件队列被卡住：应用程序无法绘制图形，处理鼠标点击，对 I/O 做出反应等等。</p></blockquote><p>虽然你可以预知任务执行的顺序，但你无法准确预测事件循环何时将任务从队列中删除。 Dart 事件处理系统基于单线程循环;它不是基于刻度或任何其他类型的时间测量。例如，在创建延迟任务时，事件会在你指定时排队。但是，直到处理事件队列中的所有内容（以及微任务队列中的每个任务）之前，才能处理该事件。</p><h2 id="提示：链接的-futures-指定任务顺序"><a href="#提示：链接的-futures-指定任务顺序" class="headerlink" title="提示：链接的 futures 指定任务顺序"></a>提示：链接的 futures 指定任务顺序</h2><p>如果你的代码具有依赖关系，请将它们显式化。显式依赖关系有助于其他开发人员理解您的代码，并使你的程序更能抵抗代码重构。</p><p>以下是错误编码方式的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BAD because of no explicit dependency between setting and using</span></span><br><span class="line"><span class="comment">// the variable.</span></span><br><span class="line">future.then(...<span class="keyword">set</span> an important variable...);</span><br><span class="line">Timer.run(() &#123;...use the important variable...&#125;);</span><br></pre></td></tr></table></figure><p>相反，编写如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BETTER because the dependency is explicit.</span></span><br><span class="line">future.then(...<span class="keyword">set</span> an important variable...)</span><br><span class="line">  .then((_) &#123;...use the important variable...&#125;);</span><br></pre></td></tr></table></figure><p>更好的代码使用 then() 来指定必须先设置变量才能使用它。(如果希望代码执行即使发生错误，也可以使用 whenComplete() 而不是 then()。）</p><p>如果使用变量需要花费时间并且可以在以后完成，请考虑将该代码放在新的 Future 中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MAYBE EVEN BETTER: Explicit dependency plus delayed execution.</span></span><br><span class="line">future.then(...<span class="keyword">set</span> an important variable...)</span><br><span class="line">  .then((_) &#123;<span class="keyword">new</span> Future(() &#123;...use the important variable...&#125;)&#125;);</span><br></pre></td></tr></table></figure><p>使用新的 Future 为事件循环提供了处理事件队列中其他事件的机会。下一节详细介绍了稍后运行的调度代码。</p><h3 id="如何调度任务"><a href="#如何调度任务" class="headerlink" title="如何调度任务"></a>如何调度任务</h3><p>当你需要指定稍后要执行的代码时，可以使用 dart:async 库提供的以下API：</p><ol><li><strong>Future</strong> 类，它将一个项添加到<strong>事件队列</strong>的末尾。</li><li>顶级 <strong>scheduleMicrotask()</strong> 函数，它将项添加到<strong>微任务队列</strong>的末尾。</li></ol><blockquote><p>注意：<code>scheduleMicrotask()</code> 函数曾被命名为 <code>runAsync()</code> 。(见公告。）</p></blockquote><p>使用这些API的示例位于<code>Event queue:new Future()</code> 和<code>Microtask queue:scheduleMicrotask()</code>下的下一节中。</p><h3 id="使用适当的队列（通常是：事件队列）"><a href="#使用适当的队列（通常是：事件队列）" class="headerlink" title="使用适当的队列（通常是：事件队列）"></a>使用适当的队列（通常是：事件队列）</h3><p>尽可能使用 Future 在事件队列上调度任务。使用事件队列有助于缩短微任务队列的速度，从而降低微任务队列使事件队列匮乏的可能性。</p><p>如果在处理事件队列中的任何项之前绝对必须完成任务，那么通常应该立即执行该函数。如果不能，则使用 scheduleMicrotask() 将项添加到微任务队列。例如，在Web应用程序中使用微任务来避免过早释放js-interop代理或结束IndexedDB事务或事件处理程序。</p><p><img src="//jinyulei.cn/2019/04/29/Flutter/Dart/Async/The Event Loop and Dart/scheduling-tasks.webp" alt></p><h3 id="事件队列：新的future"><a href="#事件队列：新的future" class="headerlink" title="事件队列：新的future()"></a>事件队列：新的future()</h3><p>要在事件队列上计划任务，请使用<code>new Future()</code>或<code>new Future.delayed()</code>。这些是dart:async 库中定义的两个 Future 构造函数。</p><blockquote><p>注意：你也可以使用 Timer 来安排任务，但如果任务中发生任何未捕获的异常，你的应用程序将退出。相反，我们推荐 Future ，它建立在 Timer 之上，并添加了检测任务完成和响应错误等功能。</p></blockquote><p>要立即将项目放在事件队列中，请使用<code>new Future()</code>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adds a task to the event queue.</span></span><br><span class="line"><span class="keyword">new</span> Future(() &#123;</span><br><span class="line">  <span class="comment">// ...code goes here...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你可以添加对 <code>then()</code> 或 <code>whenComplete()</code> 的调用，以在新 Future 完成后立即执行某些代码。例如，以下代码在新 Future 的任务出列时打印“42”：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Future(() =&gt; <span class="number">21</span>)</span><br><span class="line">    .then((v) =&gt; v*<span class="number">2</span>)</span><br><span class="line">    .then((v) =&gt; <span class="built_in">print</span>(v));</span><br></pre></td></tr></table></figure><p>要在一段时间后将条目排入队列，请使用<code>new Future.delayed()</code>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// After a one-second delay, adds a task to the event queue.</span></span><br><span class="line"><span class="keyword">new</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds:<span class="number">1</span>), () &#123;</span><br><span class="line">  <span class="comment">// ...code goes here...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>虽然前面的示例在一秒钟之后将任务添加到事件队列，但是在主隔离空闲，微任务队列为空以及事件队列中先前排队的条目消失之前，该任务无法执行。例如，如果 main() 函数或事件处理程序正在运行昂贵的计算，则该任务在该计算完成之后才能执行。在这种情况下，延迟可能远远超过一秒。</p><blockquote><p>提示：如果您在Web应用程序中为动画绘制帧，请不要使用 Future（或 Timer 或 Stream ）。相反，使用 <a href="https://api.dartlang.org/stable/dart-html/Window/animationFrame.html" target="_blank" rel="noopener">animationFrame</a> ，它是 requestAnimationFrame 的 Dart接口。</p></blockquote><p>关于future的有趣事实：</p><ol><li>传递给 Future 的 <strong>then()</strong> 方法的函数在 Future 完成时立即执行。(该函数未入队，只是被调用。）</li><li>如果在调用 <strong>then()</strong> 之前已经完成了Future，那么就会在微任务队列中添加一个任务，该任务执行传递给 <strong>then()</strong> 函数。</li><li><strong>Future()</strong> 和 <strong>Future.delayed()</strong> 构造函数不会立即完成;他们将一个条目添加到事件队列中。</li><li><strong>Future.value()</strong> 构造函数在微任务中完成，类​​似于＃2。</li><li><strong>Future.sync()</strong> 构造函数立即执行其函数参数（除非该函数返回Future）在微任务中完成，类​​似于＃2。</li></ol><h3 id="微任务队列：scheduleMicrotask（）"><a href="#微任务队列：scheduleMicrotask（）" class="headerlink" title="微任务队列：scheduleMicrotask（）"></a>微任务队列：scheduleMicrotask（）</h3><p>dart:async 库将 scheduleMicrotask() 定义为顶级函数。你可以像这样调用scheduleMicrotask() ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scheduleMicrotask(() &#123;</span><br><span class="line">  <span class="comment">// ...code goes here...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于错误<a href="https://github.com/dart-lang/sdk/issues/9001" target="_blank" rel="noopener">9001</a>和<a href="https://github.com/dart-lang/sdk/issues/9002" target="_blank" rel="noopener">9002</a>，第一次调用 scheduleMicrotask() 会在事件队列上调度任务;此任务创建微任务队列并将指定的函数排入 scheduleMicrotask() 。只要微任务队列至少有一个条目，对 scheduleMicrotask() 的后续调用就会正确地添加到微任务队列中。一旦微任务队列为空，就必须在下次调用 scheduleMicrotask() 时再次创建它。</p><p>这些错误的结果：你使用 scheduleMicrotask() 调度的第一个任务看起来就像是在事件队列中。</p><p>解决方法是在第一次调用 new Future() 之前先调用 scheduleMicrotask() 。这会在事件队列上执行其他任务之前创建微任务队列。但是，它不会阻止将外部事件添加到事件队列中。当你有一个延迟的任务时它也没有帮助。</p><p>将任务添加到微任务队列的另一种方法是在已经完成的 Future 上调用 then()。有关更多信息，请参阅上一节。</p><h3 id="必要时使用隔离器或工作线程"><a href="#必要时使用隔离器或工作线程" class="headerlink" title="必要时使用隔离器或工作线程"></a>必要时使用隔离器或工作线程</h3><p>如果要运行计算密集型任务，该怎么办？为了使您的应用程序保持响应，你应该将任务放入其自己的隔离或工作线程。隔离可能在单独的进程或线程中运行，具体取决于 Dart 实现。在1.0中，我们不希望Web应用程序支持隔离区或Dart语言工作者。但是，您可以使用dart: html Worker类将JavaScript工作线程添加到 Dart Web应用程序。</p><p>你应该使用多少个隔离？对于计算密集型任务，通常应该使用尽可能多的隔离区来提供可用的CPU。如果它们纯粹是计算的话，任何额外的隔离都会被浪费掉。但是，如果隔离区执行异步调用 - 例如执行 I/O  - 那么它们将不会在CPU上花费太多时间，因此拥有比CPU更多的隔离区是有意义的。</p><p>如果这是一个适合您的应用程序的良好架构，你还可以使用比CPU更多的隔离。例如，你可以为每个功能使用单独的隔离，或者在需要确保不共享数据时使用。</p><h2 id="测试你的理解"><a href="#测试你的理解" class="headerlink" title="测试你的理解"></a>测试你的理解</h2><p>现在你已经阅读了有关计划任务的所有内容，让我们测试你的理解。</p><p>请记住，您不应该依赖 Dart 的事件队列实现来指定任务顺序。实现可能会改变，Future 的 then() 和whenComplete() 方法是更好的选择。如果你能正确回答这些问题，你会不会觉得自己很聪明？</p><p>问题＃1<br>这个样本打印出来的是什么？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'main #1 of 2'</span>);</span><br><span class="line">  scheduleMicrotask(() =&gt; <span class="built_in">print</span>(<span class="string">'microtask #1 of 2'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds:<span class="number">1</span>),</span><br><span class="line">                     () =&gt; <span class="built_in">print</span>(<span class="string">'future #1 (delayed)'</span>));</span><br><span class="line">  <span class="keyword">new</span> Future(() =&gt; <span class="built_in">print</span>(<span class="string">'future #2 of 3'</span>));</span><br><span class="line">  <span class="keyword">new</span> Future(() =&gt; <span class="built_in">print</span>(<span class="string">'future #3 of 3'</span>));</span><br><span class="line"></span><br><span class="line">  scheduleMicrotask(() =&gt; <span class="built_in">print</span>(<span class="string">'microtask #2 of 2'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'main #2 of 2'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main #1 of 2</span><br><span class="line">main #2 of 2</span><br><span class="line">microtask #1 of 2</span><br><span class="line">microtask #2 of 2</span><br><span class="line">future #2 of 3</span><br><span class="line">future #3 of 3</span><br><span class="line">future #1 (delayed)</span><br></pre></td></tr></table></figure><p>该顺序应该是你所期望的，因为示例的代码分三批执行：</p><ol><li>main() 函数中的代码</li><li>微任务队列中的任务（ scheduleMicrotask() ）</li><li>事件队列中的任务（ new Future() 或 new Future.delayed() ）</li></ol><p>请记住，main() 函数中的所有调用都是同步执行，从头到尾完成。首先 main() 调用 print() ，然后调用 scheduleMicrotask() ，然后调用 new Future.delayed()，然后调用 new Future()，依此类推。只有回调 - 指定为 scheduleMicrotask() ，new Future.delayed() 和 new Future() 的参数的闭包体中的代码 - 稍后执行。</p><p>注意：目前，如果您注释掉第一次调用scheduleMicrotask()，那么futures＃2和＃3的回调将在微任务＃2之前执行。这是由于错误9001和9002，如Microtask queue：scheduleMicrotask（）中所讨论的。</p><p>问题2<br>这是一个更复杂的例子。如果你能正确预知此代码的输出，你将获得一颗金星。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'main #1 of 2'</span>);</span><br><span class="line">  scheduleMicrotask(() =&gt; <span class="built_in">print</span>(<span class="string">'microtask #1 of 3'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Future.delayed(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds:<span class="number">1</span>),</span><br><span class="line">      () =&gt; <span class="built_in">print</span>(<span class="string">'future #1 (delayed)'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Future(() =&gt; <span class="built_in">print</span>(<span class="string">'future #2 of 4'</span>))</span><br><span class="line">      .then((_) =&gt; <span class="built_in">print</span>(<span class="string">'future #2a'</span>))</span><br><span class="line">      .then((_) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'future #2b'</span>);</span><br><span class="line">        scheduleMicrotask(() =&gt; <span class="built_in">print</span>(<span class="string">'microtask #0 (from future #2b)'</span>));</span><br><span class="line">      &#125;)</span><br><span class="line">      .then((_) =&gt; <span class="built_in">print</span>(<span class="string">'future #2c'</span>));</span><br><span class="line"></span><br><span class="line">  scheduleMicrotask(() =&gt; <span class="built_in">print</span>(<span class="string">'microtask #2 of 3'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Future(() =&gt; <span class="built_in">print</span>(<span class="string">'future #3 of 4'</span>))</span><br><span class="line">      .then((_) =&gt; <span class="keyword">new</span> Future(</span><br><span class="line">                   () =&gt; <span class="built_in">print</span>(<span class="string">'future #3a (a new future)'</span>)))</span><br><span class="line">      .then((_) =&gt; <span class="built_in">print</span>(<span class="string">'future #3b'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Future(() =&gt; <span class="built_in">print</span>(<span class="string">'future #4 of 4'</span>));</span><br><span class="line">  scheduleMicrotask(() =&gt; <span class="built_in">print</span>(<span class="string">'microtask #3 of 3'</span>));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'main #2 of 2'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出，假设错误9001/9002未修复：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main #<span class="number">1</span> of <span class="number">2</span></span><br><span class="line">main #<span class="number">2</span> of <span class="number">2</span></span><br><span class="line">microtask #<span class="number">1</span> of <span class="number">3</span></span><br><span class="line">microtask #<span class="number">2</span> of <span class="number">3</span></span><br><span class="line">microtask #<span class="number">3</span> of <span class="number">3</span></span><br><span class="line">future #<span class="number">2</span> of <span class="number">4</span></span><br><span class="line">future #<span class="number">2</span>a</span><br><span class="line">future #<span class="number">2</span>b</span><br><span class="line">future #<span class="number">2</span>c</span><br><span class="line">future #<span class="number">3</span> of <span class="number">4</span></span><br><span class="line">future #<span class="number">4</span> of <span class="number">4</span></span><br><span class="line">microtask #<span class="number">0</span> (from future #<span class="number">2</span>b)</span><br><span class="line">future #<span class="number">3</span>a (a <span class="keyword">new</span> future)</span><br><span class="line">future #<span class="number">3</span>b</span><br><span class="line">future #<span class="number">1</span> (delayed)</span><br></pre></td></tr></table></figure><p>注意：由于错误9001/9002，微任务＃0在未来＃4之后执行;它应该在未来＃3之前执行。这个错误出现了，因为在未来＃2b执行时，没有微任务排队，因此微任务＃0会在事件队列上产生一个新任务，从而创建一个新的微任务队列。该微任务队列包含微任务＃0。如果你注释掉微任务＃1，那么微任务就会在未来＃2c和未来＃3之前出现在一起。</p><p>像以前一样，执行main()函数，然后执行微任务队列上的所有操作，然后执行事件队列上的任务。以下是一些有趣的观点：</p><ul><li>当 future() 回调为将来3调用 new Future() 时，它会创建一个新任务（＃3a），它被添加到事件队列的末尾。</li><li>所有 then() 回调在完成后调用 Future 时立即执行。因此，在控制返回到嵌入器之前，将来的2,2a，2b和2c一次执行。同样，未来的3a和3b将一次性执行。</li><li>如果你将3a代码从那时（（_）=&gt;新的Future（…））更改为（（_）{new Future（…）;}），那么“future＃3b”就会更早出现（之后）未来＃3，而不是未来＃3a）。原因是从回调中返回Future是你如何得到 then()（它本身返回一个新的Future）将这两个Futures链接在一起，这样当回调返回的Future完成后，then() 返回的Future完成。有关更多信息，请参阅 <a href="https://api.dartlang.org/stable/dart-async/Future/then.html" target="_blank" rel="noopener">then() 参考</a>。</li></ul><p>带注释的例子和输出<br>以下是一些可能澄清问题＃2答案的数字。首先，这是带注释的程序源：</p><p><img src="https://webdev.dartlang.org/articles/performance/images/test-annotated.png" alt></p><p>假设没有外部事件进入，这就是各个时间点的队列和输出的样子：</p><p><img src="https://webdev.dartlang.org/articles/performance/images/test-queue-output.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你现在应该了解 Dart 的事件循环以及如何安排任务。以下是Dart中事件循环的一些主要概念：</p><ul><li>Dart 应用程序的事件循环从两个队列执行任务：事件队列和微任务队列。</li><li>事件队列包含来自Dart（future，计时器，隔离消息等）和系统（用户操作，I/O 等）的条目。</li><li>目前，微任务队列只有来自 Dart 的条目，但我们希望它与浏览器微任务队列合并。</li><li>事件循环在出列并处理事件队列中的下一个项之前清空微任务队列。</li><li>一旦两个队列都为空，应用程序已完成其工作并且（取决于其嵌入器）可以退出。</li><li>main()函数以及微任务和事件队列中的所有项都在 Dart 应用程序的主隔离上运行。</li></ul><p>安排任务时，请遵循以下规则：</p><ul><li>如果可能，将其放在事件队列中（使用新的 Future() 或新的 Future.delayed() ）。</li><li>使用 Future 的 then() 或 whenComplete() 方法指定任务顺序。</li><li>为避免使事件循环匮乏，请将微任务队列保持尽可能短。</li><li>要使应用程序保持响应，请在任一事件循环中避免计算密集型任务。</li><li>要执行计算密集型任务，请创建其他隔离区或工作线程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Futures 和错误处理</title>
      <link href="/2019/04/29/Flutter/Dart/Async/Futures%20and%20Error%20Handling/"/>
      <url>/2019/04/29/Flutter/Dart/Async/Futures%20and%20Error%20Handling/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.dartlang.org/guides/libraries/futures-error-handling" target="_blank" rel="noopener">原文链接</a></p><p>本指南介绍了在编写异步代码时如何处理错误。你可以通过两种方式编写异步代码：</p><ul><li>使用 <code>async</code> 函数和 <code>await</code> 表达式，其背后使用的是 Futures。</li><li>直接使用 <a href="https://api.dartlang.org/stable/dart-async/dart-async-library.html" target="_blank" rel="noopener">Future API</a>。</li></ul><a id="more"></a><p>注意：如果你不熟悉 Futures 背后的一般概念，请先阅读<a href="/2019/05/04/Dart/Async/Asynchrony%20support/">异步编程：Futures</a>。</p><p>为什么要使用 Future API 而不是使用 <code>async</code> 和<code>await</code> ？当你需要比从 <code>async</code> 和 <code>await</code> 获得的还要有更多控制时。例如，假设你希望在 future 完成时发生某些事情，但你也希望立即继续你正在做的事情。如果使用 <code>await</code> ，则活动将暂停，直到 Future 完成。使用 Future API ，你可以注册回调并继续。</p><h2 id="Async-await-和异常"><a href="#Async-await-和异常" class="headerlink" title="Async, await 和异常"></a>Async, await 和异常</h2><p>使用异常处理 -  try ，catch 和 finally - 来处理使用 async 函数和 await 表达式的代码中的错误。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> dir = <span class="keyword">new</span> Directory(<span class="string">'/tmp'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dirList = dir.list();</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">for</span> (FileSystemEntity f <span class="keyword">in</span> dirList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (f <span class="keyword">is</span> File) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Found file <span class="subst">$&#123;f.path&#125;</span>'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">is</span> Directory) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Found dir <span class="subst">$&#123;f.path&#125;</span>'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(e.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本指南的其余部分解决了使用 Future API 时的处理错误。</p><h2 id="Future-API-以及-回调"><a href="#Future-API-以及-回调" class="headerlink" title="Future API 以及 回调"></a>Future API 以及 回调</h2><p>使用 Future API 的函数注册回调，用于处理完成 Future 的值(或错误)。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myFunc().then(processValue)</span><br><span class="line">        .catchError(handleError);</span><br></pre></td></tr></table></figure><p>注册的回调基于以下规则触发：如果在以值结束的 Future 上调用 <code>then()</code> 的回调，则触发该回调;如果在一个以错误结束的 Future 上调用了 <code>catchError()</code> 的回调，则会触发它。</p><p>在上面的例子中，如果 <code>myFunc()</code> 的Future以值结束，那么()的回调将触发。如果<code>then()</code> 中没有产生新错误，则不会触发 <code>catchError()</code> 的回调。另一方面，如果<code>myFunc()</code> 以错误结束，<code>then()</code> 的回调不会触发，而 <code>catchError()</code> 的回调就会触发。</p><h2 id="将-then-和-catchError-一起使用的例子"><a href="#将-then-和-catchError-一起使用的例子" class="headerlink" title="将 then() 和 catchError() 一起使用的例子"></a>将 then() 和 catchError() 一起使用的例子</h2><p>链接 <code>then()</code> 和 <code>catchError()</code> 调用是处理 Futures 时的常见模式，可以被认为是 try-catch 块的粗略等价物。</p><p>接下来的几节给出了这种模式的例子。</p><h3 id="catchError-作为一个完整的错误处理器"><a href="#catchError-作为一个完整的错误处理器" class="headerlink" title="catchError() 作为一个完整的错误处理器"></a>catchError() 作为一个完整的错误处理器</h3><p>以下示例处理从 <code>then()</code> 的回调中抛出异常，并演示 <code>catchError()</code> 作为错误处理程序的多功能性：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myFunc()</span><br><span class="line">  .then((value) &#123;</span><br><span class="line">    doSomethingWith(value);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span>(<span class="string">"some arbitrary error"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catchError(handleError);</span><br></pre></td></tr></table></figure><p>如果 <code>myFunc()</code> 的Future以值结束，<code>then()</code> 的回调会触发。如果then()的回调中的代码抛出（就像在上面的例子中那样），then()的Future以错误结束。该错误由 <code>catchError()</code> 处理。</p><p>如果 <code>myFunc()</code> 的Future以错误结束，<code>then()</code> 的Future完成该错误。该错误也由 <code>catchError()</code> 处理。</p><p>无论错误是在 <code>myFunc()</code> 内还是在<code>then()</code>内，<code>catchError()</code> 都会成功处理它。</p><h3 id="than-中的错误处理"><a href="#than-中的错误处理" class="headerlink" title="than() 中的错误处理"></a>than() 中的错误处理</h3><p>对于更细粒度的错误处理，你可以在 <code>then()</code> 中注册第二个（<code>onError</code>）回调来处理已结束但有错误的 Futures。这是是 <code>then()</code> 的签名：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> Future then(onValue(T value), &#123;onError(AsyncError asyncError)&#125;)</span><br></pre></td></tr></table></figure><p>仅当你要区分转发到 then() 的错误和 then() 中生成的错误时，才注册可选的 onError 回调：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">funcThatThrows()</span><br><span class="line">  .then(successCallback, onError: (e) &#123;</span><br><span class="line">    handleError(e);          <span class="comment">// Original error.</span></span><br><span class="line">    anotherFuncThatThrows(); <span class="comment">// Oops, new error.</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catchError(handleError);  <span class="comment">// Error from within then() handled.</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，使用 <code>onError</code> 回调处理 <code>funcThatThrows()</code> 的Future错误; <code>anotherFuncThatThrows()</code> 导致then() 的Future以错误结尾;这个错误由​​<code>catchError()</code> 处理。</p><p>通常，不建议实现两种不同的错误处理策略：仅当有令人信服的理由在 then() 中捕获错误时才注册第二个回调。</p><h3 id="一个长链中间的错误"><a href="#一个长链中间的错误" class="headerlink" title="一个长链中间的错误"></a>一个长链中间的错误</h3><p>通常会有一系列then()调用，并使用catchError()捕获从链的任何部分生成的错误：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; one()   =&gt; <span class="keyword">new</span> Future.value(<span class="string">"from one"</span>);</span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; two()   =&gt; <span class="keyword">new</span> Future.error(<span class="string">"error from two"</span>);</span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; three() =&gt; <span class="keyword">new</span> Future.value(<span class="string">"from three"</span>);</span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; four()  =&gt; <span class="keyword">new</span> Future.value(<span class="string">"from four"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  one()                                   <span class="comment">// Future completes with "from one".</span></span><br><span class="line">    .then((_) =&gt; two())                   <span class="comment">// Future completes with two()'s error.</span></span><br><span class="line">    .then((_) =&gt; three())                 <span class="comment">// Future completes with two()'s error.</span></span><br><span class="line">    .then((_) =&gt; four())                  <span class="comment">// Future completes with two()'s error.</span></span><br><span class="line">    .then((value) =&gt; processValue(value)) <span class="comment">// Future completes with two()'s error.</span></span><br><span class="line">    .catchError((e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"Got error: <span class="subst">$&#123;e.error&#125;</span>"</span>);     <span class="comment">// Finally, callback fires.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">42</span>;                          <span class="comment">// Future completes with 42.</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then((value) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"The value is <span class="subst">$value</span>"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output of this program:</span></span><br><span class="line"><span class="comment">//   Got error: error from two</span></span><br><span class="line"><span class="comment">//   The value is 42</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，one() 的Future以值结束，但是 two() 的 Future 以错误结束。当在以错误结束的 Future 上调用 then() 时，则不会触发 then() 的回调。相反，then() 的Future 以它的接收器的错误结尾。在我们的示例中，这意味着在调用 two() 之后，每个后续then() 返回的 Future 都会以 two 的错误结束。该错误最终在 catchError() 中处理。</p><h3 id="处理特有的错误"><a href="#处理特有的错误" class="headerlink" title="处理特有的错误"></a>处理特有的错误</h3><p>如果我们想捕获特定错误怎么办？或者捕获多个错误？</p><p>catchError() 接受一个可选的命名参数test，它允许我们查询抛出的错误类型。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> Future catchError(onError(AsyncError asyncError), &#123;<span class="built_in">bool</span> test(<span class="built_in">Object</span> error)&#125;)</span><br></pre></td></tr></table></figure><p>考虑 handleAuthResponse(params），这是一个根据提供的参数对用户进行身份验证的函数，并将用户重定向到适当的URL。鉴于复杂的工作流程，handleAuthResponse()可能会生成各种错误和异常，你应该以不同的方式处理它们。以下是如何使用test来执行此操作：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  handleAuthResponse(&#123;<span class="string">'username'</span>: <span class="string">'johncage'</span>, <span class="string">'age'</span>: <span class="number">92</span>&#125;)</span><br><span class="line">    .then((_) =&gt; ...)</span><br><span class="line">    .catchError(handleFormatException,</span><br><span class="line">                test: (e) =&gt; e <span class="keyword">is</span> FormatException)</span><br><span class="line">    .catchError(handleAuthorizationException,</span><br><span class="line">                test: (e) =&gt; e <span class="keyword">is</span> AuthorizationException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-whenComplete-的-Async-的-try-catch-finally"><a href="#使用-whenComplete-的-Async-的-try-catch-finally" class="headerlink" title="使用 whenComplete() 的 Async 的 try-catch-finally"></a>使用 whenComplete() 的 Async 的 try-catch-finally</h2><p>如果 then().catchError() 对应 try-catch ，whenComplete() 相当于 ‘finally’。在 whenComplete()中注册的回调，是在 whenComplete() 的接收器结束时被调用的，不管它是以值还是错误结尾：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = connectToServer();</span><br><span class="line">server.post(myUrl, fields: &#123;<span class="string">"name"</span>: <span class="string">"john"</span>, <span class="string">"profession"</span>: <span class="string">"juggler"</span>&#125;)</span><br><span class="line">      .then(handleResponse)</span><br><span class="line">      .catchError(handleError)</span><br><span class="line">      .whenComplete(server.close);</span><br></pre></td></tr></table></figure><p>无论 server.post() 是否产生有效响应或错误，我们都想调用 server.close 。我们通过将它放在 whenComplete() 中来确保这一点。</p><h3 id="结束由-whenComplete-返回的Future"><a href="#结束由-whenComplete-返回的Future" class="headerlink" title="结束由 whenComplete() 返回的Future"></a>结束由 whenComplete() 返回的Future</h3><p>如果没有错误从 <code>whenComplete()</code> 发出，则其 Future 将以与调用 <code>whenComplete()</code> 的Future相同的方式完成。通过示例最容易理解。</p><p>在下面的代码中，then() 的Future以错误结束，所以 whenComplete() 的 Future 也以错误结束。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  funcThatThrows()</span><br><span class="line">    .then((_) =&gt; <span class="built_in">print</span>(<span class="string">"won't reach here"</span>))    <span class="comment">// Future completes with an error.</span></span><br><span class="line">    .whenComplete(() =&gt; <span class="built_in">print</span>(<span class="string">'reaches here'</span>)) <span class="comment">// Future completes with the same error.</span></span><br><span class="line">    .then((_) =&gt; <span class="built_in">print</span>(<span class="string">"won't reach here"</span>))    <span class="comment">// Future completes with the same error.</span></span><br><span class="line">    .catchError(handleError);                  <span class="comment">// Error is handled here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面的代码中，then() 的 Future 完成了一个错误，现在由 catchError() 处理。因为catchError() 的Future以 someObject 结束，所以 whenComplete() 的Future 以同一个对象结束。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  funcThatThrows()</span><br><span class="line">    .then((_) =&gt; ...)         <span class="comment">// Future completes with an error.</span></span><br><span class="line">    .catchError((e) &#123;</span><br><span class="line">      handleError(e);</span><br><span class="line">      printErrorMessage();</span><br><span class="line">      <span class="keyword">return</span> someObject;</span><br><span class="line">    &#125;)                                   <span class="comment">// Future completes with someObject.</span></span><br><span class="line">    .whenComplete(() =&gt; <span class="built_in">print</span>(<span class="string">"Done!"</span>)); <span class="comment">// Future completes with someObject.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="来自-whenComplete-的错误"><a href="#来自-whenComplete-的错误" class="headerlink" title="来自 whenComplete() 的错误"></a>来自 whenComplete() 的错误</h3><p>如果 whenComplete() 的回调引发错误，那么 whenComplete() 的Future以该错误结束：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  funcThatThrows()</span><br><span class="line">    .catchError(handleError)               <span class="comment">// Future completes with a value.</span></span><br><span class="line">    .whenComplete(() =&gt; <span class="keyword">throw</span> <span class="string">"new error"</span>) <span class="comment">// Future completes with an error.</span></span><br><span class="line">    .catchError(handleError);              <span class="comment">// Error is handled.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="潜在问题：未能及早注册错误处理程序"><a href="#潜在问题：未能及早注册错误处理程序" class="headerlink" title="潜在问题：未能及早注册错误处理程序"></a>潜在问题：未能及早注册错误处理程序</h2><p>在 Future 完成之前安装错误处理程序至关重要：这可以避免 Future 完成错误，错误处理程序尚未附加以及错误意外传播的情况。考虑以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  Future future = funcThatThrows();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// BAD. Too late to handle funcThatThrows() exception.</span></span><br><span class="line">  <span class="keyword">new</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), () &#123;</span><br><span class="line">    future.then(...)</span><br><span class="line">          .catchError(...);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，catchError() 在调用 funcThatThrows() 之后直到半秒才注册，并且错误未处理。</p><p>如果在 Future.delayed() 回调中调用 funcThatThrows() ，问题就会消失：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">new</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), () &#123;</span><br><span class="line">    funcThatThrows().then(processValue)</span><br><span class="line">                    .catchError(handleError)); <span class="comment">// We get here.</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="潜在问题：意外混合同步和异步错误"><a href="#潜在问题：意外混合同步和异步错误" class="headerlink" title="潜在问题：意外混合同步和异步错误"></a>潜在问题：意外混合同步和异步错误</h3><p>返回 future 的函数几乎总是会在将来发出错误。由于我们不希望这些函数的调用者必须实现多个错误处理方案，因此我们希望防止任何同步错误泄漏。考虑以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; parseAndRead(data) &#123;</span><br><span class="line">  <span class="keyword">var</span> filename = obtainFileName(data);         <span class="comment">// Could throw.</span></span><br><span class="line">  File file = <span class="keyword">new</span> File(filename);</span><br><span class="line">  <span class="keyword">return</span> file.readAsString().then((contents) &#123;</span><br><span class="line">    <span class="keyword">return</span> parseFileData(contents);            <span class="comment">// Could throw.</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码中的两个函数可能同步抛出：<code>obtainFileName()</code> 和<code>parseFileData()</code> 因为<code>parseFileData()</code> 在<code>then()</code> 回调中执行，所以它的错误不会从函数中泄漏出来。相反，<code>then()</code>的<code>futureparseFileData()</code>的错误结束，错误最终结束了parseAndRead() 的future，并且 <code>catchError()</code> 可以成功处理错误。</p><p>但是，在 then() 回调中不调用 obtainFileName() ;如果它抛出，则传播同步错误：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  parseAndRead(data).catchError((e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"inside catchError"</span>);</span><br><span class="line">    <span class="built_in">print</span>(e.error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Program Output:</span></span><br><span class="line"><span class="comment">//   Unhandled exception:</span></span><br><span class="line"><span class="comment">//   &lt;error from obtainFileName&gt;</span></span><br><span class="line"><span class="comment">//   ...</span></span><br></pre></td></tr></table></figure><p>因为使用 catchError() 不捕获错误，所以 parseAndRead() 的客户端将为此错误实现单独的错误处理策略。</p><h3 id="解决方案：使用Future-sync-来包装代码"><a href="#解决方案：使用Future-sync-来包装代码" class="headerlink" title="解决方案：使用Future.sync() 来包装代码"></a>解决方案：使用Future.sync() 来包装代码</h3><p>确保不会从函数中意外抛出同步错误的常见模式是将函数体包装在新的 Future.sync() 回调中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; parseAndRead(data) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Future.<span class="keyword">sync</span>(() &#123;</span><br><span class="line">    <span class="keyword">var</span> filename = obtainFileName(data);         <span class="comment">// Could throw.</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(filename);</span><br><span class="line">    <span class="keyword">return</span> file.readAsString().then((contents) &#123;</span><br><span class="line">      <span class="keyword">return</span> parseFileData(contents);            <span class="comment">// Could throw.</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果回调返回非 Future 值，则 Future.sync() 的 Future 以该值结束。如果回调抛出（就像在上面的例子中那样），则 Future 会以错误结束。如果回调本身返回 Future，则Future 的值或错误将以 Future.sync() 的 Future 结束。</p><p>使用 Future.sync() 中包含的代码，catchError() 可以处理所有错误：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  parseAndRead(data).catchError((e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"inside catchError"</span>);</span><br><span class="line">    <span class="built_in">print</span>(e.error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Program Output:</span></span><br><span class="line"><span class="comment">//   inside catchError</span></span><br><span class="line"><span class="comment">//   &lt;error from obtainFileName&gt;</span></span><br></pre></td></tr></table></figure><p>Future.sync() 使你的代码能够抵御未捕获的异常。如果你的函数中包含大量代码，那么你可能会在没有意识到的情况下做一些危险的事情：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future fragileFunc() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Future.<span class="keyword">sync</span>(() &#123;</span><br><span class="line">    <span class="keyword">var</span> x = someFunc();     <span class="comment">// Unexpectedly throws in some rare cases.</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">10</span> / x;         <span class="comment">// x should not equal 0.</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future.sync() 不仅允许你处理你可能发生的错误，还可以防止错误意外泄漏你的功能。</p><h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>以下文档提供了有关 Future 的更多信息：</p><ul><li><a href="/2019/04/29/Dart/Async/The%20Event%20Loop%20and%20Dart/">事件循环和Dart</a>，一篇描述如何使用Futures安排任务的文章</li><li><a href="https://api.dartlang.org/stable/dart-async/Future-class.html" target="_blank" rel="noopener">Future的API参考</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)异步编程: Streams </title>
      <link href="/2019/04/28/Flutter/Dart/Async/AsynchronousProgrammingStreams/"/>
      <url>/2019/04/28/Flutter/Dart/Async/AsynchronousProgrammingStreams/</url>
      
        <content type="html"><![CDATA[<p><a href="https://dart.dev/tutorials/language/streams" target="_blank" rel="noopener">原文链接</a></p><blockquote><p>关键点有哪些？</p><ul><li>Streams提供了一个异步数据序列。</li><li>数据序列包括用户生成的事件和从文件读取的数据。</li><li>你可以使用来自 Stream API 的 <strong>await for</strong> 或 <code>listen()</code> 来处理流。</li><li>Streams 提供了一种响应错误的方法。</li><li>有两种类型的流：单一订阅流和广播流。</li></ul></blockquote><a id="more"></a><p><a href="https://api.dartlang.org/stable/dart-async/Future-class.html" target="_blank" rel="noopener">Future</a> 和 <a href="https://api.dartlang.org/stable/dart-async/Stream-class.html" target="_blank" rel="noopener">Stream</a> 类是 Dart 异步编程的特点。</p><p>Future 表示不立即完成的计算。在普通函数返回结果的地方，异步函数返回一个 Future ，这个 Future 最终将包含结果。Future 会在结果准备就绪的时候告诉你。</p><p>流是一系列异步事件。它就像一个异步的 Iterable ，流在准备好事件的时候告诉你,而不是在你要求它时获得下一个事件。</p><h2 id="接收流事件"><a href="#接收流事件" class="headerlink" title="接收流事件"></a>接收流事件</h2><p>流可以通过多种方式创建，这是另一篇文章的主题，但它们都可以以相同的方式使用：异步 for 循环(通常称为 <strong>await for</strong>）迭代流的事件就像 <strong>for 循环</strong> 在一个 Iterable 上迭代。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; sumStream(Stream&lt;<span class="built_in">int</span>&gt; stream) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">in</span> stream) &#123;</span><br><span class="line">    sum += value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码只接收整数事件流的每个事件，将它们相加，然后返回总和。循环体结束时，函数暂停，直到下一个事件到达或流完成。</p><p>该函数使用 <code>async</code> 关键字标记，这在使用 <strong>await for</strong> 循环时是必需的。</p><p>以下示例通过使用 一个 <code>async*</code> 函数生成简单的整数流来测试前面的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2015, the Dart project authors.</span></span><br><span class="line"><span class="comment">// Please see the AUTHORS file for details.</span></span><br><span class="line"><span class="comment">// All rights reserved. Use of this source code is governed</span></span><br><span class="line"><span class="comment">// by a BSD-style license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">int</span>&gt; sumStream(Stream&lt;<span class="built_in">int</span>&gt; stream) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">in</span> stream) &#123;</span><br><span class="line">    sum += value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stream&lt;<span class="built_in">int</span>&gt; countStream(<span class="built_in">int</span> to) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= to; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> stream = countStream(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="keyword">await</span> sumStream(stream);</span><br><span class="line">  <span class="built_in">print</span>(sum); <span class="comment">// 55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误事件"><a href="#错误事件" class="headerlink" title="错误事件"></a>错误事件</h2><p>当流中没有更多事件时流就完成了，并且就像通知新事件到达一样接收事件的代码会被通知。使用 一个 <strong>await for</strong> 循环读取事件时，循环在流完成时停止。</p><p>在某些情况下，在流完成之前会发生错误;也许从远程服务器获取文件时网络失败，或者创建事件的代码可能存在错误，但有人需要了解它。</p><p>Streams 还可以提供错误事件，例如它提供数据事件。大多数流将在第一个错误之后停止，但是可能有多个流提供多个错误，并且流可以在错误事件之后提供更多数据。在本文档中，我们仅讨论最多传递一个错误的流。</p><p>使用 await for 读取流时，循环语句抛出错误。这也结束了循环。你可以使用 try-catch 捕获错误。以下示例在循环迭代器等于4时抛出错误：</p><h2 id="使用-streams"><a href="#使用-streams" class="headerlink" title="使用 streams"></a>使用 streams</h2><p>Stream 类包含许多辅助方法，可以为你在流上执行常见操作，类似于<a href="https://api.dartlang.org/stable/dart-core/Iterable-class.html" target="_blank" rel="noopener">Iterable</a>上的方法。例如，你可以使用 Stream API 中的 lastWhere() 在流中找到最后一个正整数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">int</span>&gt; lastPositive(Stream&lt;<span class="built_in">int</span>&gt; stream) =&gt;</span><br><span class="line">    stream.lastWhere((x) =&gt; x &gt;= <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="两种类型的流"><a href="#两种类型的流" class="headerlink" title="两种类型的流"></a>两种类型的流</h2><p>存在两种类型的流。</p><h3 id="单订阅流"><a href="#单订阅流" class="headerlink" title="单订阅流"></a>单订阅流</h3><p>最常见的流包含一系列事件，这些事件是更大整体的一部分。事件需要以正确的顺序传递，而不会遗漏任何事件。这是你在读取文件或接收 Web 请求时获得的流。</p><p>这样的流只能被监听一次。稍后再次监听可能意味着错过了初始事件，然后流的其余部分毫无意义。当你开始监听时，将获取数据并以块的形式提供。</p><h3 id="广播流"><a href="#广播流" class="headerlink" title="广播流"></a>广播流</h3><p>另一种流用于可以一次处理一个的单个消息。例如，这种流可以用于浏览器中的鼠标事件。</p><p>你可以随时开始监听此类流，然后你可以获得在监听时触发的事件。多个监听者可以同时监听，您可以在取消之前的订阅后再次监听。</p><h2 id="处理流的方法"><a href="#处理流的方法" class="headerlink" title="处理流的方法"></a>处理流的方法</h2><p>Stream&lt;T&gt;上的以下方法处理流并返回结果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;T&gt; <span class="keyword">get</span> first;</span><br><span class="line">Future&lt;<span class="built_in">bool</span>&gt; <span class="keyword">get</span> isEmpty;</span><br><span class="line">Future&lt;T&gt; <span class="keyword">get</span> last;</span><br><span class="line">Future&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> length;</span><br><span class="line">Future&lt;T&gt; <span class="keyword">get</span> single;</span><br><span class="line">Future&lt;<span class="built_in">bool</span>&gt; any(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test);</span><br><span class="line">Future&lt;<span class="built_in">bool</span>&gt; contains(<span class="built_in">Object</span> needle);</span><br><span class="line">Future&lt;E&gt; drain&lt;E&gt;([E futureValue]);</span><br><span class="line">Future&lt;T&gt; elementAt(<span class="built_in">int</span> index);</span><br><span class="line">Future&lt;<span class="built_in">bool</span>&gt; every(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test);</span><br><span class="line">Future&lt;T&gt; firstWhere(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test, &#123;T <span class="built_in">Function</span>() orElse&#125;);</span><br><span class="line">Future&lt;S&gt; fold&lt;S&gt;(S initialValue, S <span class="built_in">Function</span>(S previous, T element) combine);</span><br><span class="line">Future forEach(<span class="keyword">void</span> <span class="built_in">Function</span>(T element) action);</span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; join([<span class="built_in">String</span> separator = <span class="string">""</span>]);</span><br><span class="line">Future&lt;T&gt; lastWhere(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test, &#123;T <span class="built_in">Function</span>() orElse&#125;);</span><br><span class="line">Future pipe(StreamConsumer&lt;T&gt; streamConsumer);</span><br><span class="line">Future&lt;T&gt; reduce(T <span class="built_in">Function</span>(T previous, T element) combine);</span><br><span class="line">Future&lt;T&gt; singleWhere(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test, &#123;T <span class="built_in">Function</span>() orElse&#125;);</span><br><span class="line">Future&lt;<span class="built_in">List</span>&lt;T&gt;&gt; toList();</span><br><span class="line">Future&lt;<span class="built_in">Set</span>&lt;T&gt;&gt; toSet();</span><br></pre></td></tr></table></figure><p>除了 <code>drain()</code> 和 <code>pipe()</code> 之外的所有这些函数都对应于 <a href="https://api.dartlang.org/stable/dart-core/Iterable-class.html" target="_blank" rel="noopener">Iterable</a> 上的类似函数。通过使用具有 <strong>await for</strong> 循环 的异步函数（或仅使用其他方法之一）,可以轻松地编写每个函数。例如，一些实现可能是：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">bool</span>&gt; contains(<span class="built_in">Object</span> needle) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> event <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event == needle) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future forEach(<span class="keyword">void</span> <span class="built_in">Function</span>(T element) action) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> event <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">    action(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">List</span>&lt;T&gt;&gt; toList() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> result = &lt;T&gt;[];</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">this</span>.forEach(result.add);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; join([<span class="built_in">String</span> separator = <span class="string">""</span>]) <span class="keyword">async</span> =&gt;</span><br><span class="line">    (<span class="keyword">await</span> <span class="keyword">this</span>.toList()).join(separator);</span><br></pre></td></tr></table></figure><p>（实际实现稍微复杂一些，但主要是出于历史原因。）</p><h2 id="修改流的方法"><a href="#修改流的方法" class="headerlink" title="修改流的方法"></a>修改流的方法</h2><p>Stream上的以下方法基于原始流返回新流。每个人都等待，直到有人在监听原始流之前监听新流。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;R&gt; cast&lt;R&gt;();</span><br><span class="line">Stream&lt;S&gt; expand&lt;S&gt;(<span class="built_in">Iterable</span>&lt;S&gt; <span class="built_in">Function</span>(T element) convert);</span><br><span class="line">Stream&lt;S&gt; map&lt;S&gt;(S <span class="built_in">Function</span>(T event) convert);</span><br><span class="line">Stream&lt;R&gt; retype&lt;R&gt;();</span><br><span class="line">Stream&lt;T&gt; skip(<span class="built_in">int</span> count);</span><br><span class="line">Stream&lt;T&gt; skipWhile(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test);</span><br><span class="line">Stream&lt;T&gt; take(<span class="built_in">int</span> count);</span><br><span class="line">Stream&lt;T&gt; takeWhile(<span class="built_in">bool</span> <span class="built_in">Function</span>(T element) test);</span><br><span class="line">Stream&lt;T&gt; where(<span class="built_in">bool</span> <span class="built_in">Function</span>(T event) test);</span><br></pre></td></tr></table></figure><p>前面的方法对应于 <a href="https://api.dartlang.org/stable/dart-core/Iterable-class.html" target="_blank" rel="noopener">Iterable</a> 上的类似方法，它将 iterable 转换为另一个 iterable 。所有这些都可以使用带有 <strong>await for</strong> 循环的异步函数轻松编写。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;E&gt; asyncExpand&lt;E&gt;(Stream&lt;E&gt; <span class="built_in">Function</span>(T event) convert);</span><br><span class="line">Stream&lt;E&gt; asyncMap&lt;E&gt;(FutureOr&lt;E&gt; <span class="built_in">Function</span>(T event) convert);</span><br><span class="line">Stream&lt;T&gt; distinct([<span class="built_in">bool</span> <span class="built_in">Function</span>(T previous, T next) equals]);</span><br></pre></td></tr></table></figure><p><code>asyncExpand()</code> 和 <code>asyncMap()</code> 函数类似于 <code>expand()</code> 和 <code>map()</code> ，但允许其函数参数为异步函数。 <code>distinct()</code> 函数在 <code>Iterable</code> 上不存在，但它可以在流上有。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; handleError(<span class="built_in">Function</span> onError, &#123;<span class="built_in">bool</span> test(error)&#125;);</span><br><span class="line">Stream&lt;T&gt; timeout(<span class="built_in">Duration</span> timeLimit,</span><br><span class="line">    &#123;<span class="keyword">void</span> <span class="built_in">Function</span>(EventSink&lt;T&gt; sink) onTimeout&#125;);</span><br><span class="line">Stream&lt;S&gt; transform&lt;S&gt;(StreamTransformer&lt;T, S&gt; streamTransformer);</span><br></pre></td></tr></table></figure><p>最后三个功能更加特殊。它们涉及到 <strong>await for</strong> 循环无法做到的错误处理， - 到达循环的第一个错误将结束循环及其在流上的订阅。并且没有恢复。在 <strong>await for</strong> 循环中使用它之前，你可以使用 <code>handleError()</code> 从流中删除错误。</p><h3 id="transform-方法"><a href="#transform-方法" class="headerlink" title="transform() 方法"></a>transform() 方法</h3><p><code>transform()</code> 函数不仅用于错误处理;它是流的更通用的 “map”。通常的map要求每个传入事件都有一个值。但是，特别是对于 I/O 流，可能需要多个传入事件才能生成输出事件。 <a href="https://api.dartlang.org/stable/dart-async/StreamTransformer-class.html" target="_blank" rel="noopener">StreamTransformer</a>可以使用它。例如，像<a href="https://api.dartlang.org/stable/dart-convert/Utf8Decoder-class.html" target="_blank" rel="noopener">Utf8Decoder</a>这样的解码器就是变换器。变换器只需要一个函数<a href="https://api.dartlang.org/stable/dart-async/StreamTransformer/bind.html" target="_blank" rel="noopener">bind()</a>，它可以通过异步函数轻松实现。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;S&gt; mapLogErrors&lt;S, T&gt;(</span><br><span class="line">  Stream&lt;T&gt; stream,</span><br><span class="line">  S <span class="built_in">Function</span>(T event) convert,</span><br><span class="line">) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="keyword">var</span> streamWithoutErrors = stream.handleError((e) =&gt; log(e));</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> event <span class="keyword">in</span> streamWithoutErrors) &#123;</span><br><span class="line">    <span class="keyword">yield</span> convert(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取和解析一个文件"><a href="#读取和解析一个文件" class="headerlink" title="读取和解析一个文件"></a>读取和解析一个文件</h3><p>以下代码读取文件并在流上运行两个转换。它首先从UTF8转换数据，然后通过<a href="https://api.dartlang.org/stable/dart-convert/LineSplitter-class.html" target="_blank" rel="noopener">LineSplitter</a>运行它。打印所有行，除了以＃标签开头的任何行＃。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> file = File(args[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">var</span> lines = file</span><br><span class="line">      .openRead()</span><br><span class="line">      .transform(utf8.decoder)</span><br><span class="line">      .transform(LineSplitter());</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> line <span class="keyword">in</span> lines) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!line.startsWith(<span class="string">'#'</span>)) <span class="built_in">print</span>(line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听方法"><a href="#监听方法" class="headerlink" title="监听方法"></a>监听方法</h2><p>Stream上的 final 方法是 <code>listen()</code>。这是一种“底层”方法 - 所有其他流函数都是根据<code>listen()</code> 定义的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StreamSubscription&lt;T&gt; listen(<span class="keyword">void</span> <span class="built_in">Function</span>(T event) onData,</span><br><span class="line">    &#123;<span class="built_in">Function</span> onError, <span class="keyword">void</span> <span class="built_in">Function</span>() onDone, <span class="built_in">bool</span> cancelOnError&#125;);</span><br></pre></td></tr></table></figure><p>要创建新的 Stream 类型，你可以扩展 <code>Stream</code> 类并实现 <code>listen()</code> 方法 - <code>Stream</code> 所有其他方法为了能工作都要调用 <code>listen()</code>。</p><p><code>listen()</code> 方法允许你开始监听流。在你这样做之前，流是一个惰性对象，描述你想要查看的事件。监听时，将返回 <a href="https://api.dartlang.org/stable/dart-async/StreamSubscription-class.html" target="_blank" rel="noopener">StreamSubscription</a> 对象，该对象表示生成事件的活动流。这类似于 <code>Iterable</code> 只是一个对象集合，但迭代器进行实际迭代。</p><p>流订阅允许你暂停订阅，暂停后恢复它，并完全取消订阅。你可以为每个数据事件或错误事件以及关闭流时设置回调。</p><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><p>有关在 Dart 中使用流和异步编程的更多详细信息，请阅读以下文档。</p><ul><li><a href="/2019/04/30/Dart/Async/Creating%20Streams%20in%20Dart/">在 Dart 中创建流</a>，这是一篇关于创建自己的流的文章</li><li><a href="/2019/04/29/Dart/Async/Futures%20and%20Error%20Handling/"> Futures 和错误处理</a>，这篇文章解释了如何使用 Future API 处理错误</li><li><a href="/2019/05/04/Dart/Async/Asynchrony%20support/">异步支持</a>，<a href="https://www.dartlang.org/guides/language/language-tour" target="_blank" rel="noopener">语言导览</a>中的一个部分</li><li><a href="https://api.dartlang.org/stable/dart-async/Stream-class.html" target="_blank" rel="noopener">流 API 参考</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)异步编程: futures 和 async-await </title>
      <link href="/2019/04/28/Flutter/Dart/Async/AsynchronousProgrammingFutures/"/>
      <url>/2019/04/28/Flutter/Dart/Async/AsynchronousProgrammingFutures/</url>
      
        <content type="html"><![CDATA[<p><a href="https://dart.dev/tutorials/language/futures" target="_blank" rel="noopener">原文链接</a></p><blockquote><p>关键点是什么？</p></blockquote><blockquote><ul><li>Dart 代码在单线程的执行区块上运行</li><li>阻塞线程的代码能够让你的程序卡死。</li><li><code>Future</code> 对象代表的是异步操作的结果-稍后要完成的处理或者 I/O 。</li><li>要实现暂停执行直到一个 future 完成了，在 async 函数中使用 <code>await</code> </li><li>要捕捉异常，在异步函数中使用 try-catch 表达式</li><li>要并发执行代码，就创建一个 <em>isolate</em> 。(或者对于 web 应用来说，创建一个工作线程)</li></ul></blockquote><a id="more"></a><p>Dart 代码在单线程的执行区块上运行。如果 Dart 代码阻塞了，例如，执行一个耗时的计算或者等待 I/O ，整个程序就会卡死。</p><p>异步操作让你的代码完成其它工作的同时等待一个操作完成。Dart 使用 <code>Future</code> 来表示异步操作的结果。要使用 future ，你可以使用 <code>async</code> 和 <code>await</code> ，或者 <code>Future</code> API。</p><blockquote><p>注意：所有 Dart 代码都在一个 <em>isolate</em> 的上下文中运行，该 <em>isolate</em> 拥有Dart代码使用的所有内存。当 Dart 代码正在执行时，同一个 isolate 中的其他代码都无法运行。</p></blockquote><blockquote><p>如果你希望多个部分的 Dart 代码并发运行，你可以在各自的 isolate 中运行它们。 （ Web 应用程序使用工作线程而不是 isolate。）多个 isolate 同时运行的时候，通常每个isolate都在其自己的CPU核心上运行。<em>isolate</em> 之间不共享内存，它们可以进行交互的唯一函数是通过相互发送消息。有关更多信息，请参阅 <a href="https://api.dartlang.org/stable/2.3.1/dart-isolate/dart-isolate-library.html" target="_blank" rel="noopener">isolates</a> 或 <a href="https://api.dartlang.org/stable/2.3.1/dart-html/Worker-class.html" target="_blank" rel="noopener"> Web 工作线程</a> 的文档。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>让我们看一些可能导致程序卡死的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步代码</span></span><br><span class="line"><span class="keyword">void</span> printDailyNewsDigest() &#123;</span><br><span class="line">  <span class="keyword">var</span> newsDigest = gatherNewsReports(); <span class="comment">// 可能需要一段时间。</span></span><br><span class="line">  <span class="built_in">print</span>(newsDigest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  printDailyNewsDigest();</span><br><span class="line">  printWinningLotteryNumbers();</span><br><span class="line">  printWeatherForecast();</span><br><span class="line">  printBaseballScore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码收集了今天的新闻，并将之打印出来，然后打印其他一堆用户感兴趣的条目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;gathered news goes here&gt;</span><br><span class="line">Winning lotto numbers: [23, 63, 87, 26, 2]</span><br><span class="line">Tomorrow&apos;s forecast: 70F, sunny.</span><br><span class="line">Baseball score: Red Sox 10, Yankees 0</span><br></pre></td></tr></table></figure><p>我们的代码是有问题的：因为 <code>gatherNewsReports()</code> 阻塞了线程，剩余的代码只有在<code>gatherNewsReports()</code> 返回文件内容之后才能运行，不管这个过程需要多长时间。如果读取文件花费了很长时间，用户就需要等待，然后就开始胡思乱想。</p><p>为了帮助应用能及时响应，Dart 库的作者在定义函数的时候使用了一个异步模型来做潜在的繁重工作。譬如使用 future 返回它们的值的函数。</p><h2 id="什么是-future-？"><a href="#什么是-future-？" class="headerlink" title="什么是 future ？"></a>什么是 future ？</h2><p>future 是一个 <a href="https://api.dartlang.org/stable/dart-async/Future-class.html" target="_blank" rel="noopener">Future&lt;T&gt;</a> 对象，用来表示异步操作产生的结果 <code>T</code>。如果结果不是一个可用的值，future的类型就是 <code>Future&lt;void&gt;</code> 。当函数返回的 future 被调用了，有两件事发生了：</p><ol><li>函数把需要做的工作放入队列然后返回一个未完成的 <code>Future</code> 对象。</li><li>稍后，当操作完成了，<code>Future</code> 对象就以一个值或一个错误完成了。</li></ol><p>当写依赖于 future 的代码的时候，你有两个选择</p><ul><li>使用 <code>async</code> 和 <code>await</code></li><li>使用 <code>Future</code> API</li></ul><h2 id="Async-和-await"><a href="#Async-和-await" class="headerlink" title="Async 和 await"></a>Async 和 await</h2><p><code>async</code> 和 <code>await</code> 关键字是 Dart 语言<a href="https://dart.dev/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">异步支持</a>的一部分。它们允许你像写同步代码一样写异步代码，并且不用使用 <code>Future</code> API。async 函数的 <code>async</code> 关键字是在它的 body 之前的。<code>await</code> 关键字只有在异步函数中才能使用。</p><blockquote><p>版本说明：在 Dart 1.x 中，异步函数立即暂停执行。在 Dart 2中，异步函数不是立即挂起，而是同步执行，直到第一个 <code>await</code> 或 <code>return</code>出现。</p></blockquote><p>以下的 app 通过使用 <code>async</code> 和 <code>await</code> 去读取这个网站上的文件内容来模拟读取新闻。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; printDailyNewsDigest() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> newsDigest = <span class="keyword">await</span> gatherNewsReports();</span><br><span class="line">  <span class="built_in">print</span>(newsDigest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  printDailyNewsDigest();</span><br><span class="line">  printWinningLotteryNumbers();</span><br><span class="line">  printWeatherForecast();</span><br><span class="line">  printBaseballScore();</span><br><span class="line">&#125;</span><br><span class="line">printWinningLotteryNumbers() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Winning lotto numbers: [23, 63, 87, 26, 2]'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printWeatherForecast() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Tomorrow's forecast: 70F, sunny."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printBaseballScore() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Baseball score: Red Sox 10, Yankees 0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> news = <span class="string">'&lt;gathered news goes here&gt;'</span>;</span><br><span class="line"><span class="keyword">const</span> oneSecond = <span class="built_in">Duration</span>(seconds: <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想象这个函数是更为复杂和慢的. :)</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; gatherNewsReports() =&gt;</span><br><span class="line">    Future.delayed(oneSecond, () =&gt; news);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一种选择, 你可以使用 dart:io 或 dart:html来从服务器获取新闻</span></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// import 'dart:html';</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future&lt;String&gt; gatherNewsReportsFromServer() =&gt; HttpRequest.getString(</span></span><br><span class="line"><span class="comment">//      'https://www.dartlang.org/f/dailyNewsDigest.txt',</span></span><br><span class="line"><span class="comment">//    );</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Winning lotto numbers: [23, 63, 87, 26, 2]</span><br><span class="line">Tomorrow&apos;s forecast: 70F, sunny.</span><br><span class="line">Baseball score: Red Sox 10, Yankees 0</span><br><span class="line">&lt;gathered news goes here&gt;</span><br></pre></td></tr></table></figure><p>注意下 <code>printDetailDigest()</code> 是首个被调用的函数，但是新闻却是最后被打印出来的，即使这个文件只包含了单行的信息。这是因为读取和打印文件的的代码是异步运行的。</p><p>在此例中，<code>printDetailNewsDigest()</code> 函数调用了<code>gatherNewReports()</code>，它是非阻塞的。调用<code>gatherNewsReports()</code> 把要做的工作放入队列但是不阻止剩余的代码执行。程序打印出了，乐透号码、天气预报、以及棒球的比分； <code>当gatherNewsReports()</code> 结束收集新闻的时候，程序把它打印出来。如果读取 <code>gatherNewsReports()</code> 花费了一小会的时间来完成它的工作，并不会造成什么伤害，在每天新闻打印之前用户可以看其它的东西。</p><p>注意下返回类型，<code>gatherNewsReports()</code> 的返回类型是 <code>Future&lt;String&gt;</code> ,这意味着它是以 string 类型值完成的 future 。<code>printDailyNewsDigest()</code> 函数，不会返回一个值，它的返回类型是 <code>Future&lt;Void&gt;</code>。</p><p>以下的示意图展示了代码中的执行流程。每个编码对应一个步骤。</p><p><img src="https://www.dartlang.org/tutorials/images/async-await.png" alt="img"></p><ol><li>应用开始执行</li><li><code>main()</code> 函数调用 async 函数 <code>printDailyNewsDigest()</code> ,它就开始同步执行。</li><li><code>printDailyNewsDigest()</code> 使用 await 来调用函数 <code>gatherNewsReports()</code> ,<code>gatherNewsReports()</code> 这个函数就开始执行。</li><li><code>gatherNewsReports()</code> 函数返回一个未完成的 future（一个 Future<string> 的实例）。</string></li><li>因为 <code>printDailyNewsDigest()</code> 是一个异步的函数并且在等待一个值，它暂停了它的执行并返回一个未完成的 future .(在此例中，一个 <code>Future&lt;void&gt;</code> 被返回到了它的调用者 <code>main()</code>)。</li><li>剩余的打印函数执行。因为它们是同步的，每个函数在移动到下一个打印函数之前已经执行完全了。例如，中奖的乐透号码是在天气预报打印之前的。</li><li>当 <code>main()</code> 函数执行完成，异步函数就能恢复执行了。首先，由 <code>gatherNewReports()</code> 返回的 future 完成了。然后 <code>printDailyNewsDigest()</code> 继续执行，打印出新闻。</li><li>当 <code>printDailyNewsDigest()</code> 函数体完成了执行，这个最初返回的 future 完成了，然后应用就退出了。</li></ol><p>注意下，async 函数开始是直接执行的(同步的)。但它遇到下面任何一种情形的时候，函数暂停了执行并返回了一个未完成的 future：</p><ul><li>函数的首个 await 表达式（在表达式中获取未完成的 future 之后）。</li><li>函数中任意的 return 声明</li><li>函数体的结束</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果返回类型为 Future 的函数以错误结尾的时候，你可能想要捕捉这个错误。异步函数可以使用 try-catch 处理错误：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; printDailyNewsDigest() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newsDigest = <span class="keyword">await</span> gatherNewsReports();</span><br><span class="line">    <span class="built_in">print</span>(newsDigest);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Handle error...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try-catch 代码与异步代码的行为方式与同步代码的行为方式相同：如果 <code>try</code> 块中的代码抛出异常，则 <code>catch</code> 子句中的代码将执行。</p><h3 id="顺序处理"><a href="#顺序处理" class="headerlink" title="顺序处理"></a>顺序处理</h3><p>你可以使用多个 <code>await</code> 表达式来确保每个语句在执行下一个语句之前完成：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 async 和 await 的线性处理.</span></span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> expensiveA();</span><br><span class="line">  <span class="keyword">await</span> expensiveB();</span><br><span class="line">  doSomethingWith(<span class="keyword">await</span> expensiveC());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>expensiveA()</code> 完成之前，<code>expensiveB()</code> 函数不会执行，依此类推。</p><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><p>阅读以下文档，了解有关在 Dart 中使用 future 和异步编程的更多详细信息：</p><ul><li><a href="/2019/05/04/Dart/Async/Asynchrony%20support/">异步支持</a>，<a href="https://www.dartlang.org/guides/language/language-tour" target="_blank" rel="noopener">语言导览</a>中的一个部分。</li><li><a href="https://api.dartlang.org/stable/dart-async/Future-class.html" target="_blank" rel="noopener">futures</a>，<a href="https://api.dartlang.org/stable/dart-isolate/dart-isolate-library.html" target="_blank" rel="noopener">isolates</a> 和 <a href="https://api.dartlang.org/stable/dart-html/Worker-class.html" target="_blank" rel="noopener">web 工作线程</a> 的 API 参考文档。</li></ul><h2 id="接下来是什么？"><a href="#接下来是什么？" class="headerlink" title="接下来是什么？"></a>接下来是什么？</h2><p>下一个教程，<a href="/2019/04/28/Dart/Async/AsynchronousProgrammingStreams/">异步编程：Streams</a>，向你展示如何使用事件流。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Async in Dart</title>
      <link href="/2019/04/27/Flutter/Dart/Async/Async%20in%20Dart/"/>
      <url>/2019/04/27/Flutter/Dart/Async/Async%20in%20Dart/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=MUDOIAssBDs&amp;list=PLOU2XLYxmsIIQorIS8gagUiMau9S84vZV&amp;index=2" target="_blank" rel="noopener">https://www.youtube.com/watch?v=MUDOIAssBDs&amp;list=PLOU2XLYxmsIIQorIS8gagUiMau9S84vZV&amp;index=2</a></p><h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><ul><li>Introduction<ul><li>synchronous vs asynchronus</li><li>dart:async</li></ul></li><li>Async/Await</li><li>Debugging</li><li>Summary</li></ul><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Synchronous:</p><ul><li>Wait</li></ul><p>Asynchronous</p><ul><li>Yield(don’t wait)</li></ul><h2 id="Parallel-Synchronous"><a href="#Parallel-Synchronous" class="headerlink" title="Parallel Synchronous"></a>Parallel Synchronous</h2><p><img src="https://qiantun.oss-cn-beijing.aliyuncs.com/img/web_Parallel_Synchronous.png" alt></p><h2 id="Problems-Synchronous"><a href="#Problems-Synchronous" class="headerlink" title="Problems - Synchronous"></a>Problems - Synchronous</h2><ul><li>Race conditions</li><li>Threads can be expensive</li><li>Inefficient usd of threads</li></ul><p><img src="https://qiantun.oss-cn-beijing.aliyuncs.com/img/dart_system_call.png" alt></p><h2 id="Async-Programming"><a href="#Async-Programming" class="headerlink" title="Async Programming"></a>Async Programming</h2><p>“Don’t wait for us. We will call you back.”</p><h2 id="Shared-Threads"><a href="#Shared-Threads" class="headerlink" title="Shared Threads"></a>Shared Threads</h2><p>Multiple tasks share the same thread.</p><p>parallel Synchronous</p><p><img src="https://qiantun.oss-cn-beijing.aliyuncs.com/img/parallelSynchronous.png" alt></p><p>Asynchronus</p><p><img src="https://qiantun.oss-cn-beijing.aliyuncs.com/img/dart_Asynchronous.png" alt></p><h2 id="Yield-to-Event-Loop"><a href="#Yield-to-Event-Loop" class="headerlink" title="Yield to Event Loop"></a>Yield to Event Loop</h2><p>Typical asynchronous pattern:</p><p>void main(){<br>  doSomethingSlow(callbackWhenDone);<br>}</p><h2 id="Async-Programming-2"><a href="#Async-Programming-2" class="headerlink" title="Async Programming-2"></a>Async Programming-2</h2><ul><li>Better use of threads</li><li>Cooperative</li><li>Callbacks</li><li>Event Loop</li><li>More reative</li></ul><p>Fits well with event-driven programs</p><h2 id="Asynchronous-in-Dart"><a href="#Asynchronous-in-Dart" class="headerlink" title="Asynchronous in Dart"></a>Asynchronous in Dart</h2><p>Asynchronous from the start.</p><ul><li>Support in dart:async</li><li>Consistently used in dart:io,dart:convert,dart:html and dart:isolate</li></ul><h2 id="Fundamental-Types"><a href="#Fundamental-Types" class="headerlink" title="Fundamental Types"></a>Fundamental Types</h2><p>One return value.</p><p>A collection of values.</p><table><thead><tr><th></th><th>Synchronous</th><th>Asynchronous</th></tr></thead><tbody><tr><td>Single</td><td>T</td><td>Future<t></t></td></tr><tr><td>Multiple</td><td>Iterable<t></t></td><td>Stream<t></t></td></tr></tbody></table><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>A Future represents a value that is not yet available.</p><p>abstract class Future {<br>   Future then(onValue(value),{onError});<br>   Future catchError(onError(error));<br>   Future whenComplete(onCompletion());<br>}</p><h2 id="Future-Example"><a href="#Future-Example" class="headerlink" title="Future-Example"></a>Future-Example</h2><p>Example:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line">main()&#123;</span><br><span class="line">   <span class="keyword">new</span> File(<span class="string">'/tep/file.text'</span>)</span><br><span class="line">   .create()<span class="comment">//Return a future.</span></span><br><span class="line">   .then((_)&#123; <span class="built_in">print</span>(<span class="string">'Created'</span>);&#125;)</span><br><span class="line">   .catchError((e)&#123;<span class="built_in">print</span>(<span class="string">'couldn'</span>t create.$e<span class="string">');&#125;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Asynchronous Iterable</p><ul><li>sequence of values</li><li>operations to manipulate and filter values</li><li>Iterables are pulled. Streams push</li></ul><h2 id="Pull"><a href="#Pull" class="headerlink" title="Pull"></a>Pull</h2><p>Iterables are pulled:</p><p>var iterator=[1,2,3].iterator;<br>while(iterator.moveNext()){<br>   print(iterator.current);<br>} </p><h2 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h2><p>Streams push:</p><p>var stream= element.onClick;<br>stream.listen(print);</p><h2 id="Iterable-API"><a href="#Iterable-API" class="headerlink" title="Iterable-API"></a>Iterable-API</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">Iterator</span>&lt;E&gt; <span class="keyword">get</span> iterator;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">Iterable</span> map(<span class="built_in">Function</span> f);</span><br><span class="line">  <span class="built_in">Iterable</span>&lt;E&gt; where(<span class="built_in">Function</span> f);</span><br><span class="line">  E           <span class="keyword">get</span> first;</span><br><span class="line">  <span class="keyword">void</span>  forEach(<span class="keyword">void</span> f(E element));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stream-Api"><a href="#Stream-Api" class="headerlink" title="Stream- Api"></a>Stream- Api</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">  listen(<span class="keyword">void</span> onData(E data),...);</span><br><span class="line">  </span><br><span class="line">  Stream map(<span class="built_in">Function</span> f);</span><br><span class="line">  Stream&lt;E&gt; where(<span class="built_in">Function</span> f);</span><br><span class="line">  Future&lt;E&gt;  <span class="keyword">get</span> first;</span><br><span class="line">  <span class="keyword">void</span>  forEach(<span class="keyword">void</span> f(E element));</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h2><ul><li>Improve syntax</li><li>Make it easier to reason about asynchronous programs</li></ul><h2 id="Stream-amp-Futures-Example"><a href="#Stream-amp-Futures-Example" class="headerlink" title="Stream &amp; Futures- Example"></a>Stream &amp; Futures- Example</h2><p>Small web-server in Dart(no error-handing):</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runServer()&#123;</span><br><span class="line">   <span class="keyword">var</span> future=HttpServer.bind(‘<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>’,<span class="number">4040</span>);</span><br><span class="line">   future.then((HttpServer server)&#123;<span class="comment">// a Stream.</span></span><br><span class="line">     server.listen((HttpRequest request)&#123;</span><br><span class="line">        request.response.write(<span class="string">'Hello, world!'</span>);</span><br><span class="line">        request.response.close();</span><br><span class="line">     &#125;);</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Synchronous-Web-Server"><a href="#Synchronous-Web-Server" class="headerlink" title="Synchronous Web Server"></a>Synchronous Web Server</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">runServer()&#123;</span><br><span class="line">   <span class="keyword">var</span> server= HttpServer.bind(<span class="string">'127.0.0.1'</span>,<span class="number">4040</span>);</span><br><span class="line">   <span class="keyword">for</span>(HttpRequest request <span class="keyword">in</span> server.requests)&#123;</span><br><span class="line">      request.response.write(<span class="string">'Hello,world!'</span>);</span><br><span class="line">      request.response.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Async-Await-Syntactic-Sugar"><a href="#Async-Await-Syntactic-Sugar" class="headerlink" title="Async/Await- Syntactic Sugar"></a>Async/Await- Syntactic Sugar</h2><p>Syntactic Sugar</p><ul><li>Modifier on the body</li><li>Function local</li><li>Explicit</li></ul><h2 id="Syntactic-Sugar-Modifier"><a href="#Syntactic-Sugar-Modifier" class="headerlink" title="Syntactic Sugar-Modifier"></a>Syntactic Sugar-Modifier</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runServer() <span class="keyword">async</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> future = HttpServer.bind(<span class="string">'127.0.0.1'</span>,<span class="number">4040</span>);</span><br><span class="line">   future.then((HttpServer server)&#123;</span><br><span class="line">      server.listen((HttpRequest request)&#123;</span><br><span class="line">         request.response.write(<span class="string">'Hello, world!'</span>);</span><br><span class="line">         request.response.close();</span><br><span class="line">        &#125;);</span><br><span class="line">       &#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Syntactic-sugar-await"><a href="#Syntactic-sugar-await" class="headerlink" title="Syntactic sugar - await"></a>Syntactic sugar - await</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">runServer() <span class="keyword">async</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> server= <span class="keyword">await</span> HttpServer.bind(<span class="string">'127.0.0.1'</span>,<span class="number">4040</span>);</span><br><span class="line">  server.listen((HttpRequest request)&#123;</span><br><span class="line">    request.response.write(<span class="string">'Hello,world!'</span>);</span><br><span class="line">    request.response.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run Server <span class="keyword">async</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> server= <span class="keyword">await</span> HttpServer.bind(<span class="string">'127.0.0.1'</span>,<span class="number">4040</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span>(HttpRequest request <span class="keyword">in</span> server)&#123;</span><br><span class="line">     request.response.write(<span class="string">'Hello, world!'</span>);</span><br><span class="line">     request.response.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nitty Gritty Details</p><h2 id="Static-Type-Await"><a href="#Static-Type-Await" class="headerlink" title="Static Type - Await"></a>Static Type - Await</h2><p>The static type of an await is the generic type of the future.</p><p>API:<br>   Future&lt;List<string>&gt; File.readAsLines();</string></p><p>Async use:</p><p>   List<string> lines = await file.readAsLines();</string></p><h2 id="Await-on-non-Futrue-value"><a href="#Await-on-non-Futrue-value" class="headerlink" title="Await on non-Futrue value"></a>Await on non-Futrue value</h2><ul><li>Await wait on any value</li><li>Wraps value in Future if necessary</li></ul><p>await 499</p><p>== </p><p>await new Future.value(499);</p><h2 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h2><p>Modifiers works on closures.</p><p>foo(() async=&gt; …);<br>foo(() async {…});</p><h2 id="Bodywrap"><a href="#Bodywrap" class="headerlink" title="Bodywrap"></a>Bodywrap</h2><p>Body of async functions is wrapped into Future.microtask.</p><p>Future runServer() async { … }</p><p>==</p><p>Future runServer()=&gt; new Future.microtask((){<br> …<br>});</p><h2 id="Bodywrap-2"><a href="#Bodywrap-2" class="headerlink" title="Bodywrap-2"></a>Bodywrap-2</h2><p>Consequences:</p><ul><li>Errors are captured and return in Future</li><li>Functions yield at entry</li><li>Returned Futures are chained</li><li>Return Type is Future</li></ul><h2 id="Return-Type"><a href="#Return-Type" class="headerlink" title="Return Type"></a>Return Type</h2><p>async functions always return a Future.</p><p>Future runServer() async {…}</p><p>Completed with the return value or error.</p><p>*</p><table><thead><tr><th></th><th>Synchronous</th><th>Asynchronous</th></tr></thead><tbody><tr><td>Single</td><td>T</td><td>Future<t></t></td></tr><tr><td>Multiple</td><td>Iterable<t></t></td><td>Stream<t></t></td></tr></tbody></table><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync*"></a>Sync*</h2><p>Create Iterabels with sync*.</p><p>Iterable range(int from, int to) sync*{<br>   for(int i=form;i&lt;to;i++){<br>      yield i;<br>   }<br>}</p><p>range(3,6).forEach(print);//Prints 3 4 5</p><h2 id="Yield"><a href="#Yield" class="headerlink" title="Yield"></a>Yield</h2><ul><li>Yield pushes one value</li><li>yield* pipes through another iterable</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Iterable</span> recRange(<span class="built_in">int</span> from,<span class="built_in">int</span> to) <span class="keyword">sync</span>*&#123;</span><br><span class="line">   <span class="keyword">if</span>(from&lt;to)&#123;</span><br><span class="line">      <span class="keyword">yield</span> from;</span><br><span class="line">      <span class="keyword">yield</span>* recRange(from+<span class="number">1</span>,to)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Async"><a href="#Async" class="headerlink" title="Async*"></a>Async*</h2><p>Create Streams with async*</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream bigFiles(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; fileNames) <span class="keyword">async</span>*&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> fileName <span class="keyword">in</span> fileNames)&#123;</span><br><span class="line">     <span class="keyword">var</span> stat = <span class="keyword">await</span> <span class="keyword">new</span> File(fileName).stat();</span><br><span class="line">     <span class="keyword">if</span>(stat.size&gt;<span class="number">10000</span>) <span class="keyword">yield</span> fileName;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Yield-Await"><a href="#Yield-Await" class="headerlink" title="Yield + Await"></a>Yield + Await</h2><p>The async*  modifier enables:</p><ul><li>yield</li><li>yield*</li><li>awiat</li><li>awiat for</li></ul><h2 id="Async-Details"><a href="#Async-Details" class="headerlink" title="Async*- Details"></a>Async*- Details</h2><p>Good to know:</p><ul><li>Function is not started before listen</li><li>Finallies are executed on cancel</li><li>Yield eventually returns to event loop</li></ul><p>while(true) {yield 499;}</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Asynchronous debugging is hard.</p><ul><li>interleaved execution</li><li>stack frames are lost</li></ul><p>No Sliver Bullet</p><h2 id="Debugging-Example"><a href="#Debugging-Example" class="headerlink" title="Debugging - Example"></a>Debugging - Example</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="string">'asynchronous wait'</span>;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'bad'</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar()=&gt; foo();</span><br><span class="line">gee()=&gt; bar();</span><br><span class="line">main()&#123;</span><br><span class="line">  gee();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cleaned-Stacktrace"><a href="#Cleaned-Stacktrace" class="headerlink" title="Cleaned Stacktrace"></a>Cleaned Stacktrace</h2><p>Stacktrace contains a lot of noisy internal frames.</p><p>After cleanup:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Unhandled exception:</span><br><span class="line">Uncaught Error: bad</span><br><span class="line">Stack Trace:</span><br><span class="line">\#<span class="number">0</span> foo(example.dart:<span class="number">5</span>:<span class="number">3</span>)</span><br><span class="line">&lt;asynchronous entry&gt;</span><br></pre></td></tr></table></figure><h2 id="Zones"><a href="#Zones" class="headerlink" title="Zones"></a>Zones</h2><p>Zones:</p><ul><li>Reason for noisy stack traces</li><li>Provide hooks for sophisticated stack-trace tracking</li></ul><h2 id="Zone"><a href="#Zone" class="headerlink" title="Zone"></a>Zone</h2><ul><li>create ZoneDescription</li><li>fork zone</li><li>intercept all asynchronous calls</li><li>wrap targets and store tracing information</li><li>install that information when coming back</li><li>…</li></ul><h2 id="Stack-trace-package"><a href="#Stack-trace-package" class="headerlink" title="Stack_trace package"></a>Stack_trace package</h2><p>Already done:</p><p><a href="https://pub.flutter-io.cn/packages/stack_trace" target="_blank" rel="noopener">https://pub.flutter-io.cn/packages/stack_trace</a></p><h2 id="Debugging-Original"><a href="#Debugging-Original" class="headerlink" title="Debugging- Original"></a>Debugging- Original</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="string">'asynchronous wait'</span>;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'bad'</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar()=&gt; foo();</span><br><span class="line">gee()=&gt; bar();</span><br><span class="line">main()&#123;</span><br><span class="line">  gee();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:stack_trace/stack_trace.dart'</span>;</span><br><span class="line">...</span><br><span class="line">foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="string">'asynchronous wait'</span>;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'bad'</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar()=&gt; foo();</span><br><span class="line">gee()=&gt; bar();</span><br><span class="line">main()&#123;</span><br><span class="line">  Chain.capture(gee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:stack_trace/stack_trace.dart'</span>;</span><br><span class="line">...</span><br><span class="line">foo() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="string">'asynchronous wait'</span>;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'bad'</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar()=&gt; foo();</span><br><span class="line">gee()=&gt; bar();</span><br><span class="line">main()&#123;</span><br><span class="line">  Chain.capture(gee,onError:(e.chain)&#123;<span class="built_in">print</span>(chain.terse);&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul><li>Asynchronous programming well supported in Dart</li><li>Async / await tremendously simplifies asynchronous programming</li><li>stack_trace package helps in debugging</li></ul><h2 id="Credits"><a href="#Credits" class="headerlink" title="Credits"></a>Credits</h2><p>Futures:</p><ul><li>As old as 1976</li><li>Lots of JavaScript packages</li></ul><p>Streams:</p><ul><li>Reactive Extensions(Rx)</li></ul><p>Aysnc/await:</p><ul><li>.NET Framework 4.5</li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
            <tag> Async </tag>
            
            <tag> Dart Developer Summit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)手势</title>
      <link href="/2019/04/26/Flutter/development/ui/Advanced%20UI/gestures/"/>
      <url>/2019/04/26/Flutter/development/ui/Advanced%20UI/gestures/</url>
      
        <content type="html"><![CDATA[<p>本文档说明了如何在Flutter监听并响应手势。手势的例子包括点击、拖放、缩放。</p><p>Flutter 中的手势系统有两个独立的层。第一层有原始指针(pointer)事件，它描述了屏幕上指针(例如，触摸，鼠标和触控笔)的位置和移动。第二层有手势，描述由一个或多个指针移动组成的语义动作。</p><a id="more"></a><h2 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h2><p>指针(Pointer)代表用户与设备屏幕交互的原始数据。有四种类型的指针事件</p><ul><li><a href="https://api.flutter.dev/flutter/gestures/PointerDownEvent-class.html" target="_blank" rel="noopener"><code>PointerDownEvent</code></a> 指针已经接触到屏幕的特定位置</li><li><a href="https://api.flutter.dev/flutter/gestures/PointerMoveEvent-class.html" target="_blank" rel="noopener"><code>PointerMoveEvent</code></a> 指针从屏幕上的一个位置移动到另一个位置</li><li><a href="https://api.flutter.dev/flutter/gestures/PointerUpEvent-class.html" target="_blank" rel="noopener"><code>PointerUpEvent</code></a> 指针离开屏幕</li><li><a href="https://api.flutter.dev/flutter/gestures/PointerCancelEvent-class.html" target="_blank" rel="noopener"><code>PointerCancelEvent</code></a> 指针的输入事件不再针对此应用</li></ul><p>在指针按下时，框架对你的应用程序执行了一次命中测试，以确定指针与屏幕相接的位置存在哪些widget。指针按下事件(以及该指针的后续事件)然后被分发到由命中测试发现的最内部的widget。从那里开始，事件在widget树中向上冒泡，这些事件会从最内部的widget被分发到到widget根的路径上的所有widget,没有机制取消或停止冒泡过程。</p><p>要直接从widget层监听指针事件，可以使用Listenerwidget。但是通常来说，请考虑使用手势（如下所述）</p><h2 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h2><p>手势表示由多个单独的指针事件(甚至可能是多个单独的指针)识别的语义动作(例如，轻敲，拖动和缩放)。 完整的一个手势可以分派多个事件，对应于手势的生命周期(例如，拖动开始，拖动更新和拖动结束)：</p><ul><li>Tap<ul><li><code>onTapDown</code> 指针已经在特定位置与屏幕接触</li><li><code>onTapUp</code> 指针在特定位置离开屏幕</li><li><code>onTap</code> 点击事件触发</li><li><code>onTapCancel</code> 先前指针触发的<code>onTapDown</code>不会在触发tap事件</li></ul></li><li>双击<ul><li><code>onDoubleTap</code>用户快速连续两次在同一位置点击屏幕.</li></ul></li><li>长按<ul><li><code>onLongPress</code>指针在相同位置长时间保持与屏幕接触</li></ul></li><li>垂直拖动<ul><li><code>onVerticalDragStart</code> 指针已经与屏幕接触并可能开始垂直移动</li><li><code>onVerticalDragUpdate</code> 指针与屏幕接触并已沿垂直方向移动.</li><li><code>onVerticalDragEnd</code> 先前与屏幕接触并垂直移动的指针离开屏幕，并且在停止接触屏幕时以特定速度移动</li></ul></li><li>水平拖动<ul><li><code>onHorizontalDragStart</code> 指针已经接触到屏幕并可能开始水平移动</li><li><code>onHorizontalDragUpdate</code> 指针与屏幕接触并已沿水平方向移动</li><li><code>onHorizontalDragEnd</code> 先前与屏幕接触并水平移动的指针不再与屏幕接触，并在停止接触屏幕时以特定速度移动</li></ul></li></ul><p>要从widget层监听手势，请使用 <a href="https://api.flutter.dev/flutter/widgets/GestureDetector-class.html" target="_blank" rel="noopener"><code>GesutreDetector</code></a></p><p>如果你使用的是Material组件，这些widget中的许多widget已经对点击或手势作出了响应。例如，<a href="https://api.flutter.dev/flutter/material/IconButton-class.html" target="_blank" rel="noopener"><code>IconButton</code></a>和<a href="https://api.flutter.dev/flutter/material/FlatButton-class.html" target="_blank" rel="noopener"><code>FlatButton</code></a>会对点击作出响应，<a href="https://api.flutter.dev/flutter/widgets/ListView-class.html" target="_blank" rel="noopener"><code>ListView</code></a>的触摸滑动。如果你使用的不是这些widget,但是你想要点击的水波纹效果，你可以使用<a href="https://api.flutter.dev/flutter/material/InkWell-class.html" target="_blank" rel="noopener"><code>InkWell</code></a>。</p><h2 id="手势消歧"><a href="#手势消歧" class="headerlink" title="手势消歧"></a>手势消歧</h2><p>在屏幕上的指定位置，可能会有多个手势检测器。所有这些手势检测器在指针事件流经过的时候，监听指针事件流，并尝试识别特定手势。GestureDetectorwidget基于它的哪个回调是非空的，决定识别哪个手势。</p><p>当屏幕上给定指针有多个手势检测器时，框架通过让每个检测器加入一个“手势竞技场”来确定用户想要的手势。“手势竞技场”使用以下规则确定哪个手势胜出:</p><ul><li><p>在任何时候，识别者都可以宣布失败并离开“手势竞技场”。如果在“手势竞技场”中只剩下一个检测器，那么该检测器就是赢家。</p></li><li><p>在任何时候，识别者可以声明为胜利，这会造成它胜利，并且所有剩下的识别器都会失败。</p></li></ul><p>例如，在消除水平和垂直拖动的歧义时，两个识别器在接收到指针向下事件时进入“手势竞技场”。检测器观察指针移动事件。 如果用户将指针水平移动超过一定数量的逻辑像素，则水平识别器将声明胜利，并且手势将被解释为水平拖拽。 类似地，如果用户垂直移动超过一定数量的逻辑像素，垂直识别器将宣布胜利。</p><p>当只有水平（或垂直）拖动识别器时，“手势竞技场”是有益的。在这种情况下，“手势竞争场”将只有一个识别器，并且水平拖动将被立即识别，这意味着水平移动的第一个像素可以被视为拖动，用户不需要等待进一步的手势消歧。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gestures </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)交织动画</title>
      <link href="/2019/04/25/Flutter/development/ui/animations/Staggered%20Animations/"/>
      <url>/2019/04/25/Flutter/development/ui/animations/Staggered%20Animations/</url>
      
        <content type="html"><![CDATA[<p>你将学到什么</p><ul><li>交织动画由连续或重叠的动画组成。</li><li>要创建交织动画，请使用多个动画对象。</li><li>一个 <code>AnimationController</code> 控制所有动画。</li><li>每个 <code>Animation</code> 对象在间隔期间指定动画。</li><li>对于要设置动画的每个属性，请创建一个 <code>Tween</code>。</li></ul><a id="more"></a><p>术语：如果补间或渐变的概念对你来说是新的，请参阅<a href="/flutter/animations/2019/04/24/Animations-tutorial/"><code>Flutter动画教程</code></a>。</p><p>交织的动画是一个直截了当的概念：视觉变化发生在一系列操作中，而不是一次性发生。动画可能是纯粹的顺序动画，在下一个动画之后会发生一个变化，或者它可能部分或完全重叠。它也可能有间隙，没有发生变化。</p><p>本指南介绍了如何在Flutter中构建交织动画。</p><p>例子<br>本指南解释了 basic_staggered_animation 示例。你还可以参考更复杂的示例staggered_pic_selection。</p><p><a href="https://github.com/flutter/website/tree/master/examples/_animation/basic_staggered_animation" target="_blank" rel="noopener">basic_staggered_animation</a></p><p>展示单个widget的一系列连续和重叠动画。点击屏幕会开始一个动画，可以改变不透明度，大小，形状，颜色和内边距。</p><p><a href="https://github.com/flutter/website/tree/master/examples/_animation/staggered_pic_selection" target="_blank" rel="noopener">staggered_pic_selection</a></p><p>展示从以三种尺寸之一显示的图像列表中删除图像。此示例使用两个动画控制器：一个用于图像选择/取消选择，另一个用于图像删除。选择/取消选择动画是交织的。(要查看此效果，您可能需要增加timeDilation值。）选择一个最大的图像 - 它会缩小，因为它在蓝色圆圈内显示一个复选标记。接下来，选择一个最小的图像 - 大图像随着复选标记消失而扩展。在大图像完成展开之前，小图像会缩小以显示其复选标记。这种交织行为类似于你在Google相册中看到的行为。</p><p>以下视频演示了basic_staggered_animation执行的动画：</p><iframe width="772" height="435" src="https://www.youtube.com/embed/0fFvnZemmh8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>在视频中，您会看到widget的以下动画，该widget以带有略微圆角的边框蓝色方块开始。方块按以下顺序运行更改：</p><ol><li>淡入</li><li>扩大</li><li>向上移动时变得更高</li><li>转变为有边界的圆圈</li><li>将颜色更改为橙​​色</li></ol><p>正向运行之后，动画反向运行。</p><p>Flutter新手？本页假定你知道如何使用Flutter的widget创建布局。有关更多信息，请参阅<a href="https://flutter.dev/docs/development/ui/layout" target="_blank" rel="noopener">在Flutter中构建布局</a>。</p><h2 id="交织动画的基本结构"><a href="#交织动画的基本结构" class="headerlink" title="交织动画的基本结构"></a>交织动画的基本结构</h2><p>重点是什么？</p><ul><li>所有动画都由同一个AnimationController驱动。</li><li>无论动画实时持续多长时间，控制器的值必须介于0.0和1.0之间。</li><li>每个动画的间隔介于0.0和1.0之间。</li><li>对于在间隔中设置动画的每个属性，请创建一个Tween。 Tween指定该属性的开始值和结束值。</li><li>Tween生成一个由控制器管理的Animation对象。</li></ul><p>下图显示了 <a href="https://github.com/flutter/website/tree/master/examples/_animation/basic_staggered_animation" target="_blank" rel="noopener">basic_staggered_animation</a> 示例中使用的间隔。你可能会注意到以下特征：</p><ul><li>不透明度在时间轴的前10％期间发生变化。</li><li>不透明度的变化与宽度的变化之间存在微小的差距。</li><li>在最后25％的时间线中没有任何动画。</li><li>增加内边距使widget看起来升高了。</li><li>将边框半径增加到0.5，将带圆角的方形转换为圆形。</li><li>内边距和边界半径变化发生在相同的精确间隔期间，但它们不必。</li></ul><p><img src="https://flutter.dev/assets/ui/animations/StaggeredAnimationIntervals-ea26220d9436a04e001ebaa4fc0b8dd69496a0274563d0f9df145cc2a5fa8299.png" alt></p><p>要设置动画：</p><ul><li>创建一个管理所有动画的AnimationController。</li><li>为每个正在设置动画的属性创建一个Tween。<ul><li>Tween定义了一系列值。</li><li>Tween的animate方法需要父控制器，并为该属性生成一个Animation。</li></ul></li><li>在“动画”曲线属性上指定间隔。</li></ul><p>当控制动画的值更改时，新动画的值会更改，从而触发UI更新。</p><p>以下代码为width属性创建补间。它构建一个<a href="https://api.flutter.dev/flutter/animation/CurvedAnimation-class.html" target="_blank" rel="noopener">CurvedAnimation</a>，指定一个缓和的曲线。有关其他可用的预定义动画曲线，请参阅<a href="https://api.flutter.dev/flutter/animation/Curves-class.html" target="_blank" rel="noopener">曲线</a>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">width = Tween&lt;<span class="built_in">double</span>&gt;(</span><br><span class="line">  begin: <span class="number">50.0</span>,</span><br><span class="line">  end: <span class="number">150.0</span>,</span><br><span class="line">).animate(</span><br><span class="line">  CurvedAnimation(</span><br><span class="line">    parent: controller,</span><br><span class="line">    curve: Interval(</span><br><span class="line">      <span class="number">0.125</span>, <span class="number">0.250</span>,</span><br><span class="line">      curve: Curves.ease,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>开始值(begin)和结束值(end)不必是双精度数。下面的代码使用 <code>BorderRadius.circular</code>() 为 <code>borderRadius</code> 属性（控制方块角的圆度）构建补间。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">borderRadius = BorderRadiusTween(</span><br><span class="line">  begin: BorderRadius.circular(<span class="number">4.0</span>),</span><br><span class="line">  end: BorderRadius.circular(<span class="number">75.0</span>),</span><br><span class="line">).animate(</span><br><span class="line">  CurvedAnimation(</span><br><span class="line">    parent: controller,</span><br><span class="line">    curve: Interval(</span><br><span class="line">      <span class="number">0.375</span>, <span class="number">0.500</span>,</span><br><span class="line">      curve: Curves.ease,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><h2 id="完成的交织动画"><a href="#完成的交织动画" class="headerlink" title="完成的交织动画"></a>完成的交织动画</h2><p>与所有交互式widget一样，完整动画由widget对组成：无状态widget和有状态widget。</p><p>无状态widget指定补间，定义Animation对象，并提供build()函数，负责构建widget树的动画部分。</p><p>有状态widget创建控制器，播放动画，并构建widget树的非动画部分。在屏幕中的任何位置检测到点击时，动画开始。</p><p><a href="https://github.com/flutter/website/tree/master/examples/_animation/basic_staggered_animation/main.dart" target="_blank" rel="noopener">basic_staggered_animation的main.dart的完整代码</a></p><h2 id="无状态小部件：StaggerAnimation"><a href="#无状态小部件：StaggerAnimation" class="headerlink" title="无状态小部件：StaggerAnimation"></a>无状态小部件：StaggerAnimation</h2><p>在无状态widgetStaggerAnimation中，build()函数实例化AnimatedBuilder–一个用于构建动画的通用widget。 AnimatedBuilder构建一个widget并使用Tweens的当前值配置它。该示例创建一个名为<code>_buildAnimation()</code>的函数（执行实际的UI更新），并将其分配给其构建器属性。 AnimatedBuilder监听来自动画控制器的通知，在值发生变化时将widget树标记为脏。对于动画的每个刻度，值都会更新，从而调用<code>_buildAnimation()</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaggerAnimation</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  StaggerAnimation(&#123; Key key, <span class="keyword">this</span>.controller &#125;) :</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Each animation defined here transforms its value during the subset</span></span><br><span class="line">    <span class="comment">// of the controller's duration defined by the animation's interval.</span></span><br><span class="line">    <span class="comment">// For example the opacity animation transforms its value during</span></span><br><span class="line">    <span class="comment">// the first 10% of the controller's duration.</span></span><br><span class="line"></span><br><span class="line">    opacity = Tween&lt;<span class="built_in">double</span>&gt;(</span><br><span class="line">      begin: <span class="number">0.0</span>,</span><br><span class="line">      end: <span class="number">1.0</span>,</span><br><span class="line">    ).animate(</span><br><span class="line">      CurvedAnimation(</span><br><span class="line">        parent: controller,</span><br><span class="line">        curve: Interval(</span><br><span class="line">          <span class="number">0.0</span>, <span class="number">0.100</span>,</span><br><span class="line">          curve: Curves.ease,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... Other tween definitions ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; controller;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; opacity;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; width;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; height;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;EdgeInsets&gt; padding;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;BorderRadius&gt; borderRadius;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;Color&gt; color;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This function is called each time the controller "ticks" a new frame.</span></span><br><span class="line">  <span class="comment">// When it runs, all of the animation's values will have been</span></span><br><span class="line">  <span class="comment">// updated to reflect the controller's current value.</span></span><br><span class="line">  Widget _buildAnimation(BuildContext context, Widget child) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      padding: padding.value,</span><br><span class="line">      alignment: Alignment.bottomCenter,</span><br><span class="line">      child: Opacity(</span><br><span class="line">        opacity: opacity.value,</span><br><span class="line">        child: Container(</span><br><span class="line">          width: width.value,</span><br><span class="line">          height: height.value,</span><br><span class="line">          decoration: BoxDecoration(</span><br><span class="line">            color: color.value,</span><br><span class="line">            border: Border.all(</span><br><span class="line">              color: Colors.indigo[<span class="number">300</span>],</span><br><span class="line">              width: <span class="number">3.0</span>,</span><br><span class="line">            ),</span><br><span class="line">            borderRadius: borderRadius.value,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> AnimatedBuilder(</span><br><span class="line">      builder: _buildAnimation,</span><br><span class="line">      animation: controller,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有状态widget：StaggerDemo"><a href="#有状态widget：StaggerDemo" class="headerlink" title="有状态widget：StaggerDemo"></a>有状态widget：StaggerDemo</h2><p>有状态widget StaggerDemo创建了AnimationController（统一它们的人），指定持续时间为2000毫秒。它播放动画，并构建widget树的非动画部分。在屏幕中检测到点击时动画开始。动画正向播放，然后倒放。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaggerDemo</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _StaggerDemoState createState() =&gt; _StaggerDemoState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_StaggerDemoState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StaggerDemo</span>&gt; <span class="title">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  AnimationController _controller;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    _controller = AnimationController(</span><br><span class="line">      duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>),</span><br><span class="line">      vsync: <span class="keyword">this</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...Boilerplate...</span></span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; _playAnimation() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> _controller.forward().orCancel;</span><br><span class="line">      <span class="keyword">await</span> _controller.reverse().orCancel;</span><br><span class="line">    &#125; on TickerCanceled &#123;</span><br><span class="line">      <span class="comment">// the animation got canceled, probably because we were disposed</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    timeDilation = <span class="number">10.0</span>; <span class="comment">// 1.0 is normal animation speed.</span></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: <span class="keyword">const</span> Text(<span class="string">'Staggered Animation'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: GestureDetector(</span><br><span class="line">        behavior: HitTestBehavior.opaque,</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          _playAnimation();</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Container(</span><br><span class="line">            width: <span class="number">300.0</span>,</span><br><span class="line">            height: <span class="number">300.0</span>,</span><br><span class="line">            decoration: BoxDecoration(</span><br><span class="line">              color: Colors.black.withOpacity(<span class="number">0.1</span>),</span><br><span class="line">              border: Border.all(</span><br><span class="line">                color:  Colors.black.withOpacity(<span class="number">0.5</span>),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            child: StaggerAnimation(</span><br><span class="line">              controller: _controller.view</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Animations </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Hero 动画</title>
      <link href="/2019/04/25/Flutter/development/ui/animations/Hero%20Animations/"/>
      <url>/2019/04/25/Flutter/development/ui/animations/Hero%20Animations/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/development/ui/animations/hero-animations" target="_blank" rel="noopener">原文链接</a></p><p>你会学到什么</p><ul><li><code>hero</code>指的是在路由之间飞行的widget。</li><li>使用Flutter的<code>Hero</code>widget创建一个<code>hero</code>动画。</li><li>将<code>hero</code>从一个路由飞到另一个路由。</li><li>动画将<code>hero</code>的形状从圆形变为矩形，同时将其从一个路由飞到另一个路由。</li><li>Flutter中的<code>Hero</code>widget 实现了一种动画风格，通常称为共享元素过渡或共享元素动画。</li></ul><a id="more"></a><p>你可能已经多次看过<code>Hero</code>动画了。例如，路由显示表示待售物品的缩略图列表。选择条目会将其飞到一个新路由，其中包含更多详细信息和“购买”按钮。将图像从一个路由飞到另一个路由在Flutter中称为<code>hero</code>动画，尽管相同的运动有时被称为共享元素过渡。</p><p>你可能想要观看介绍<code>Hero widget</code>的这一分钟视频：</p><iframe width="560" height="315" src="https://www.youtube.com/embed/Be9UH1kXFDw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>本指南演示了如何构建标准<code>Hero</code>动画，以及在飞行过程中将图像从圆形变换为方形的<code>Hero</code>动画。</p><p>示例：本指南提供以下链接中每种<code>hero</code>动画样式的示例。</p><ul><li><a href="https://flutter.dev/docs/development/ui/animations/hero-animations#standard-hero-animation-code" target="_blank" rel="noopener">Standard hero animation code</a></li><li><a href="https://flutter.dev/docs/development/ui/animations/hero-animations#radial-hero-animation-code" target="_blank" rel="noopener">Radial hero animation code</a></li></ul><p>Flutter新手？本页假定您知道如何使用Flutter的widget创建布局。有关更多信息，请参阅<a href="https://flutter.dev/docs/development/ui/layout" target="_blank" rel="noopener">在Flutter中构建布局</a>。</p><p>术语：<a href="/flutter/navigation/2019/04/24/Navigate-to-a-new-screen-and-back/">路由</a>描述Flutter应用程序中的页面或屏幕。</p><p>你可以使用<code>Hero</code> widget在Flutter中创建此动画。当<code>hero</code>以动画形式从源路由到目标路由时，目标路由会淡入视图。通常，<code>hero</code>是UI的一小部分，如图像，两条路由都有共同之处。从用户的角度来看，<code>hero</code>在路由之间“飞翔”。本指南介绍如何创建以下<code>hero</code>动画：</p><p><code>标准hero动画</code></p><p>标准<code>hero</code>动画将<code>hero</code>从一个路由飞到一个新路由，通常降落在不同的位置并且具有不同的大小。</p><p>以下视频(以低速录制)展示了一个典型示例。在路由中心点击脚蹼将它们飞到新的蓝色路由的左上角，尺寸较小。在蓝色路由中点击脚蹼（或使用设备的回到前一个路由的手势）将脚蹼飞回原始路由。</p><iframe width="910" height="512" src="https://www.youtube.com/embed/CEcFnqRDfgw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><code>径向hero动画</code></p><p>在径向hero动画中，当<code>hero</code>在路由之间飞行时，其形状呈现为从圆形变为矩形。</p><p>以下视频(以低速录制)显示了径向<code>hero</code>动画的示例。开始时，路由底部会出现一排三个圆形图像。点击任何圆形图像会将图像飞到一个以正方形形状显示的新路由上。点击方形图像会使<code>hero</code>回到原始路由，显示为圆形。</p><iframe width="910" height="512" src="https://www.youtube.com/embed/LWKENpwDKiM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>在进入到特定于标准或径向<code>hero</code>动画的部分之前，阅读<code>hero</code>动画的基本结构以学习如何构建<code>hero</code>动画代码，并在表象背后了解Flutter如何执行<code>hero</code>动画的。</p><h2 id="hero动画的基本结构"><a href="#hero动画的基本结构" class="headerlink" title="hero动画的基本结构"></a><code>hero</code>动画的基本结构</h2><p>重点是什么？</p><ul><li>在不同的路由中使用两个widget小部件，但使用匹配的标签来实现动画。</li><li>Navigator管理着包含应用程序路由的堆栈。</li><li>从导航器的堆栈中<code>push</code>路由或<code>pop</code>路由会触发动画。</li><li>Flutter框架计算一个<a href="https://api.flutter.dev/flutter/animation/RectTween-class.html" target="_blank" rel="noopener">矩形补间</a>，用于定义<code>hero</code>从源路由到目的地路由的边界。在飞行过程中，<code>hero</code>被移动到应用程序的覆盖层，以便它出现在两个路由的顶部。</li></ul><p>术语：如果补间或补间的概念对你来说是新的，请参阅<a href="/flutter/animations/2019/04/24/Animations-tutorial/">Flutter中的动画教程</a>。</p><p>使用两个Hero widget实现<code>hero</code>动画：一个描述源路由中的widget，另一个描述目标路由中的小widget。从用户的角度来看，<code>hero</code>似乎是共享的，只有程序员才需要了解这个实现细节。</p><p>关于对话框的注意事项：<code>hero</code>从一个<code>PageRoute</code>路由飞到另一个。对话框（例如，用showDialog()显示 ),使用的是PopupRoutes，它们不是<code>PageRoute</code>。至少目前，你无法在Dialog上实现hero动画。有关进一步的开发(以及可能的解决方法)，请<a href="https://github.com/flutter/flutter/issues/10667" target="_blank" rel="noopener">查看此问题</a>。</p><p><code>hero</code>动画代码具有以下结构：</p><ol><li>定义一个起始<code>hero</code>小部件，称为源<code>hero</code>。<code>hero</code>指定其图形表示(通常是图像)和识别标记，并且在源路由定义的当前显示的widget树中。</li><li>定义一个结束<code>hero</code>小部件，称为目标<code>hero</code>。此<code>hero</code>还指定其图形表示，以及与源<code>hero</code>相同的标记。两个hero widget都必须使用相同的标记创建，通常是表示基础数据的对象。为了获得最佳效果，<code>hero</code>应该拥有几乎相同的widget树。</li><li>创建包含目标<code>hero</code>的路由。目标路由定义动画结尾处存在的widget树。</li><li>通过在导航器堆栈上按下目标路由来触发动画。导航器的push和pop操作会触发每对<code>hero</code>的<code>hero</code>动画，并在源和目标路由中使用匹配的标记。</li><li>Flutter计算从起点到终点设置Hero边界的动画的补间(插值大小和位置),并在叠加层中执行动画。</li></ol><p>下一节将更详细地介绍Flutter的处理过程。</p><h2 id="表象背后"><a href="#表象背后" class="headerlink" title="表象背后"></a>表象背后</h2><p>以下描述了Flutter如何执行从一个路由到另一个路由的过渡。</p><p><img src="https://flutter.dev/assets/ui/animations/hero-transition-0-e129c393b824c1026897ff0051019e344062817525ea83babf3d8afb74e0234c.png" alt></p><p>在转换之前，源<code>hero</code>在源路由的widget树中等待。目标路由尚不存在，并且叠加层为空。</p><p><img src="https://flutter.dev/assets/ui/animations/hero-transition-1-af93acb4da6e70ef6d902af4b64b2a9d1ab92c97ebd6a2580d259bdf058e36ad.png" alt></p><p>将路由<code>push</code>到导航器会触发动画。在t = 0.0时，Flutter执行以下操作：</p><p>在画面外，使用<code>Material</code>运动规范中描述的曲面运动计算目标<code>hero</code>的路径。Flutter现在知道<code>hero</code>最终的位置。</p><p>将目标<code>hero</code>放置在叠加层中，与源<code>hero</code>的位置和大小相同。向叠加层添加<code>hero</code>会更改其Z轴上顺序，以使其显示在所有路由的顶部。</p><p>将源<code>hero</code>移动到屏幕外。</p><p><img src="https://flutter.dev/assets/ui/animations/hero-transition-2-fb104777adbaac9003639cab2b40aa4fae20033d522be4064b1790653e2fef29.png" alt></p><p>当<code>hero</code>飞行时，它的矩形边界使用在Hero的createRectTween属性中指定的<a href="https://api.flutter.dev/flutter/animation/Tween-class.html" target="_blank" rel="noopener">Tween &lt;Rect&gt;</a>进行动画处理。默认情况下，Flutter使用<a href="https://api.flutter.dev/flutter/material/MaterialRectArcTween-class.html" target="_blank" rel="noopener">MaterialRectArcTween</a>的实例，该实例沿着弯曲路径设置矩形的对角线。(有关使用不同Tween动画的示例，请参阅径向<code>hero</code>动画。）</p><p><img src="https://flutter.dev/assets/ui/animations/hero-transition-3-66ff086cd05a7ff64290c41634d6bbd63c025126427fc0a3459af8fd71b7cded.png" alt></p><p>飞行完成时：</p><p>Flutter将hero widget从叠加层移动到目标路由。叠加层现在为空。</p><p>目标<code>hero</code>出现在目的地路由的最终位置。</p><p>源<code>hero</code>将恢复到其路由。</p><p>pop路由执行相同的过程，将<code>hero</code>动画回原点和源路由中的位置。</p><h3 id="必要的类"><a href="#必要的类" class="headerlink" title="必要的类"></a>必要的类</h3><p>本指南中的示例使用以下类来实现<code>hero</code>动画：</p><p><code>hero</code></p><p>从源到目标路由的widget。为源路由定义一个<code>Hero</code>，为目标路由定义另一个<code>Hero</code>，并为每个分配相同的标记。flutter使用匹配的标签做出<code>hero</code>对的动画。</p><p><code>Inkwell</code></p><p>指定点击<code>hero</code>时会发生什么。InkWell的onTap()方法构建新路由并将其<code>push</code>到Navigator的堆栈。</p><p><code>Navigator</code></p><p>Navigator管理一堆路由。从导航器的堆栈中<code>push</code>路由或<code>pop</code>路由会触发动画。</p><p><code>Route</code></p><p>指定屏幕或页面。除最基本的应用程序之外，大多数应用程序都有个路由。</p><h2 id="标准Hero动画"><a href="#标准Hero动画" class="headerlink" title="标准Hero动画"></a>标准Hero动画</h2><p>重点是什么？</p><ul><li>使用<code>MaterialPageRoute</code>，<code>CupertinoPageRoute</code>指定路由，或使用<code>PageRouteBuilder</code>构建自定义路由。本节中的示例使用<code>MaterialPageRoute</code>。</li><li>通过将目标图像包装在SizedBox中，在过渡结束时更改图像的大小。</li><li>通过将目标图像放置在widget中来更改图像的位置。这些示例使用Container。</li></ul><p>标准<code>hero</code>动画代码</p><p>以下每个示例都演示了将图像从一个路由飞到另一个路由。本指南介绍了第一个示例。</p><p><a href="https://github.com/flutter/website/tree/master/examples/_animation/hero_animation/" target="_blank" rel="noopener">hero_animation</a></p><p>将<code>hero</code>代码封装在自定义PhotoHero widget 中。沿着曲线路径动画<code>hero</code>的动作，如Material运动规范中所述。</p><p><a href="https://github.com/flutter/website/tree/master/examples/_animation/basic_hero_animation/" target="_blank" rel="noopener">basic_hero_animation</a></p><p>直接使用<code>hero</code>widget。本指南中未介绍此基本示例，供你参考。</p><h3 id="这是怎么回事？"><a href="#这是怎么回事？" class="headerlink" title="这是怎么回事？"></a>这是怎么回事？</h3><p>使用Flutter的<code>hero</code> widget可以轻松实现将图像从一个路由传输到另一个路由。使用<code>MaterialPageRoute</code>指定新路由时，图像沿着弯曲路径飞行，如“Material设计”运动规范所述。</p><p><a href="https://flutter.dev/docs/get-started/test-drive" target="_blank" rel="noopener">创建一个新的Flutter示例</a>并使用<a href="https://github.com/flutter/website/tree/master/examples/_animation/hero_animation/" target="_blank" rel="noopener">Gi​​tHub目录中</a>的文件进行更新。</p><p>运行示例：</p><ul><li>点击主路由的照片，将图像拖动到新的路由，在不同的位置，以不同比例显示相同的照片。</li><li>通过点击图像或使用设备的返回上一个路由手势返回上一个路由。</li><li>你可以使用<code>timeDilation</code>属性进一步减慢过渡。</li></ul><h3 id="PhotoHero类"><a href="#PhotoHero类" class="headerlink" title="PhotoHero类"></a>PhotoHero类</h3><p>自定义PhotoHero类在点击时维护<code>hero</code>及其大小，图像和行为。PhotoHero构建了以下widget树：</p><p><img src="https://flutter.dev/assets/ui/animations/photohero-class-ebc745117913037726a9660636a95d6b54fb59d077bceecef1546975722c4c1a.png" alt></p><p>这里是代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class PhotoHero extends StatelessWidget &#123;</span><br><span class="line">  const PhotoHero(&#123; Key key, this.photo, this.onTap, this.width &#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  final String photo;</span><br><span class="line">  final VoidCallback onTap;</span><br><span class="line">  final double width;</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return SizedBox(</span><br><span class="line">      width: width,</span><br><span class="line">      child: Hero(</span><br><span class="line">        tag: photo,</span><br><span class="line">        child: Material(</span><br><span class="line">          color: Colors.transparent,</span><br><span class="line">          child: InkWell(</span><br><span class="line">            onTap: onTap,</span><br><span class="line">            child: Image.asset(</span><br><span class="line">              photo,</span><br><span class="line">              fit: BoxFit.contain,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键信息：</p><ul><li>当HeroAnimation作为app的home属性提供时，MaterialApp会隐式push起始路由。</li><li>InkWell包装图像，使得向源和目标<code>hero</code>添加点击手势变得微不足道。</li><li>使用透明颜色定义“Material”widget可使图像在飞往目标时“弹出”背景。</li><li>SizedBox指定动画开始和结束时<code>hero</code>的大小。</li><li>将Image的fit属性设置为BoxFit.contain，可确保在过渡期间图像尽可能大，而不会更改其宽高比。</li></ul><h3 id="HeroAnimation类"><a href="#HeroAnimation类" class="headerlink" title="HeroAnimation类"></a>HeroAnimation类</h3><p>HeroAnimation类创建源和目标 <code>PhotoHeroes</code>，并设置过渡。</p><p>这是代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroAnimation</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    timeDilation = <span class="number">5.0</span>; <span class="comment">// 1.0 means normal animation speed.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: <span class="keyword">const</span> Text(<span class="string">'Basic Hero Animation'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: PhotoHero(</span><br><span class="line">          photo: <span class="string">'images/flippers-alpha.png'</span>,</span><br><span class="line">          width: <span class="number">300.0</span>,</span><br><span class="line">          onTap: () &#123;</span><br><span class="line">            Navigator.of(context).push(MaterialPageRoute&lt;<span class="keyword">void</span>&gt;(</span><br><span class="line">              builder: (BuildContext context) &#123;</span><br><span class="line">                <span class="keyword">return</span> Scaffold(</span><br><span class="line">                  appBar: AppBar(</span><br><span class="line">                    title: <span class="keyword">const</span> Text(<span class="string">'Flippers Page'</span>),</span><br><span class="line">                  ),</span><br><span class="line">                  body: Container(</span><br><span class="line">                    <span class="comment">// The blue background emphasizes that it's a new route.</span></span><br><span class="line">                    color: Colors.lightBlueAccent,</span><br><span class="line">                    padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">                    alignment: Alignment.topLeft,</span><br><span class="line">                    child: PhotoHero(</span><br><span class="line">                      photo: <span class="string">'images/flippers-alpha.png'</span>,</span><br><span class="line">                      width: <span class="number">100.0</span>,</span><br><span class="line">                      onTap: () &#123;</span><br><span class="line">                        Navigator.of(context).pop();</span><br><span class="line">                      &#125;,</span><br><span class="line">                    ),</span><br><span class="line">                  ),</span><br><span class="line">                );</span><br><span class="line">              &#125;</span><br><span class="line">            ));</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键信息：</p><ul><li>当用户点击包含源<code>hero</code>的InkWell时，代码使用<code>MaterialPageRoute</code>创建目标路由。将目标路由<code>push</code>到导航器的堆栈会触发动画。</li><li>Container将PhotoHero定位在AppBar下方的目的路由的左上角。</li><li>目标PhotoHero的onTap()方法 <code>pop</code>导航器的堆栈，触发将Hero飞回原始路由的动画。</li><li>使用<code>timeDilation</code>属性可以在调试时减慢转换速度。</li></ul><h2 id="径向hero动画"><a href="#径向hero动画" class="headerlink" title="径向hero动画"></a>径向hero动画</h2><p>重点是什么？</p><ul><li>径向过渡将圆形动画变为方形。</li><li>径向<code>hero</code>动画在将<code>hero</code>从源路由飞到目标路由时执行径向过渡。</li><li><code>MaterialRectCenterArcTween</code> 定义 补间动画。</li><li>使用<code>PageRouteBuilder</code>构建目标路由。</li></ul><p>将路由从一个路由飞向另一个路由，因为它从圆形过渡为矩形，这是一种光滑的效果，你可以使用<code>hero</code>widget来实现。为此，代码动画两个剪辑形状的交集：圆形和方形。在整个动画中，圆形剪辑（和图像）从minRadius缩放到maxRadius，而方形剪辑保持不变的大小。同时，图像从其在源路由中的位置飞到其在目的路由中的位置。有关此过渡的可视示例，请参阅材质运动规范中的<a href="https://material.io/guidelines/motion/transforming-material.html#transforming-material-radial-transformation" target="_blank" rel="noopener">径向过渡</a>。</p><p>此动画可能看起来很复杂(并且确实如此)，但你可以根据需要自定义提供的示例。繁重的工作已经为你完成了。</p><p>径向<code>hero</code>动画代码</p><p>以下每个示例都演示了径向<code>hero</code>动画。本指南介绍了第一个示例。</p><p><a href="https://github.com/flutter/website/tree/master/examples/_animation/radial_hero_animation" target="_blank" rel="noopener">radial_hero_animation</a></p><p>材质运动规范中描述的径向<code>hero</code>动画。</p><p><a href="https://github.com/flutter/website/tree/master/examples/_animation/basic_radial_hero_animation" target="_blank" rel="noopener">basic_radial_hero_animation</a></p><p>径向<code>hero</code>动画的最简单示例。目的路由没有<code>Scaffold</code>, <code>Card</code>, <code>Column</code>或<code>Text</code>。本指南中未介绍此基本示例，供你参考。</p><p><a href="https://github.com/flutter/website/tree/master/examples/_animation/radial_hero_animation_animate_rectclip" target="_blank" rel="noopener">radial_hero_animation_animate_rectclip</a></p><p>通过动画化矩形剪辑的大小来扩展radial_hero_animaton。本指南中未介绍此高级示例，供你参考。</p><p>专业提示：径向<code>hero</code>动画涉及将圆形与正方形相交。即使使用timeDilation减慢动画速度，也很难看到这一点，因此你可以考虑在开发过程中启用Flutter的可视化调试模式。</p><h3 id="这是怎么回事？-1"><a href="#这是怎么回事？-1" class="headerlink" title="这是怎么回事？"></a>这是怎么回事？</h3><p>下图显示了动画开头(t = 0.0)和结束(t = 1.0)的剪裁图像。</p><p><img src="https://flutter.dev/assets/ui/animations/radial-hero-animation-cf2651ecb9c60cd5001451fb534e90621774cc186adebd519b056eaa92dec33f.png" alt></p><p>蓝色渐变(表示图像)表示剪辑形状相交的位置。在转换开始时，交集的结果是一个圆形剪辑（<a href="https://api.flutter.dev/flutter/widgets/ClipOval-class.html" target="_blank" rel="noopener">ClipOval</a>）。在转换期间，ClipOval从minRadius缩放到maxRadius，而<a href="https://api.flutter.dev/flutter/widgets/ClipRect-class.html" target="_blank" rel="noopener">ClipRect</a>保持恒定大小。在过渡结束时，圆形和矩形剪辑的交叉产生一个与<code>hero</code>widget大小相同的矩形。换句话说，在转换结束时，图像不再被剪裁。</p><p><a href="https://flutter.dev/docs/get-started/test-drive" target="_blank" rel="noopener">创建一个新的Flutter示例</a>并使用<a href="https://github.com/flutter/website/tree/master/examples/_animation/radial_hero_animation" target="_blank" rel="noopener">Gi​​tHub目录</a>中的文件进行更新。</p><p>运行示例：</p><ul><li>点击三个圆形缩略图中的一个，将图像设置为一个较大的正方形，该正方形位于新路由的中间，遮挡了原始路由。</li><li>通过点击图像或使用设备的返回上一个路由手势返回上一个路由。</li><li>你可以使用timeDilation属性进一步减慢过渡。</li></ul><h3 id="Photo类"><a href="#Photo类" class="headerlink" title="Photo类"></a>Photo类</h3><p>Photo类构建保存图像的widget树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Photo extends StatelessWidget &#123;</span><br><span class="line">  Photo(&#123; Key key, this.photo, this.color, this.onTap &#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  final String photo;</span><br><span class="line">  final Color color;</span><br><span class="line">  final VoidCallback onTap;</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Material(</span><br><span class="line">      // Slightly opaque color appears where the image has transparency.</span><br><span class="line">      color: Theme.of(context).primaryColor.withOpacity(0.25),</span><br><span class="line">      child: InkWell(</span><br><span class="line">        onTap: onTap,</span><br><span class="line">        child: Image.asset(</span><br><span class="line">            photo,</span><br><span class="line">            fit: BoxFit.contain,</span><br><span class="line">          )</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键信息：</p><ul><li>Inkwell捕获轻击手势。调用函数将onTap()函数传递给Photo的构造函数。</li><li>在飞行过程中，InkWell在它的第一个<code>Material</code>祖先上散开。</li><li><code>Material</code>”widget具有略微不透明的颜色，因此图像的透明部分将使用颜色进行渲染。这确保了即使对于具有透明度的图像也容易看到圆到方的过渡。</li><li>Photo类在其widget树中不包含Hero。为了使动画起作用，<code>hero</code>包装了RadialExpansion widget。</li></ul><h3 id="RadialExpansion类"><a href="#RadialExpansion类" class="headerlink" title="RadialExpansion类"></a>RadialExpansion类</h3><p>RadialExpansion widget 是演示的核心，它构建了在过渡期间剪切图像的widget树。剪裁的形状来自圆形剪辑(在飞行期间生长)与矩形剪辑(整个过程中保持恒定大小)的交叉。</p><p>为此，它构建了以下widget树：</p><p><img src="https://flutter.dev/assets/ui/animations/radial-expansion-class-057f907d3b6ff22ac2c857a2e739436dd36eedd3ef0ed9dd73839d93d026f0d7.png" alt></p><p>这里是代码:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RadialExpansion</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  RadialExpansion(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.maxRadius,</span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">  &#125;) : clipRectSize = <span class="number">2.0</span> * (maxRadius / math.sqrt2),</span><br><span class="line">       <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> maxRadius;</span><br><span class="line">  <span class="keyword">final</span> clipRectSize;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) </span><br><span class="line">    <span class="keyword">return</span> ClipOval(</span><br><span class="line">      child: Center(</span><br><span class="line">        child: SizedBox(</span><br><span class="line">          width: clipRectSize,</span><br><span class="line">          height: clipRectSize,</span><br><span class="line">          child: ClipRect(</span><br><span class="line">            child: child,  <span class="comment">// Photo</span></span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键信息：</p><ul><li><code>hero</code>包装了RadialExpansion widget。</li><li>当<code>hero</code>飞行时，它的大小会发生变化，并且由于它限制了孩子的大小，因此<code>RadialExpansion</code> widget会更改大小以匹配。</li><li><code>RadialExpansion</code>动画由两个重叠的剪辑创建。</li><li>该示例使用<code>MaterialRectCenterArcTween</code>定义补间插值。<code>hero</code>动画的默认飞行路径使用<code>hero</code>的角插入补间。此方法会影响径向变换期间<code>hero</code>的纵横比，因此新的飞行路由使用<code>MaterialRectCenterArcTween</code>使用每个<code>hero</code>的中心点插补补间。</li></ul><p>这是代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> RectTween _createRectTween(Rect begin, Rect end) &#123;</span><br><span class="line">  <span class="keyword">return</span> MaterialRectCenterArcTween(begin: begin, end: end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hero</code>的飞行路径仍遵循弧线，但图像的纵横比保持不变。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Animations </tag>
            
            <tag> navigation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)在路由上设置widget动画</title>
      <link href="/2019/04/24/Flutter/development/ui/navigation/Animating%20a%20Widget%20across%20screens/"/>
      <url>/2019/04/24/Flutter/development/ui/navigation/Animating%20a%20Widget%20across%20screens/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/cookbook/navigation/hero-animations" target="_blank" rel="noopener">原文链接</a></p><p>在路由之间导航时，引导用户浏览我们的应用通常很有帮助。引导用户浏览应用程序的常用技巧是将Widget以动画的形式从一个路由到下一个路由。这创建了连接两个路由的视觉锚点。</p><p>我们如何使用Flutter将Widget以动画的形式从一个路由到下一个路由？使用<a href="https://api.flutter.dev/flutter/widgets/Hero-class.html" target="_blank" rel="noopener">Hero</a> widget！</p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>创建两个显示相同图像的路由</li><li>将<code>Hero</code> Widget添加到第一个路由</li><li>将<code>Hero</code> Widget添加到第二个路由</li></ol><h2 id="1-创建两个显示相同图像的路由"><a href="#1-创建两个显示相同图像的路由" class="headerlink" title="1.创建两个显示相同图像的路由"></a>1.创建两个显示相同图像的路由</h2><p>在此示例中，我们将在两个路由上显示相同的图像。 当用户点击图像时，我们希望将图像以动画的形式从一个路由到下一个路由。 现在，我们将创建视觉结构，并在接下来的步骤中处理动画！</p><p>注意：此示例基于<a href="https://flutter.dev/docs/cookbook/navigation/navigation-basics" target="_blank" rel="noopener">导航到新路由并返回</a>和<a href="https://flutter.dev/docs/cookbook/gestures/handling-taps" target="_blank" rel="noopener">处理点击事件</a>配方。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Main Screen'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: GestureDetector(</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          Navigator.push(context, MaterialPageRoute(builder: (_) &#123;</span><br><span class="line">            <span class="keyword">return</span> DetailScreen();</span><br><span class="line">          &#125;));</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Image.network(</span><br><span class="line">          <span class="string">'https://picsum.photos/250?image=9'</span>,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: GestureDetector(</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          Navigator.pop(context);</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Image.network(</span><br><span class="line">            <span class="string">'https://picsum.photos/250?image=9'</span>,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-将Hero-Widget添加到第一个路由"><a href="#2-将Hero-Widget添加到第一个路由" class="headerlink" title="2.将Hero Widget添加到第一个路由"></a>2.将Hero Widget添加到第一个路由</h2><p>为了将两个屏幕与动画连接在一起，我们需要将Image Widget包装在Hero Widget的两个路由上。 Hero Widget需要两个参数：</p><ol><li>tag：标识Hero的对象。两个路由上必须相同。</li><li>child：我们想要在路由之间实现动画效果的widget。</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hero(</span><br><span class="line">  tag: <span class="string">'imageHero'</span>,</span><br><span class="line">  child: Image.network(</span><br><span class="line">    <span class="string">'https://picsum.photos/250?image=9'</span>,</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>3.将Hero Widget添加到第二个路由</p><p>要完成与第一个路由的连接，我们需要使用Hero Widget将Image包装在第二个路由上！它必须使用与第一个路由相同的标签。</p><p>将Hero Widget应用到第二个路由后，路由之间的动画将起作用！</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hero(</span><br><span class="line">  tag: <span class="string">'imageHero'</span>,</span><br><span class="line">  child: Image.network(</span><br><span class="line">    <span class="string">'https://picsum.photos/250?image=9'</span>,</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意：此代码与我们在第一个路由上的代码相同！通常，您可以创建可重用的Widget而不是重复代码，但是对于此示例，我们将复制代码以用于演示目的。</p><p>完整例子</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(HeroApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Transition Demo'</span>,</span><br><span class="line">      home: MainScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Main Screen'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: GestureDetector(</span><br><span class="line">        child: Hero(</span><br><span class="line">          tag: <span class="string">'imageHero'</span>,</span><br><span class="line">          child: Image.network(</span><br><span class="line">            <span class="string">'https://picsum.photos/250?image=9'</span>,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          Navigator.push(context, MaterialPageRoute(builder: (_) &#123;</span><br><span class="line">            <span class="keyword">return</span> DetailScreen();</span><br><span class="line">          &#125;));</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: GestureDetector(</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Hero(</span><br><span class="line">            tag: <span class="string">'imageHero'</span>,</span><br><span class="line">            child: Image.network(</span><br><span class="line">              <span class="string">'https://picsum.photos/250?image=9'</span>,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          Navigator.pop(context);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://flutter.dev/images/cookbook/hero.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Animations </tag>
            
            <tag> navigation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)发送数据到新路由</title>
      <link href="/2019/04/24/Flutter/development/ui/navigation/Send%20data%20to%20a%20new%20screen/"/>
      <url>/2019/04/24/Flutter/development/ui/navigation/Send%20data%20to%20a%20new%20screen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/cookbook/navigation/passing-data" target="_blank" rel="noopener">原文地址</a></p><p>通常，我们不仅要导航到新路由，还要将一些数据传递到路由。例如，我们经常希望传递有关我们所使用的项目的信息。</p><p>请记住：多个路由仅仅是多个Widget。在这个例子中，我们将创建一个Todos列表。当点击待办事项时，我们将导航到显示有关待办事项信息的新路由（widget）。</p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>定义Todo类</li><li>显示待办事项列表</li><li>创建一个详细信息路由，可以显示有关待办事项的信息</li><li>导航并将数据传递到详细信息路由</li></ol><h2 id="1-定义Todo类"><a href="#1-定义Todo类" class="headerlink" title="1.定义Todo类"></a>1.定义Todo类</h2><p>首先，我们需要一种简单的方式来表示Todo。对于此示例，我们将创建一个包含两个数据的类：标题和描述。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> description;</span><br><span class="line"></span><br><span class="line">  Todo(<span class="keyword">this</span>.title, <span class="keyword">this</span>.description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-创建待办事项列表"><a href="#2-创建待办事项列表" class="headerlink" title="2.创建待办事项列表"></a>2.创建待办事项列表</h2><p>其次，我们要显示Todo列表。在这个例子中，我们将生成20个待办事项并使用ListView显示它们。有关使用列表的更多信息，请参阅<a href="https://flutter.dev/docs/cookbook/lists/basic-list/" target="_blank" rel="noopener">基础列表</a>配方。</p><h3 id="生成Todo列表"><a href="#生成Todo列表" class="headerlink" title="生成Todo列表"></a>生成Todo列表</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> todos = <span class="built_in">List</span>&lt;Todo&gt;.generate(</span><br><span class="line">  <span class="number">20</span>,</span><br><span class="line">  (i) =&gt; Todo(</span><br><span class="line">        <span class="string">'Todo <span class="subst">$i</span>'</span>,</span><br><span class="line">        <span class="string">'A description of what needs to be done for Todo <span class="subst">$i</span>'</span>,</span><br><span class="line">      ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="使用ListView显示待办事项列表"><a href="#使用ListView显示待办事项列表" class="headerlink" title="使用ListView显示待办事项列表"></a>使用ListView显示待办事项列表</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">  itemCount: todos.length,</span><br><span class="line">  itemBuilder: (context, index) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListTile(</span><br><span class="line">      title: Text(todos[index].title),</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>到现在为止还挺好。我们将生成20个Todos并在ListView中显示它们！</p><h2 id="3-创建一个详细信息屏幕，可以显示有关待办事项的信息"><a href="#3-创建一个详细信息屏幕，可以显示有关待办事项的信息" class="headerlink" title="3.创建一个详细信息屏幕，可以显示有关待办事项的信息"></a>3.创建一个详细信息屏幕，可以显示有关待办事项的信息</h2><p>现在，我们将创建第二个路由。路由标题将包含待办事项的标题，路由正文将显示说明。</p><p>由于它是一个普通的StatelessWidget，我们只需要创建Screen的用户传入Todo！然后，我们将使用给定的Todo构建UI。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Declare a field that holds the Todo</span></span><br><span class="line">  <span class="keyword">final</span> Todo todo;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In the constructor, require a Todo</span></span><br><span class="line">  DetailScreen(&#123;Key key, <span class="meta">@required</span> <span class="keyword">this</span>.todo&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// Use the Todo to create our UI</span></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(todo.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Padding(</span><br><span class="line">        padding: EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">        child: Text(todo.description),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-导航并将数据传递到详细信息路由"><a href="#4-导航并将数据传递到详细信息路由" class="headerlink" title="4.导航并将数据传递到详细信息路由"></a>4.导航并将数据传递到详细信息路由</h2><p>随着我们的<code>DetailScreen</code>到位，我们已准备好执行导航！在我们的例子中，当用户点击列表中的Todo时，我们将要导航到<code>DetailScreen</code>。当我们这样做时，我们也想将Todo传递给DetailScreen。</p><p>为此，我们将为ListTile Widget编写onTap回调。在我们的onTap回调中，我们将再次使用Navigator.push方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">  itemCount: todos.length,</span><br><span class="line">  itemBuilder: (context, index) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListTile(</span><br><span class="line">      title: Text(todos[index].title),</span><br><span class="line">      <span class="comment">// When a user taps on the ListTile, navigate to the DetailScreen.</span></span><br><span class="line">      <span class="comment">// Notice that we're not only creating a DetailScreen, we're</span></span><br><span class="line">      <span class="comment">// also passing the current todo to it!</span></span><br><span class="line">      onTap: () &#123;</span><br><span class="line">        Navigator.push(</span><br><span class="line">          context,</span><br><span class="line">          MaterialPageRoute(</span><br><span class="line">            builder: (context) =&gt; DetailScreen(todo: todos[index]),</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/foundation.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> description;</span><br><span class="line"></span><br><span class="line">  Todo(<span class="keyword">this</span>.title, <span class="keyword">this</span>.description);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(</span><br><span class="line">    title: <span class="string">'Passing Data'</span>,</span><br><span class="line">    home: TodosScreen(</span><br><span class="line">      todos: <span class="built_in">List</span>.generate(</span><br><span class="line">        <span class="number">20</span>,</span><br><span class="line">        (i) =&gt; Todo(</span><br><span class="line">              <span class="string">'Todo <span class="subst">$i</span>'</span>,</span><br><span class="line">              <span class="string">'A description of what needs to be done for Todo <span class="subst">$i</span>'</span>,</span><br><span class="line">            ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodosScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Todo&gt; todos;</span><br><span class="line"></span><br><span class="line">  TodosScreen(&#123;Key key, <span class="meta">@required</span> <span class="keyword">this</span>.todos&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Todos'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: ListView.builder(</span><br><span class="line">        itemCount: todos.length,</span><br><span class="line">        itemBuilder: (context, index) &#123;</span><br><span class="line">          <span class="keyword">return</span> ListTile(</span><br><span class="line">            title: Text(todos[index].title),</span><br><span class="line">            <span class="comment">// When a user taps on the ListTile, navigate to the DetailScreen.</span></span><br><span class="line">            <span class="comment">// Notice that we're not only creating a DetailScreen, we're</span></span><br><span class="line">            <span class="comment">// also passing the current todo through to it!</span></span><br><span class="line">            onTap: () &#123;</span><br><span class="line">              Navigator.push(</span><br><span class="line">                context,</span><br><span class="line">                MaterialPageRoute(</span><br><span class="line">                  builder: (context) =&gt; DetailScreen(todo: todos[index]),</span><br><span class="line">                ),</span><br><span class="line">              );</span><br><span class="line">            &#125;,</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Declare a field that holds the Todo</span></span><br><span class="line">  <span class="keyword">final</span> Todo todo;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In the constructor, require a Todo</span></span><br><span class="line">  DetailScreen(&#123;Key key, <span class="meta">@required</span> <span class="keyword">this</span>.todo&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// Use the Todo to create our UI</span></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(todo.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Padding(</span><br><span class="line">        padding: EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">        child: Text(todo.description),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://flutter.dev/images/cookbook/passing-data.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> navigation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)从路由返回数据</title>
      <link href="/2019/04/24/Flutter/development/ui/navigation/Return%20data%20from%20a%20screen/"/>
      <url>/2019/04/24/Flutter/development/ui/navigation/Return%20data%20from%20a%20screen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/cookbook/navigation/returning-data" target="_blank" rel="noopener">原文链接</a></p><p>在某些情况下，我们可能希望从新路由返回数据。例如，假设我们<code>push</code>一个向用户提供两个选项的新路由。当用户点击选项时，我们想要通知我们的第一个路由用户的选择，以便它可以对该信息采取行动！</p><p>我们怎样才能做到这一点？使用<a href="https://api.flutter.dev/flutter/widgets/Navigator/pop.html" target="_blank" rel="noopener">Navigator.pop</a>！</p><a id="more"></a><h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><ol><li>定义主路由</li><li>添加一个启动选择路由的按钮</li><li>使用两个按钮显示选择路由</li><li>点击按钮时，关闭选择路由</li><li>在主屏幕上用snackbar显示选择的那项</li></ol><h2 id="1-定义主屏幕"><a href="#1-定义主屏幕" class="headerlink" title="1.定义主屏幕"></a>1.定义主屏幕</h2><p>主路由将显示一个按钮。点击时，它将启动选择路由！</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Returning Data Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// We'll create the SelectionButton Widget in the next step</span></span><br><span class="line">      body: Center(child: SelectionButton()),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-添加一个启动选择路由的按钮"><a href="#2-添加一个启动选择路由的按钮" class="headerlink" title="2.添加一个启动选择路由的按钮"></a>2.添加一个启动选择路由的按钮</h2><p>现在，我们将创建SelectionButton。我们的选择按钮将：</p><ol><li>点击后启动<code>SelectionScreen</code></li><li>等待<code>SelectionScreen</code>返回结果</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      onPressed: () &#123;</span><br><span class="line">        _navigateAndDisplaySelection(context);</span><br><span class="line">      &#125;,</span><br><span class="line">      child: Text(<span class="string">'Pick an option, any option!'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A method that launches the SelectionScreen and awaits the result from</span></span><br><span class="line">  <span class="comment">// Navigator.pop</span></span><br><span class="line">  _navigateAndDisplaySelection(BuildContext context) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// Navigator.push returns a Future that will complete after we call</span></span><br><span class="line">    <span class="comment">// Navigator.pop on the Selection Screen!</span></span><br><span class="line">    <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">      context,</span><br><span class="line">      <span class="comment">// We'll create the SelectionScreen in the next step!</span></span><br><span class="line">      MaterialPageRoute(builder: (context) =&gt; SelectionScreen()),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-使用两个按钮显示选择路由"><a href="#3-使用两个按钮显示选择路由" class="headerlink" title="3.使用两个按钮显示选择路由"></a>3.使用两个按钮显示选择路由</h2><p>现在，我们需要建立一个选择路由！它将包含两个按钮。当用户点击按钮时，它应该关闭选择路由，并让主路由知道点击了哪个按钮！</p><p>现在，我们将定义UI，并确定如何在下一步中返回数据。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Pick an option'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">              child: RaisedButton(</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  <span class="comment">// Pop here with "Yep"...</span></span><br><span class="line">                &#125;,</span><br><span class="line">                child: Text(<span class="string">'Yep!'</span>),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">              child: RaisedButton(</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  <span class="comment">// Pop here with "Nope"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                child: Text(<span class="string">'Nope.'</span>),</span><br><span class="line">              ),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-点击按钮时，关闭选择路由"><a href="#4-点击按钮时，关闭选择路由" class="headerlink" title="4.点击按钮时，关闭选择路由"></a>4.点击按钮时，关闭选择路由</h2><p>现在，我们要修改两个按钮的onPressed回调！为了将数据返回到第一个路由，我们需要使用<a href="https://api.flutter.dev/flutter/widgets/Navigator/pop.html" target="_blank" rel="noopener">Navigator.pop</a>方法。</p><p><code>Navigator.pop</code>接收一个名为result的可选的第二个参数。如果我们提供结果，它将在SelectionButton中返回到<code>Future</code>中！</p><h2 id="是的按钮"><a href="#是的按钮" class="headerlink" title="是的按钮"></a>是的按钮</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    <span class="comment">// Our Yep button will return "Yep!" as the result</span></span><br><span class="line">    Navigator.pop(context, <span class="string">'Yep!'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">'Yep!'</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="否的按钮"><a href="#否的按钮" class="headerlink" title="否的按钮"></a>否的按钮</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    <span class="comment">// Our Nope button will return "Nope!" as the result</span></span><br><span class="line">    Navigator.pop(context, <span class="string">'Nope!'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">'Nope!'</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="5-在主路由用snarkback显示选择的那项"><a href="#5-在主路由用snarkback显示选择的那项" class="headerlink" title="5.在主路由用snarkback显示选择的那项"></a>5.在主路由用snarkback显示选择的那项</h2><p>既然我们正在启动选择路由并等待结果，我们将要对所返回的信息做些什么！</p><p>在这种情况下，我们将显示一个显示结果的Snackbar。为此，我们将在SelectionButton中修改_navigateAndDisplaySelection方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_navigateAndDisplaySelection(BuildContext context) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">    context,</span><br><span class="line">    MaterialPageRoute(builder: (context) =&gt; SelectionScreen()),</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// After the Selection Screen returns a result, hide any previous snackbars</span></span><br><span class="line">  <span class="comment">// and show the new result!</span></span><br><span class="line">  Scaffold.of(context)</span><br><span class="line">    ..removeCurrentSnackBar()</span><br><span class="line">    ..showSnackBar(SnackBar(content: Text(<span class="string">"<span class="subst">$result</span>"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(</span><br><span class="line">    title: <span class="string">'Returning Data'</span>,</span><br><span class="line">    home: HomeScreen(),</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Returning Data Demo'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(child: SelectionButton()),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      onPressed: () &#123;</span><br><span class="line">        _navigateAndDisplaySelection(context);</span><br><span class="line">      &#125;,</span><br><span class="line">      child: Text(<span class="string">'Pick an option, any option!'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A method that launches the SelectionScreen and awaits the result from</span></span><br><span class="line">  <span class="comment">// Navigator.pop!</span></span><br><span class="line">  _navigateAndDisplaySelection(BuildContext context) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// Navigator.push returns a Future that will complete after we call</span></span><br><span class="line">    <span class="comment">// Navigator.pop on the Selection Screen!</span></span><br><span class="line">    <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">      context,</span><br><span class="line">      MaterialPageRoute(builder: (context) =&gt; SelectionScreen()),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// After the Selection Screen returns a result, hide any previous snackbars</span></span><br><span class="line">    <span class="comment">// and show the new result!</span></span><br><span class="line">    Scaffold.of(context)</span><br><span class="line">      ..removeCurrentSnackBar()</span><br><span class="line">      ..showSnackBar(SnackBar(content: Text(<span class="string">"<span class="subst">$result</span>"</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Pick an option'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">              child: RaisedButton(</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  <span class="comment">// Close the screen and return "Yep!" as the result</span></span><br><span class="line">                  Navigator.pop(context, <span class="string">'Yep!'</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                child: Text(<span class="string">'Yep!'</span>),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">              child: RaisedButton(</span><br><span class="line">                onPressed: () &#123;</span><br><span class="line">                  <span class="comment">// Close the screen and return "Nope!" as the result</span></span><br><span class="line">                  Navigator.pop(context, <span class="string">'Nope.'</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                child: Text(<span class="string">'Nope.'</span>),</span><br><span class="line">              ),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://flutter.dev/images/cookbook/returning-data.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> navigation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)使用命名过的路由进行导航</title>
      <link href="/2019/04/24/Flutter/development/ui/navigation/Navigate%20with%20named%20routes/"/>
      <url>/2019/04/24/Flutter/development/ui/navigation/Navigate%20with%20named%20routes/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/cookbook/navigation/named-routes" target="_blank" rel="noopener">原文链接</a></p><p>在导航到导航到一个新页面和返回的方法中，我们学习了如何通过创建新路由并将其<code>push</code>导航器来导航到新路由。</p><p>但是，如果我们需要在应用程序的许多部分导航到同一路由，这可能会导致代码重复。 在这些情况下，定义“命名过的路由”，并使用“命名过的路由“进行导航，是非常方便的。</p><p>要使用“命名过的路由”，我们可以使用Navigator.pushNamed函数。 此示例将复制原始功能，演示如何使用“命名过的路由”。</p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>创建两个路由</li><li>定义路由表(routes)</li><li>使用Navigator.pushNamed导航到第二个路由</li><li>使用Navigator.pop返回第一个路由</li></ol><h2 id="1-创建两个路由"><a href="#1-创建两个路由" class="headerlink" title="1.创建两个路由"></a>1.创建两个路由</h2><p>首先，我们需要使用两个路由。 第一个路由将包含一个导航到第二个路由的按钮。 第二个路由将包含一个导航回第一个路由的按钮。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'First Screen'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          child: Text(<span class="string">'Launch screen'</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="comment">// Navigate to second screen when tapped!</span></span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"Second Screen"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="comment">// Navigate back to first screen when tapped!</span></span><br><span class="line">          &#125;,</span><br><span class="line">          child: Text(<span class="string">'Go back!'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-定义路由"><a href="#2-定义路由" class="headerlink" title="2.定义路由"></a>2.定义路由</h2><p>接下来，我们需要通过为<code>MaterialAp</code>p构造函数提供其他属性来定义我们的路由：<code>initialRoute</code>和<code>routes</code>它们自己。</p><p><code>initialRoute</code>属性定义了应用程序应该从哪个路由开始。<code>routes</code>属性定义可用的命名过的路由以及导航到这些路由时应构建的widget。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  <span class="comment">// Start the app with the "/" named route. In our case, the app will start</span></span><br><span class="line">  <span class="comment">// on the FirstScreen Widget</span></span><br><span class="line">  initialRoute: <span class="string">'/'</span>,</span><br><span class="line">  routes: &#123;</span><br><span class="line">    <span class="comment">// When we navigate to the "/" route, build the FirstScreen Widget</span></span><br><span class="line">    <span class="string">'/'</span>: (context) =&gt; FirstScreen(),</span><br><span class="line">    <span class="comment">// When we navigate to the "/second" route, build the SecondScreen Widget</span></span><br><span class="line">    <span class="string">'/second'</span>: (context) =&gt; SecondScreen(),</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意：使用<code>initialRoute</code>时，请确保未定义<code>home</code>属性。</p><h2 id="3-导航到第二个路由"><a href="#3-导航到第二个路由" class="headerlink" title="3.导航到第二个路由"></a>3.导航到第二个路由</h2><p>通过我们的widget和路由，我们可以开始导航！在这种情况下，我们将使用Navigator.pushNamed函数。这告诉Flutter构建路由表中定义的Widget并启动路由。</p><p>在我们的FirstScreen widget 的build方法中，我们将修改<code>onPressed</code>回调：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Within the `FirstScreen` Widget</span></span><br><span class="line">onPressed: () &#123;</span><br><span class="line">  <span class="comment">// Navigate to the second screen using a named route</span></span><br><span class="line">  Navigator.pushNamed(context, <span class="string">'/second'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-返回第一个路由"><a href="#4-返回第一个路由" class="headerlink" title="4.返回第一个路由"></a>4.返回第一个路由</h2><p>为了导航回第一页，我们可以使用Navigator.pop函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Within the SecondScreen Widget</span></span><br><span class="line">onPressed: () &#123;</span><br><span class="line">  <span class="comment">// Navigate back to the first screen by popping the current route</span></span><br><span class="line">  <span class="comment">// off the stack</span></span><br><span class="line">  Navigator.pop(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(</span><br><span class="line">    title: <span class="string">'Named Routes Demo'</span>,</span><br><span class="line">    <span class="comment">// Start the app with the "/" named route. In our case, the app will start</span></span><br><span class="line">    <span class="comment">// on the FirstScreen Widget</span></span><br><span class="line">    initialRoute: <span class="string">'/'</span>,</span><br><span class="line">    routes: &#123;</span><br><span class="line">      <span class="comment">// When we navigate to the "/" route, build the FirstScreen Widget</span></span><br><span class="line">      <span class="string">'/'</span>: (context) =&gt; FirstScreen(),</span><br><span class="line">      <span class="comment">// When we navigate to the "/second" route, build the SecondScreen Widget</span></span><br><span class="line">      <span class="string">'/second'</span>: (context) =&gt; SecondScreen(),</span><br><span class="line">    &#125;,</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'First Screen'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          child: Text(<span class="string">'Launch screen'</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="comment">// Navigate to the second screen using a named route</span></span><br><span class="line">            Navigator.pushNamed(context, <span class="string">'/second'</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"Second Screen"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="comment">// Navigate back to the first screen by popping the current route</span></span><br><span class="line">            <span class="comment">// off the stack</span></span><br><span class="line">            Navigator.pop(context);</span><br><span class="line">          &#125;,</span><br><span class="line">          child: Text(<span class="string">'Go back!'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://flutter.dev/images/cookbook/navigation-basics.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> navigation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)传递参数到命名过的路由</title>
      <link href="/2019/04/24/Flutter/development/ui/navigation/Pass%20arguments%20to%20a%20named%20route/"/>
      <url>/2019/04/24/Flutter/development/ui/navigation/Pass%20arguments%20to%20a%20named%20route/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/cookbook/navigation/navigate-with-arguments" target="_blank" rel="noopener">原文链接</a></p><p>导航器提供了使用公共标识符从应用程序的任何部分导航到命名过的路由的功能。在某些情况下，你可能还需要将参数传递给命名过的路由。例如，你可能希望导航到<code>/user</code>路由并将有关用户的信息传递给该路由。</p><p>在Flutter中，你可以通过为Navigator.pushNamed方法提供其他参数来完成此任务。你可以使用ModalRoute.of方法或在提供给MaterialApp或CupertinoApp构造函数的onGenerateRoute函数内提取参数。</p><p>此配方演示了如何将参数传递给命名过的路由并使用<code>ModelRoute.of</code>和<code>onGenerateRoute</code>读取参数。</p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>定义你需要传递的参数</li><li>创建一个提取参数的widget</li><li>在路由表中注册widget</li><li>导航到widget</li></ol><h2 id="1-定义你需要传递的参数"><a href="#1-定义你需要传递的参数" class="headerlink" title="1. 定义你需要传递的参数"></a>1. 定义你需要传递的参数</h2><p>首先，定义传递给新路由所需的参数。在此示例中，传递两个数据：路由标题以及一个消息。</p><p>要传递两个数据，请创建一个存储此信息的类。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// You can pass any object to the arguments parameter. In this example, create a</span></span><br><span class="line"><span class="comment">// class that contains both a customizable title and message.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScreenArguments</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> message;</span><br><span class="line"></span><br><span class="line">  ScreenArguments(<span class="keyword">this</span>.title, <span class="keyword">this</span>.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-创建一个提取参数的widget"><a href="#2-创建一个提取参数的widget" class="headerlink" title="2. 创建一个提取参数的widget"></a>2. 创建一个提取参数的widget</h2><p>接下来，创建一个widget，从ScreenArguments中提取并显示标题和消息。要访问ScreenArguments，请使用ModalRoute.of方法。此方法返回带有参数的当前路由。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Widget that extracts the necessary arguments from the ModalRoute.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtractArgumentsScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> routeName = <span class="string">'/extractArguments'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// Extract the arguments from the current ModalRoute settings and cast</span></span><br><span class="line">    <span class="comment">// them as ScreenArguments.</span></span><br><span class="line">    <span class="keyword">final</span> ScreenArguments args = ModalRoute.of(context).settings.arguments;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(args.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(args.message),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-在路由表中注册widget"><a href="#3-在路由表中注册widget" class="headerlink" title="3.在路由表中注册widget"></a>3.在路由表中注册widget</h2><p>接下来，在提供给<code>MaterialApp</code> Widget的路径中添加一个条目。路由根据路由名称定义应创建哪个widget。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  routes: &#123;</span><br><span class="line">    ExtractArgumentsScreen.routeName: (context) =&gt; ExtractArgumentsScreen(),</span><br><span class="line">  &#125;,     </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="4-导航到widget"><a href="#4-导航到widget" class="headerlink" title="4.导航到widget"></a>4.导航到widget</h2><p>最后，当用户使用Navigator.pushNamed点击按钮时，导航到ExtractArgumentsScreen。通过arguments属性为路由提供参数。 ExtractArgumentsScreen从这些参数中提取标题和消息。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A button that navigates to a named route that. The named route</span></span><br><span class="line"><span class="comment">// extracts the arguments by itself.</span></span><br><span class="line">RaisedButton(</span><br><span class="line">  child: Text(<span class="string">"Navigate to screen that extracts arguments"</span>),</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    <span class="comment">// When the user taps the button, navigate to the specific rout</span></span><br><span class="line">    <span class="comment">// and provide the arguments as part of the RouteSettings.</span></span><br><span class="line">    Navigator.pushNamed(</span><br><span class="line">      context,</span><br><span class="line">      ExtractArgumentsScreen.routeName,</span><br><span class="line">      arguments: ScreenArguments(</span><br><span class="line">        <span class="string">'Extract Arguments Screen'</span>,</span><br><span class="line">        <span class="string">'This message is extracted in the build method.'</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="或者，使用onGenerateRoute提取参数"><a href="#或者，使用onGenerateRoute提取参数" class="headerlink" title="或者，使用onGenerateRoute提取参数"></a>或者，使用onGenerateRoute提取参数</h2><p>你也可以在onGenerateRoute函数中提取参数并将它们传递给widget，而不是直接在widget中提取参数。</p><p>onGenerateRoute函数根据给定的<code>RouteSettings</code>创建正确的路由。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  <span class="comment">// Provide a function to handle named routes. Use this function to</span></span><br><span class="line">  <span class="comment">// identify the named route being pushed and create the correct</span></span><br><span class="line">  <span class="comment">// Screen.</span></span><br><span class="line">  onGenerateRoute: (settings) &#123;</span><br><span class="line">    <span class="comment">// If you push the PassArguments route</span></span><br><span class="line">    <span class="keyword">if</span> (settings.name == PassArgumentsScreen.routeName) &#123;</span><br><span class="line">      <span class="comment">// Cast the arguments to the correct type: ScreenArguments.</span></span><br><span class="line">      <span class="keyword">final</span> ScreenArguments args = settings.arguments;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Then, extract the required data from the arguments and</span></span><br><span class="line">      <span class="comment">// pass the data to the correct screen.</span></span><br><span class="line">      <span class="keyword">return</span> MaterialPageRoute(</span><br><span class="line">        builder: (context) &#123;</span><br><span class="line">          <span class="keyword">return</span> PassArgumentsScreen(</span><br><span class="line">            title: args.title,</span><br><span class="line">            message: args.message,</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      <span class="comment">// Provide a function to handle named routes. Use this function to</span></span><br><span class="line">      <span class="comment">// identify the named route being pushed and create the correct</span></span><br><span class="line">      <span class="comment">// Screen.</span></span><br><span class="line">      onGenerateRoute: (settings) &#123;</span><br><span class="line">        <span class="comment">// If you push the PassArguments route</span></span><br><span class="line">        <span class="keyword">if</span> (settings.name == PassArgumentsScreen.routeName) &#123;</span><br><span class="line">          <span class="comment">// Cast the arguments to the correct type: ScreenArguments.</span></span><br><span class="line">          <span class="keyword">final</span> ScreenArguments args = settings.arguments;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Then, extract the required data from the arguments and</span></span><br><span class="line">          <span class="comment">// pass the data to the correct screen.</span></span><br><span class="line">          <span class="keyword">return</span> MaterialPageRoute(</span><br><span class="line">            builder: (context) &#123;</span><br><span class="line">              <span class="keyword">return</span> PassArgumentsScreen(</span><br><span class="line">                title: args.title,</span><br><span class="line">                message: args.message,</span><br><span class="line">              );</span><br><span class="line">            &#125;,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      title: <span class="string">'Navigation with Arguments'</span>,</span><br><span class="line">      home: HomeScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Home Screen'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="comment">// A button that navigates to a named route that. The named route</span></span><br><span class="line">            <span class="comment">// extracts the arguments by itself.</span></span><br><span class="line">            RaisedButton(</span><br><span class="line">              child: Text(<span class="string">"Navigate to screen that extracts arguments"</span>),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                <span class="comment">// When the user taps the button, navigate to the specific route</span></span><br><span class="line">                <span class="comment">// and provide the arguments as part of the RouteSettings.</span></span><br><span class="line">                Navigator.push(</span><br><span class="line">                  context,</span><br><span class="line">                  MaterialPageRoute(</span><br><span class="line">                    builder: (context) =&gt; ExtractArgumentsScreen(),</span><br><span class="line">                    <span class="comment">// Pass the arguments as part of the RouteSettings. The</span></span><br><span class="line">                    <span class="comment">// ExtractArgumentScreen reads the arguments from these</span></span><br><span class="line">                    <span class="comment">// settings.</span></span><br><span class="line">                    settings: RouteSettings(</span><br><span class="line">                      arguments: ScreenArguments(</span><br><span class="line">                        <span class="string">'Extract Arguments Screen'</span>,</span><br><span class="line">                        <span class="string">'This message is extracted in the build method.'</span>,</span><br><span class="line">                      ),</span><br><span class="line">                    ),</span><br><span class="line">                  ),</span><br><span class="line">                );</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">            <span class="comment">// A button that navigates to a named route. For this route, extract</span></span><br><span class="line">            <span class="comment">// the arguments in the onGenerateRoute function and pass them</span></span><br><span class="line">            <span class="comment">// to the screen.</span></span><br><span class="line">            RaisedButton(</span><br><span class="line">              child: Text(<span class="string">"Navigate to a named that accepts arguments"</span>),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                <span class="comment">// When the user taps the button, navigate to a named route</span></span><br><span class="line">                <span class="comment">// and provide the arguments as an optional parameter.</span></span><br><span class="line">                Navigator.pushNamed(</span><br><span class="line">                  context,</span><br><span class="line">                  PassArgumentsScreen.routeName,</span><br><span class="line">                  arguments: ScreenArguments(</span><br><span class="line">                    <span class="string">'Accept Arguments Screen'</span>,</span><br><span class="line">                    <span class="string">'This message is extracted in the onGenerateRoute function.'</span>,</span><br><span class="line">                  ),</span><br><span class="line">                );</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Widget that extracts the necessary arguments from the ModalRoute.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtractArgumentsScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> routeName = <span class="string">'/extractArguments'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// Extract the arguments from the current ModalRoute settings and cast</span></span><br><span class="line">    <span class="comment">// them as ScreenArguments.</span></span><br><span class="line">    <span class="keyword">final</span> ScreenArguments args = ModalRoute.of(context).settings.arguments;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(args.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(args.message),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Widget that accepts the necessary arguments via the constructor.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassArgumentsScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> routeName = <span class="string">'/passArguments'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> message;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This Widget accepts the arguments as constructor parameters. It does not</span></span><br><span class="line">  <span class="comment">// extract the arguments from the ModalRoute.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The arguments are extracted by the onGenerateRoute function provided to the</span></span><br><span class="line">  <span class="comment">// MaterialApp widget.</span></span><br><span class="line">  <span class="keyword">const</span> PassArgumentsScreen(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.message,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(message),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can pass any object to the arguments parameter. In this example, create a</span></span><br><span class="line"><span class="comment">// class that contains both a customizable title and message.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScreenArguments</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> message;</span><br><span class="line"></span><br><span class="line">  ScreenArguments(<span class="keyword">this</span>.title, <span class="keyword">this</span>.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://flutter.dev/images/cookbook/navigate-with-arguments.gif" alt></p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> navigation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(转)导航到一个新页面和返回</title>
      <link href="/2019/04/24/Flutter/development/ui/navigation/Navigate%20to%20a%20new%20screen%20and%20back/"/>
      <url>/2019/04/24/Flutter/development/ui/navigation/Navigate%20to%20a%20new%20screen%20and%20back/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.cn/docs/cookbook/navigation/navigation-basics" target="_blank" rel="noopener">原文链接</a></p><p>我们通常会用“屏”来表示应用的不同页面（界面），比如，某个应用有一“屏”展示商品列表，当用户点击某个商品的图片，会跳到新的一“屏”展示商品的详细信息。</p><p>术语: 在 Flutter 中，屏 (screen) 和 页面 (page) 都叫做 路由 (route)， 在下文中统称为“路由 (route)”。</p><p>在 Android 开发中，Activity 相当于“路由” , 在 iOS 开发中，ViewController 相当于“路由”。 在 Flutter 中，“路由”也是一个 Widget。</p><p>怎么样从一个“路由”跳转到新的“路由“呢？你需要使用 <a href="https://api.flutter.dev/flutter/widgets/Navigator-class.html" target="_blank" rel="noopener">Navigator</a> 类。</p><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>下面来展示如何在两个路由间跳转，总共分三步：</p><ol><li><p>创建两个路由</p></li><li><p>用 Navigator.push() 跳转到第二个路由</p></li><li><p>用 Navigator.pop() 回退到第一个路由</p></li></ol><h2 id="1-创建两个路由"><a href="#1-创建两个路由" class="headerlink" title="1. 创建两个路由"></a>1. 创建两个路由</h2><p>首先，我们来创建两个路由。这是个最简单的例子，每个路由只包含一个按钮。 点击第一个路由上的按钮会跳转到第二个路由，点击第二个路由上的按钮，会回退到第一个路由。</p><p>首先来编写界面布局代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'First Route'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          child: Text(<span class="string">'Open route'</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="comment">// Navigate to second route when tapped.</span></span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"Second Route"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="comment">// Navigate back to first route when tapped.</span></span><br><span class="line">          &#125;,</span><br><span class="line">          child: Text(<span class="string">'Go back!'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-用-Navigator-push-跳转到第二个路由"><a href="#2-用-Navigator-push-跳转到第二个路由" class="headerlink" title="2.用 Navigator.push() 跳转到第二个路由"></a>2.用 Navigator.push() 跳转到第二个路由</h2><p>使用 Navigator.push()方法跳转到新的路由。 <code>push()</code> 方法会添加一个 <code>Route</code> 对象到导航器的堆栈上。 那么这个 <code>Route</code> 对象是从哪里来的呢？ 你可以自己实现一个，或者直接使用 <a href="https://api.flutter.dev/flutter/material/MaterialPageRoute-class.html" target="_blank" rel="noopener">MaterialPageRoute</a>类。 使用 <code>MaterialPageRoute</code> 是非常方便的，框架已经为我们实现了和平台原生类似的切换动画。</p><p>在 <code>FirstRoute</code> widget 的 <code>build()</code> 方法中，我们来修改 onPressed() 回调函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 FirstRoute widget (Within the `FirstRoute` widget)</span></span><br><span class="line">onPressed: () &#123;</span><br><span class="line">  Navigator.push(</span><br><span class="line">    context,</span><br><span class="line">    MaterialPageRoute(builder: (context) =&gt; SecondRoute()),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-用-Navigator-pop-回退到第一个路由"><a href="#3-用-Navigator-pop-回退到第一个路由" class="headerlink" title="3.用 Navigator.pop() 回退到第一个路由"></a>3.用 Navigator.pop() 回退到第一个路由</h2><p>怎么关闭第二个路由回退到第一个呢? 使用 <a href="https://api.flutter.dev/flutter/widgets/Navigator/pop.html" target="_blank" rel="noopener">Navigator.pop()</a> 方法，<code>pop()</code> 方法会从导航器堆栈上移除 <code>Route</code> 对象。</p><p>我们来修改 <code>SecondRoute</code> widget 的 <code>onPressed()</code> 回调函数，实现返回第一个路由的功能：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 SecondRoute widget (Within the SecondRoute widget)</span></span><br><span class="line">onPressed: () &#123;</span><br><span class="line">  Navigator.pop(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整的例子"><a href="#完整的例子" class="headerlink" title="完整的例子"></a>完整的例子</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(</span><br><span class="line">    title: <span class="string">'Navigation Basics'</span>,</span><br><span class="line">    home: FirstRoute(),</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'First Route'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          child: Text(<span class="string">'Open route'</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            Navigator.push(</span><br><span class="line">              context,</span><br><span class="line">              MaterialPageRoute(builder: (context) =&gt; SecondRoute()),</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"Second Route"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            Navigator.pop(context);</span><br><span class="line">          &#125;,</span><br><span class="line">          child: Text(<span class="string">'Go back!'</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://flutter.cn/images/cookbook/navigation-basics.gif" alt></p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> navigation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)动画教程</title>
      <link href="/2019/04/24/Flutter/development/ui/animations/Animations%20tutorial/"/>
      <url>/2019/04/24/Flutter/development/ui/animations/Animations%20tutorial/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/development/ui/animations/tutorial" target="_blank" rel="noopener">原文链接</a></p><p>你会学到什么</p><ul><li>如何使用动画库中的基础类将动画添加到widget。</li><li>AnimatedWidget和AnimatedBuilder的使用场景的比较。</li></ul><p>本教程将向您展示如何在Flutter中构建显式动画。在介绍了动画库中的一些基本概念、类和方法之后，这个教程会带你亲历5个动画相关的例子。这些示例建立在彼此之上，向你介绍了动画库的不同方面。</p><a id="more"></a><p>Flutter SDK还提供过渡动画，例如<a href="https://api.flutter.dev/flutter/widgets/FadeTransition-class.html" target="_blank" rel="noopener"><code>FadeTransition</code></a>，<a href="https://api.flutter.dev/flutter/widgets/SizeTransition-class.html" target="_blank" rel="noopener"><code>SizeTransition</code></a>和<a href="https://api.flutter.dev/flutter/widgets/SlideTransition-class.html" target="_blank" rel="noopener"><code>SlideTransition</code></a>。这些简单的动画是通过设置起点和终点来触发的。它们比这里所描述的显式动画更容易实现。</p><h2 id="基本的动画概念和类"><a href="#基本的动画概念和类" class="headerlink" title="基本的动画概念和类"></a>基本的动画概念和类</h2><p>重点是什么 </p><ul><li><code>Animation</code>，是Flutter动画库中的一个核心类，插入了那些用来指导动画的值。</li><li><code>Animation</code>对象知道动画的当前状态（例如，它是开始(started)、停止(stopped)还是向前(moving foreard)或反向(in reverse),但它不知道显示在屏幕上的任何事情。</li><li><code>AnimationController</code>管理着<code>Animation</code></li><li><code>CurvedAnimation</code>把过程定义为非线性曲线</li><li><code>Tween</code>在正在执行动画的对象所使用的数据范围之间插入值。例如，Tween可能会定义从红到蓝的一个插值，或者是从0到255的一个插值。</li><li>使用Listeners和StatusListeners来监控动画状态变化。</li></ul><p>Flutter中的动画系统是基于类型化的<code>Animation</code>对象的。widget可以通过读取它们当前的状态和监听它们的状态变化把这些动画合并进widget的build方法中，也可以使用动画作为更精心制作的动画的基础，并将这些精心制作的动画传递给其它widget。</p><h3 id="Animation-lt-double-gt"><a href="#Animation-lt-double-gt" class="headerlink" title="Animation&lt;double&gt;"></a>Animation&lt;double&gt;</h3><p>在Flutter中，Animation对象对屏幕上的东西一无所知。<code>Animation</code>是一个抽象类，它可以理解其当前值及其状态(已完成或已解除)。一种比较常用的动画类型是Animation&lt;double&gt;。</p><p>一个<code>Animation</code>对象会在一定持续时间内连续生成两个值之间的插值数。<code>Animation</code>对象的输出可以是线性，曲线，阶梯函数或你其它你能想出的任何其它映射。根据动画对象的控制方式，它可以反向运行，甚至可以在中间切换方向。</p><p>动画还可以插入除double之外的类型，例如<code>Animation\&lt;Color&gt;</code>或<code>Animation\&lt;Size&gt;</code>。</p><p><code>Animation</code>对象具有状态。其当前值始终在.value成员中访问。</p><p><code>Animation</code>对象对渲染或build()函数一无所知。</p><h3 id="Curved­Animation"><a href="#Curved­Animation" class="headerlink" title="Curved­Animation"></a>Curved­Animation</h3><p><a href="https://api.flutter.dev/flutter/animation/CurvedAnimation-class.html" target="_blank" rel="noopener">CurvedAnimation</a>将动画的过程定义为非线性曲线。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation = CurvedAnimation(parent: controller, curve: Curves.easeIn);</span><br></pre></td></tr></table></figure><p>注意：Curves类定义了许多常用曲线，或者你可以创建自己的曲线。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShakeCurve</span> <span class="keyword">extends</span> <span class="title">Curve</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">double</span> transform(<span class="built_in">double</span> t) =&gt; sin(t * pi * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CurvedAnimation</code>和<code>AnimationController</code>（会在下一节讲到）都是Animation&lt;double&gt;类型，因此你可以互换地传递它们。<code>CurvedAnimation</code>包装了它所修改的对象-你不必继承AnimationController来实现一条曲线。</p><h3 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h3><p><code>AnimationController</code>是一个特殊的Animation对象，只要硬件准备好新帧，它就会生成一个新值。默认情况下，<code>AnimationController</code>在给定的持续时间内线性生成从0.0到1.0的数字。例如，此代码创建一个Animation对象，但不启动它运行：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">controller =</span><br><span class="line">    AnimationController(duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>), vsync: <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p><code>AnimationController</code>派生自<code>Animation\&lt;double&gt;</code>，因此可以在需要<code>Animation</code>对象的任何地方使用它。但是，<code>AnimationController</code>还有其他方法来控制动画。例如，使用.forward()方法启动动画。数字的生成与屏幕刷新有关，因此通常每秒生成60个数字。生成每个数字后，每个Animation对象都会调用附加在它上面的监听对象。要为每个子项创建自定义显示列表，请参阅<a href="https://api.flutter.dev/flutter/widgets/RepaintBoundary-class.html" target="_blank" rel="noopener">RepaintBoundary</a>。</p><p>在创建<code>AnimationController</code>时，您将传递一个<code>vsync</code>参数。<code>vsync</code>的存在可防止屏幕外动画消耗不必要的资源。通过将<code>SingleTickerProviderStateMixin</code>添加到类定义，可以将有状态对象用作vsync。你可以在GitHub上的<a href="https://github.com/flutter/website/tree/master/examples/animation/animate1/lib/main.dart" target="_blank" rel="noopener">animate1</a>中看到这样的示例。</p><p>注意：在某些情况下，位置可能会超出<code>AnimationController</code>的0.0-1.0范围。例如，fling()函数允许你通过Force对象提供力度，力和位置。位置可以是任何值，因此可以在0.0到1.0范围之外。</p><p><code>CurvedAnimation</code>也可以超过0.0到1.0范围，即使<code>AnimationController</code>没有超过。根据所选的曲线，CurvedAnimation的输出可以具有比输入更宽的范围。例如，弹性曲线（如Curves.elasticIn）将明显超出或低于默认范围。</p><h3 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h3><p>默认情况下，<code>AnimationController</code>对象的范围为0.0到1.0。如果需要不同的范围或不同的数据类型，可以使用Tween将动画配置为插入到不同的范围或数据类型。例如，以下Tween的范围是从-200.0到为0.0：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tween = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">-200</span>, end: <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>Tween是一个只接受开始和结束的无状态对象。 Tween的唯一工作是定义从输入范围到输出范围的映射。输入范围通常为0.0到1.0，但这不是必需的。</p><p>Tween继承自Animatable&lt;T&gt;，而不是Animation<t>。像Animation一样,Animatable不是一定要输出double。例如，ColorTween具体说明两种颜色之间的发展。</t></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colorTween = ColorTween(begin: Colors.transparent, end: Colors.black54);</span><br></pre></td></tr></table></figure><p><code>Tween</code>对象不存储任何状态。相反，它提供了evaluate（Animation&lt;double&gt; animation）方法，该方法将映射函数应用于动画的当前值。可以在.value方法中找到<code>Animation</code>对象的当前值。evaluate函数还执行一些内务处理，例如确保在动画值分别为0.0和1.0时返回开始和结束。</p><h4 id="Tween-animate"><a href="#Tween-animate" class="headerlink" title="Tween.animate"></a>Tween.animate</h4><p>要使用Tween对象，请在Tween上调用animate（），并传入控制器对象。例如，以下代码在500ms的过程中生成0到255之间的整数值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AnimationController controller = AnimationController(</span><br><span class="line">    duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line">Animation&lt;<span class="built_in">int</span>&gt; alpha = IntTween(begin: <span class="number">0</span>, end: <span class="number">255</span>).animate(controller);</span><br></pre></td></tr></table></figure><p>注意：animate()方法返回的是<code>Animation</code>，而不是<code>Animatable</code>。</p><p>以下示例展示了控制器(controller)，曲线(curve)和补间动画(Tween)：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AnimationController controller = AnimationController(</span><br><span class="line">    duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">final</span> Animation curve =</span><br><span class="line">    CurvedAnimation(parent: controller, curve: Curves.easeOut);</span><br><span class="line">Animation&lt;<span class="built_in">int</span>&gt; alpha = IntTween(begin: <span class="number">0</span>, end: <span class="number">255</span>).animate(curve);</span><br></pre></td></tr></table></figure><h3 id="Animation-notifications"><a href="#Animation-notifications" class="headerlink" title="Animation notifications"></a>Animation notifications</h3><p>Animation对象可以有监听者(Listeners)和状态监听者(StatusListeners)，用addListener()和addStatusListener()来定义。只要动画的值发生变化，就会调用监听器。监听器最常见的行为是调用setState()来引起重建。动画开始，结束，前进或反向时调用<code>StatusListener</code>，如AnimationStatus所定义的。下一节有addListener()方法的示例，监视动画的过程(Monitoring the progress of the animation)展示了addStatusListener()的示例。</p><h2 id="Animation-例子"><a href="#Animation-例子" class="headerlink" title="Animation 例子"></a>Animation 例子</h2><p>本节会带你亲历5个动画的例子。每个部分都提供了该示例源代码的链接。</p><h3 id="渲染动画"><a href="#渲染动画" class="headerlink" title="渲染动画"></a>渲染动画</h3><p>重点是什么？</p><ul><li>如何使用addListener()和setState()向widget添加基础动画。</li><li>每次动画生成一个新数字时，addListener()函数都会调用setState()。</li><li>如何使用所需的vsync参数定义<code>AnimatedController</code>。</li><li>理解“..addListener”中的“..”语法，也称为Dart的级联表示法。</li><li>要使类成为私有，请使用下划线(_)开始其名称。</li></ul><p>到目前为止，您已经学会了如何随着时间的推移生成一系列数字。没有任何内容呈现在屏幕上。要使用<code>Animation</code>对象进行渲染，请将<code>Animation</code>对象存储为widget的成员，然后使用其值来决定如何绘制。</p><p>想想看以下绘制没有动画的Flutter logo的应用程序：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(LogoApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogoApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  _LogoAppState createState() =&gt; _LogoAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LogoAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LogoApp</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Container(</span><br><span class="line">        margin: EdgeInsets.symmetric(vertical: <span class="number">10</span>),</span><br><span class="line">        height: <span class="number">300</span>,</span><br><span class="line">        width: <span class="number">300</span>,</span><br><span class="line">        child: FlutterLogo(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用来源：<a href="https://github.com/flutter/website/tree/master/examples/animation/animate0" target="_blank" rel="noopener">animate0</a></p><p>以下展示了相同的代码修改，以使logo动画从无到有增长。定义<code>AnimationController</code>时，必须传入vsync对象。vsync参数在AnimationController部分中描述。</p><p>与非动画示例的相比的改动，做了高亮显示处理：</p><p><img src="https://qiantun.oss-cn-beijing.aliyuncs.com/img/WeChat9b8da866d2a9ec4b3372bf11e3597cf3.png" alt></p><p>App源代码:<a href="https://github.com/flutter/website/tree/master/examples/animation/animate1" target="_blank" rel="noopener">animate1</a></p><p>addListener()函数调用setState()，因此每当<code>Animation</code>生成一个新数字时，当前帧都标记为脏的(dirty)，这会强制再次调用build()。在build()中，容器会改变大小，因为它的高度和宽度现在使用animation.value而不是硬编码值。动画完成时销毁控制器以防止内存泄漏。</p><p>通过这些少量更改，您已经在Flutter中创建了第一个动画！</p><p>Dart语言技巧：你可能不熟悉Dart的级联符号 -  ..addListener（）中的两个点。此语法表示使用animate()的返回值调用addListener()方法。请想想看以下示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animation = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0</span>, end: <span class="number">300</span>).animate(controller)</span><br><span class="line">  ..addListener(() &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>此代码相当于：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animation = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0</span>, end: <span class="number">300</span>).animate(controller);</span><br><span class="line">animation.addListener(() &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>你可以在<a href="https://www.dartlang.org/guides/language/language-tour" target="_blank" rel="noopener">Dart语言之旅</a>中了解有关级联表示法的更多信息。</p><h3 id="使用AnimatedWidget进行简化"><a href="#使用AnimatedWidget进行简化" class="headerlink" title="使用AnimatedWidget进行简化"></a>使用<code>AnimatedWidget</code>进行简化</h3><p>重点是什么？</p><ul><li>如何使用<code>AnimatedWidget</code>帮助类(而不是addListener()和setState()）来创建有动画效果的widget</li><li>使用<code>AnimatedWidget</code>创建一个执行可重用动画的widget。要将widget的过渡分开，请使用<code>AnimatedBuilder</code>。</li><li>Flutter API中的AnimatedWidgets示例：AnimatedBuilder，AnimatedModalBarrier，DecoratedBoxTransition，FadeTransition，PositionedTransition，RelativePositionedTransition，RotationTransition，ScaleTransition，SizeTransition，SlideTransition。</li></ul><p><code>AnimatedWidget</code>基类允许你从动画代码中分离核心widget代码。<code>AnimatedWidget</code>不需要维护State对象来持有动画。添加以下<code>AnimatedLogo</code>类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimatedLogo</span> <span class="keyword">extends</span> <span class="title">AnimatedWidget</span> </span>&#123;</span><br><span class="line">  AnimatedLogo(&#123;Key key, Animation&lt;<span class="built_in">double</span>&gt; animation&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(key: key, listenable: animation);</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; animation = listenable;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Container(</span><br><span class="line">        margin: EdgeInsets.symmetric(vertical: <span class="number">10</span>),</span><br><span class="line">        height: animation.value,</span><br><span class="line">        width: animation.value,</span><br><span class="line">        child: FlutterLogo(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AnimatedLogo</code>在绘制自身时使用动画的当前值。</p><p>LogoApp仍然管理<code>AnimationController</code>和<code>Tween</code>，它将<code>Animation</code>对象传递给<code>AnimatedLogo</code>：</p><p><img src="https://qiantun.oss-cn-beijing.aliyuncs.com/img/1555986061511.jpg" alt></p><p>App源代码:<a href="https://github.com/flutter/website/tree/master/examples/animation/animate2" target="_blank" rel="noopener">animate2</a></p><h3 id="监控动画的过程"><a href="#监控动画的过程" class="headerlink" title="监控动画的过程"></a>监控动画的过程</h3><p>重点是什么？</p><ul><li>使用addStatusListener()通知动画状态的更改，例如启动，停止或反转方向。</li><li>通过在动画完成或返回其起始状态时反转方向，在无限循环中运行动画。</li></ul><p>知道动画何时改变状态通常很有帮助，例如完成，前进或后退。您可以使用addStatusListener()获取此通知。以下代码修改前一个示例，以便它监听状态更改并打印更新。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LogoAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LogoApp</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  Animation&lt;<span class="built_in">double</span>&gt; animation;</span><br><span class="line">  AnimationController controller;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    controller =</span><br><span class="line">        AnimationController(duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line">    animation = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0</span>, end: <span class="number">300</span>).animate(controller)</span><br><span class="line">      ..addStatusListener((state) =&gt; <span class="built_in">print</span>(<span class="string">'<span class="subst">$state</span>'</span>));</span><br><span class="line">    controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此代码会产生以下输出：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnimationStatus.forward</span><br><span class="line">AnimationStatus.completed</span><br></pre></td></tr></table></figure><p>接下来，使用addStatusListener()在开头或结尾反转动画。这会产生“呼吸”效果：</p><p><img src="https://qiantun.oss-cn-beijing.aliyuncs.com/img/1555986414707.jpg" alt></p><p>App源代码:<a href="https://github.com/flutter/website/tree/master/examples/animation/animate3" target="_blank" rel="noopener">animate3</a></p><h3 id="使用AnimatedBuilder进行重构"><a href="#使用AnimatedBuilder进行重构" class="headerlink" title="使用AnimatedBuilder进行重构"></a>使用AnimatedBuilder进行重构</h3><p>重点是什么？</p><ul><li><code>AnimatedBuilder</code>知道如何渲染过渡。</li><li><code>AnimatedBuilder</code>不知道如何渲染widget，也不管理<code>Animation</code>对象。</li><li>使用<code>AnimatedBuilder</code>将动画描述为另一个widget的build方法的一部分。如果你只想使用可重复使用的动画定义widget，请使用<code>AnimatedWidget</code>。</li><li>Flutter API中的AnimatedBuilders示例：<code>BottomSheet</code>，<code>ExpansionTile</code>，<code>PopupMenu</code>，<code>ProgressIndicator</code>，<code>RefreshIndicator</code>，<code>Scaffold</code>，<code>SnackBar</code>，<code>TabBar</code>，<code>TextField</code>。</li></ul><p>animate3示例中的代码的一个问题是，更改动画需要更改渲染logo的widget。更好的解决方案是将职责分成不同的类：</p><ul><li>渲染logo</li><li>定义<code>Animation</code>对象</li><li>渲染过渡</li></ul><p>你可以在<code>AnimatedBuilder</code>类的帮助下完成此分离。 <code>AnimatedBuilder</code>是渲染树中的单独类。与<code>AnimatedWidget</code>一样，AnimatedBuilder会自动监听来自<code>Animation</code>对象的通知，并根据需要将widget树标记为脏的(dirty)，因此您无需调用addListener()。</p><p><a href="https://github.com/flutter/website/tree/master/examples/animation/animate4/lib/main.dart" target="_blank" rel="noopener">animate4</a>示例的widget树如下所示：</p><p><img src="https://flutter.dev/assets/ui/AnimatedBuilder-WidgetTree-99e58a8bbf50268bcb0586c276889534bf31e0dc09f17e355a863b04b06a0ec4.png" alt></p><p>从widget树的底部开始，用于渲染logo的代码非常简单：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogoWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Leave out the height and width so it fills the animating parent</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; Container(</span><br><span class="line">        margin: EdgeInsets.symmetric(vertical: <span class="number">10</span>),</span><br><span class="line">        child: FlutterLogo(),</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图中的中间三个块都是在GrowTransition的build()方法中创建的，如下所示。 GrowTransition widget本身是无状态的，并包含定义过渡动画所需的最终变量集。 build()函数创建并返回<code>AnimatedBuilder</code>，它将（Anonymous builder）方法和LogoWidget对象作为参数。渲染过渡的工作实际上发生在（Anonymous builder）方法中，该方法创建适当大小的Container以强制LogoWidget缩小以适应。</p><p>下面代码中的一个棘手问题是孩子看起来像是指定了两次。事情是这样的，child的外部引用传递给<code>AnimatedBuilder</code>，<code>AnimatedBuilder</code>将其传递给匿名闭包，然后匿名闭包将该对象用作其子对象。最终结果是AnimatedBuilder插入到渲染树中的两个widget之间。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrowTransition</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  GrowTransition(&#123;<span class="keyword">this</span>.child, <span class="keyword">this</span>.animation&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">  <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; animation;</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) =&gt; Center(</span><br><span class="line">        child: AnimatedBuilder(</span><br><span class="line">            animation: animation,</span><br><span class="line">            builder: (context, child) =&gt; Container(</span><br><span class="line">                  height: animation.value,</span><br><span class="line">                  width: animation.value,</span><br><span class="line">                  child: child,</span><br><span class="line">                ),</span><br><span class="line">            child: child),</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，初始化动画的代码看起来与<a href="https://github.com/flutter/website/tree/master/examples/animation/animate2/lib/main.dart" target="_blank" rel="noopener">animate2</a>示例非常相似。 initState()方法创建一个<code>AnimationController</code>和一个<code>Tween</code>，然后用<code>animate()</code>绑定它们。魔术发生在build()方法中，该方法返回一个带LogoWidget作为子项的<code>GrowTransition</code>对象，以及一个驱动转换的动画对象。这些是上面要点中列出的三个要素。</p><p><img src="https://qiantun.oss-cn-beijing.aliyuncs.com/img/1555986662346.jpg" alt></p><p>应用源代码:<a href="https://github.com/flutter/website/tree/master/examples/animation/animate4" target="_blank" rel="noopener">animate4</a></p><h3 id="同步动画"><a href="#同步动画" class="headerlink" title="同步动画"></a>同步动画</h3><p>重点是什么？</p><ul><li>Curves类定义了一个常用曲线数组，你可以将它们与CurvedAnimation一起使用。</li></ul><p>在本节中，您将基于监视动画过程(<a href="https://github.com/flutter/website/tree/master/examples/animation/animate3/lib/main.dart" target="_blank" rel="noopener">animate3</a>）的示例构建，该动画使用<code>AnimatedWidget</code>连续进行动画制作。想想看在不透明度从透明到不透明设置动画时要进行动画处理的情况。</p><p>注意：此示例显示如何在同一动画控制器上使用多个补间，其中每个补间管理动画中的不同效果。它仅用于说明目的。如果你在生产代码中补间不透明度和大小，你可能会使用<code>FadeTransition</code>和<code>SizeTransition</code>。</p><p>每个补间管理动画的一个方面。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">controller =</span><br><span class="line">    AnimationController(duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line">sizeAnimation = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0</span>, end: <span class="number">300</span>).animate(controller);</span><br><span class="line">opacityAnimation = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0.1</span>, end: <span class="number">1</span>).animate(controller);</span><br></pre></td></tr></table></figure><p>您可以使用sizeAnimation.value获取大小，使用opacityAnimation.value获取不透明度，但AnimatedWidget的构造函数只接受一个Animation对象。要解决此问题，该示例将创建自己的Tween对象并显式计算值。</p><p>更改AnimatedLogo以封装其自己的Tween对象，并且其build()方法在父动画对象上调用Tween.evaluate()以计算所需的大小和不透明度值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimatedLogo</span> <span class="keyword">extends</span> <span class="title">AnimatedWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make the Tweens static because they don't change.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> _opacityTween = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0.1</span>, end: <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> _sizeTween = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0</span>, end: <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  AnimatedLogo(&#123;Key key, Animation&lt;<span class="built_in">double</span>&gt; animation&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(key: key, listenable: animation);</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; animation = listenable;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Opacity(</span><br><span class="line">        opacity: _opacityTween.evaluate(animation),</span><br><span class="line">        child: Container(</span><br><span class="line">          margin: EdgeInsets.symmetric(vertical: <span class="number">10</span>),</span><br><span class="line">          height: _sizeTween.evaluate(animation),</span><br><span class="line">          width: _sizeTween.evaluate(animation),</span><br><span class="line">          child: FlutterLogo(),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogoApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  _LogoAppState createState() =&gt; _LogoAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LogoAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LogoApp</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  Animation&lt;<span class="built_in">double</span>&gt; animation;</span><br><span class="line">  AnimationController controller;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    controller =</span><br><span class="line">        AnimationController(duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line">    animation = CurvedAnimation(parent: controller, curve: Curves.easeIn)</span><br><span class="line">      ..addStatusListener((status) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status == AnimationStatus.completed) &#123;</span><br><span class="line">          controller.reverse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AnimationStatus.dismissed) &#123;</span><br><span class="line">          controller.forward();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; AnimatedLogo(animation: animation);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    controller.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App 源代码:<a href="https://github.com/flutter/website/tree/master/examples/animation/animate5" target="_blank" rel="noopener">animate5</a></p><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>本教程为你使用Tweens在Flutter中创建动画提供了基础，但还有许多其他类需要探索。你可以研究专门的<code>Tween</code>类，特定于<code>Material Design</code>的动画，<code>ReverseAnimation</code>，共享元素过渡（也称为Hero动画),物理模拟和fling()方法。有关最新的可用文档和示例，请参阅<a href="https://flutter.dev/docs/development/ui/animations" target="_blank" rel="noopener">动画登录页面</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Animations </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)动画概观</title>
      <link href="/2019/04/23/Flutter/development/ui/animations/Animations%20overview/"/>
      <url>/2019/04/23/Flutter/development/ui/animations/Animations%20overview/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/development/ui/animations/overview" target="_blank" rel="noopener">原文链接</a></p><p>Flutter中的动画系统是基于类型化的<a href="https://api.flutter.dev/flutter/animation/Animation-class.html" target="_blank" rel="noopener"><code>Animation</code></a>对象的。widget可以通过读取它们当前的状态和监听它们的状态变化把这些动画合并进widget的build方法中，也可以使用动画作为更精心制作的动画的基础，并将这些精心制作的动画传递给其它widget。</p><a id="more"></a><h2 id="动画-Animation"><a href="#动画-Animation" class="headerlink" title="动画(Animation)"></a>动画(Animation)</h2><p>动画系统的主要构建块是<a href="https://api.flutter.dev/flutter/animation/Animation-class.html" target="_blank" rel="noopener"><code>Animation</code></a>类。一个动画代表了一个在动画的生命周期内可变化的特定类型的值。大多数执行动画的widget都会接收一个<code>Animation</code>对象作为参数，从中可以读取动画的当前值并在动画上监听值的变化。</p><h3 id="addListener"><a href="#addListener" class="headerlink" title="addListener"></a>addListener</h3><p>每当动画的值发生变化时，动画都会通知添加了<code>addListener</code>的所有监听者。通常，监听动画的State对象将在其监听回调中调用<code>setState</code>，以通知widget系统它需要使用动画的新值进行重建。</p><p>这种模式很常见，有两个widget可以帮助widget在动画改变值时重建：<a href="https://api.flutter.dev/flutter/widgets/AnimatedWidget-class.html" target="_blank" rel="noopener"><code>AnimatedWidget</code></a>和<a href="https://api.flutter.dev/flutter/widgets/AnimatedBuilder-class.html" target="_blank" rel="noopener"><code>AnimatedBuilder</code></a>。第一个是<code>AnimatedWidget</code>，对于无状态动画widget最有用。要使用<code>AnimatedWidget</code>，只需继承它并实现<a href="https://api.flutter.dev/flutter/widgets/AnimatedWidget/build.html" target="_blank" rel="noopener">build</a>函数。第二个是<code>AnimatedBuilder</code>，它对于希望将一个动画作为更大的build函数的一部分包含在内的更复杂的widget非常有用。要使用<code>AnimatedBuilder</code>，只需构造widget并将其传递给<code>builder</code>函数。</p><h3 id="addStatusListener"><a href="#addStatusListener" class="headerlink" title="addStatusListener"></a>addStatusListener</h3><p>动画还提供了一个<code>AnimationStatus</code>，它指示动画将如何随时间演变。每当动画的状态发生变化时，动画都会通知添加过<code>addStatusListener</code>的所有监听器。通常情况下，动画从<code>dimissed</code>状态开始，这意味着它们处于其范围的开始。例如,从0.0行进到1.0的动画，当它们的值是0.0的时候会处于<code>dismissed</code>状态。然后，动画可能然后运行播放(<code>forward</code>)(例如…从0.0到1.0)或者进入倒放(<code>reverse</code>)状态(例如..从1.0到0.0)。最终，如果动画到达其范围的末尾(例如，1.0),则动画到达完成(<code>completed</code>)状态。</p><h2 id="动画控制器-AnimationController"><a href="#动画控制器-AnimationController" class="headerlink" title="动画控制器(AnimationController)"></a>动画控制器(AnimationController)</h2><p>要创建动画，首先要创建一个<code>AnimationController</code>。除了作为动画本身能控制动画外，<code>AnimationController</code>还可以让你控制动画。例如，你可以告诉控制器播放动画或停止动画。你还可以弹射(<a href="https://api.flutter.dev/flutter/animation/AnimationController/fling.html" target="_blank" rel="noopener">fling</a>)动画，它使用物理仿真-弹簧来驱动动画。</p><p>一旦动画控制器创建完成后，你可以开始基于它构建其他动画。例如，您可以创建反映原始动画的<code>ReverseAnimation</code>，但以相反的方向运行（例如，从1.0到0.0）。同样，您可以创建一个<code>CurvedAnimation</code>，其值由曲线<a href="https://api.flutter.dev/flutter/animation/Curves-class.html" target="_blank" rel="noopener"><code>curve</code></a>校正。</p><h2 id="补间动画-Tweens"><a href="#补间动画-Tweens" class="headerlink" title="补间动画(Tweens)"></a>补间动画(Tweens)</h2><p>要设置超过0.0到1.0间隔的动画，可以使用Tween&lt;T&gt;，它在其开始值和结束值之间进行插值。许多类型都有特定的Tween子类，它们提供特定于类型的插值。例如，ColorTween在颜色之间插值，而RectTween在rects之间插值。你可以通过创建自己的Tween子类并覆盖其lerp函数来定义自己的插值。</p><p>补间本身只定义了如何在两个值之间进行插值。要获取动画当前帧的具体值，还需要动画来确定当前状态。有两种方法可以将补间与动画组合在一起以获得具体值：</p><ol><li><p>您可以在动画的当前值处评估补间。这种方法对于已经监听动画并因此在动画改变值时重建的widget最有用。</p></li><li><p>您可以根据动画为补间设置动画。animate函数返回一个包含补间的新动画，而不是返回单个值。当你想要将新创建的动画提供给另一个widget时，此方法最有用，该weiget可以读取包含补间的当前值以及监听值的变化。</p></li></ol><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>动画实际上是由许多核心构建块构建的。</p><h3 id="调度器-Scheduler"><a href="#调度器-Scheduler" class="headerlink" title="调度器(Scheduler)"></a>调度器(Scheduler)</h3><p>SchedulerBinding是一个暴露Flutter调度原语(scheduling primitives)的单例类。</p><p>对于此讨论，关键原语(primitive)是帧回调。每次需要在屏幕上显示一个帧时，Flutter的引擎会触发一个“开始帧”回调，调度程序将多路复用到使用scheduleFrameCallback()注册的所有监听器。所有这些回调都给出了框架的官方时间戳，以距离一些时间点的持续时间的形式，由于所有回调都具有相同的时间，因此从这些回调触发的任何动画看起来都是完全同步的，即使它们需要几毫秒才能执行。</p><h3 id="Tickers"><a href="#Tickers" class="headerlink" title="Tickers"></a>Tickers</h3><p><a href="https://api.flutter.dev/flutter/scheduler/Ticker-class.html" target="_blank" rel="noopener">Ticker</a>类钩进调度程序的<code>scheduleFrameCallback()</code>机制，从而能在每个tick中调用回调。</p><p>Ticker可以被启动和停止。启动时，它返回一个将在停止时解析到的Future。</p><p>每个tick，Ticker为回调提供自启动后第一个tick以来的持续时间。</p><p>因为代码总是在它们启动后给出相对于第一个刻度的过去的时间，所以代码都是同步的。如果你在两帧之间的不同时间开始三个tick，它们将以相同的开始时间同步，并随后以固定步伐进行tick。</p><h3 id="仿真-Simulations"><a href="#仿真-Simulations" class="headerlink" title="仿真(Simulations)"></a>仿真(Simulations)</h3><p><code>Simulation</code>抽象类将相对时间值(过去的时间)映射到double值，并有着一个完成的概念。</p><p>原则上，仿真是无状态的，但在实践中，一些仿真（例如，<a href="https://api.flutter.dev/flutter/widgets/BouncingScrollSimulation-class.html" target="_blank" rel="noopener"><code>BouncingScrollSimulation</code></a>和<a href="https://api.flutter.dev/flutter/widgets/ClampingScrollSimulation-class.html" target="_blank" rel="noopener"><code>ClampingScrollSimulation</code></a>）在查询时会不可逆地改变状态。</p><p>针对不同的效果，<code>Simulation</code>类有<a href="https://api.flutter.dev/flutter/physics/physics-library.html" target="_blank" rel="noopener">各种具体实现</a>。</p><h3 id="动画特征-Animatables"><a href="#动画特征-Animatables" class="headerlink" title="动画特征(Animatables)"></a>动画特征(Animatables)</h3><p><a href="https://api.flutter.dev/flutter/animation/Animatable-class.html" target="_blank" rel="noopener"><code>Animatable</code></a>抽象类将double映射到特定类型的值。</p><p><code>Animatable</code>类是无状态的和不可变的。</p><h4 id="补间动画-Tween"><a href="#补间动画-Tween" class="headerlink" title="补间动画(Tween)"></a>补间动画(Tween)</h4><p><code>Tween</code>抽象类将名义上在0.0-1.0范围内的double值映射到类型化值（例如Color或另一个double)。它是一个<code>Animatable</code>。</p><p>它有一个输出类型(T)的概念，该类型的开始值和结束值，以及在给定输入值的起始值和结束值之间插值（lerp）的方法（名义上在0.0-1.0的范围内）。</p><p><code>Tween</code>类是无状态和不可变的。</p><h4 id="组合动画-Composing-animatables"><a href="#组合动画-Composing-animatables" class="headerlink" title="组合动画(Composing animatables)"></a>组合动画(Composing animatables)</h4><p>将Animatable&lt;double&gt;（父级）传递给Animatable的chain()方法会创建一个新的Animatable子类，该子类应用父级的映射，然后应用子级的映射。</p><h3 id="曲线-Curves"><a href="#曲线-Curves" class="headerlink" title="曲线(Curves)"></a>曲线(Curves)</h3><p>曲线抽象类在名义上将0.0到1.0的范围内的双精度映射到名义上在0.0-1.0范围内的双精度。</p><p>曲线类是无状态和不可变的。</p><h3 id="动画-Animations"><a href="#动画-Animations" class="headerlink" title="动画(Animations)"></a>动画(Animations)</h3><p><code>Animation</code>抽象类提供给定类型的值，动画方向和动画状态的概念，以及用于注册在值或状态更改时调用的回调的监听器接口。</p><p>动画的某些子类具有永不改变的值（<a href="https://api.flutter.dev/flutter/animation/kAlwaysCompleteAnimation-constant.html" target="_blank" rel="noopener">kAlwaysCompleteAnimation</a>，<a href="https://api.flutter.dev/flutter/animation/kAlwaysDismissedAnimation-constant.html" target="_blank" rel="noopener">kAlwaysDismissedAnimation</a>，<a href="https://api.flutter.dev/flutter/animation/AlwaysStoppedAnimation-class.html" target="_blank" rel="noopener">AlwaysStoppedAnimation</a>）;在这些上注册回调没有任何影响，因为永远不会调用回调。</p><p>Animation&lt;double&gt;变量是特殊的，因为它可以用于表示0.0-1.0范围内的双精度，这是Curve和Tween类所期望的输入，以及动画的一些其他子类。</p><p>某些动画子类是无状态的，只是将监听器器转发给其父级。有些是非常有状态的。</p><h4 id="可组合动画-Composable-animations"><a href="#可组合动画-Composable-animations" class="headerlink" title="可组合动画(Composable animations)"></a>可组合动画(Composable animations)</h4><p>大多数动画子类取得的是一个显式的“父级”Animation&lt;double&gt;。它们是由那个父级驱动的。</p><p><code>CurvedAnimation</code>子类将Animation&lt;double&gt;类(父级)和几个Curve类(前向和反向曲线)作为输入，并使用父级的值作为曲线的输入来确定它的输出。<code>CurvedAnimation</code>是不可变的和无状态的。</p><p><code>ReverseAnimation</code>子类将Animation&lt;double&gt;类作为其父级，并反转动画的所有值。它假定父级使用的值一般在0.0-1.0范围内，并返回1.0-0.0范围内的值。父动画的状态和方向也相反。<code>ReverseAnimation</code>是不可变的，无状态的。</p><p><code>ProxyAnimation</code>子类将Animation&lt;double&gt;类作为其父级，并仅转发该父级的当前状态。但是,父级可变的。</p><p><code>TrainHoppingAnimation</code>子类接受两个父项，并在它们的值交叉时在它们之间切换。</p><h4 id="动画控制器-Animation-Controllers"><a href="#动画控制器-Animation-Controllers" class="headerlink" title="动画控制器(Animation Controllers)"></a>动画控制器(Animation Controllers)</h4><p><code>AnimationController</code>是一个有状态的Animation&lt;double&gt;，它使用Ticker来赋予自己生命。它可以启动和停止。每个trck，它需要从启动以来经过的时间并将其传递给<code>Simulation</code>来获取一个值。那就是它报告的价值。如果<code>Simulation</code>报告当时它已结束，则控制器自行停止。仿真</p><p>可以给予动画控制器下限和上限以及持续时间，然后在其中控制动画。</p><p>在简单的情况下（使用<code>forward()</code>，<code>reverse()</code>，<code>play(</code>)或<code>resume()</code>,动画控制器在给定的时间内只是从下限到上限进行线性插值(反之亦然)。</p><p>使用<code>repeat()</code>时，动画控制器在给定的持续时间内使用给定边界之间的线性插值，但不会停止。</p><p>使用<code>animateTo()</code>时，动画控制器会在给定的持续时间内从当前值到给定目标执行线性插值。如果没有给出方法的持续时间，则控制器的默认持续时间和控制器的下限和上限描述的范围被用来确定动画的速度。<br>仿真<br>使用<code>fling()</code>时，<code>Force</code>被用来创建特定的仿真，然后被用来驱动控制器。</p><p>使用<code>animateWith()</code>时，给定的仿真被用于驱动控制器。</p><p>这些方法都返回Ticker提供的future，这个future会在控制器下次停止或更改仿真时解析到。</p><h4 id="将动画特征附加到动画"><a href="#将动画特征附加到动画" class="headerlink" title="将动画特征附加到动画"></a>将动画特征附加到动画</h4><p>将Animation&lt;double&gt;(新父级)传递给一个<code>Animatable</code>的<code>animate()</code>方法会创建一个新的<code>Animation</code>子类，其作用类似于<code>Animatable</code>，但是从给定的父级动作驱动。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Animations </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Flutter bloc包</title>
      <link href="/2019/04/22/Flutter/development/data-and-backend/state-mgmt/options/BloC/Flutter%20Bloc%20Package/"/>
      <url>/2019/04/22/Flutter/development/data-and-backend/state-mgmt/options/BloC/Flutter%20Bloc%20Package/</url>
      
        <content type="html"><![CDATA[<p><a href="https://medium.com/flutter-community/flutter-bloc-package-295b53e95c5c" target="_blank" rel="noopener">原文链接</a></p><p><img src="https://cdn-images-1.medium.com/max/1600/1*lP-1aF6Rg8jo459f87l3zg.png" alt></p><p>在使用Flutter一段时间之后，我决定创造一个包帮忙我经常使用的东西—BLoC模式做一些事情。</p><a id="more"></a><p>对于那些不熟悉BLoC模式的人来说，它是一种设计模式，它有助于将表示层与业务逻辑分开。你从<a href="https://www.youtube.com/watch?v=fahC3ky_zW0" target="_blank" rel="noopener">这里</a>能够了解更多。</p><p>虽然使用BLoC模式可能会因为设置以及对<code>Streams</code>和<code>Reactive Programming</code>的理解而具有挑战性，但它的核心BLoC是非常简单的：</p><p>BLoC将事件流作为输入，并将它们转换为状态流作为输出。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*_EgLk67LpREOEMCSIhc_4Q.png" alt></p><p>我们现在可以在bloc包的帮助下使用这种强大的设计模式。</p><p>该软件包抽象了BLoC模式的响应式方面，允许开发人员专注于将事件转换为状态。</p><p>让我们从定义这些术语开始。</p><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><p>事件(<code>Events</code>)是BLoC的输入。它们通常是UI事件，例如按钮按下。事件(<code>Events</code>)被发送(<code>dispatched</code>)并转换为状态(<code>States</code>)。</p><p>状态(<code>State</code>)是BLoC的产物。表示组件可以监听状态流并根据给定状态对其自身的部分进行重绘(有关详细信息，请参阅<code>BlocBuilder</code>)。</p><p>转换(<code>Transitions</code>)发生在mapEventToState被调用之后，当事件被发送之后，但在bloc状态被修改之前。一个转换(<code>Transition</code>)由当前状态(<code>currentState</code>)，已分送的事件(<code>event</code>)和下个状态(<code>nextState</code>)组成。</p><p>现在我们了解事件和状态，我们可以看一下Bloc API了。</p><h2 id="Bloc-API"><a href="#Bloc-API" class="headerlink" title="Bloc API"></a>Bloc API</h2><p>mapEventToState是一个类在扩展Bloc时必须实现的方法。该方法将传入事件作为参数。只要有一个事件被表示层发送(<code>dispatched</code>)，就会调用<code>mapEventToState</code>。 <code>mapEventToState</code>必须将该事件转换为新状态，并<code>Stream</code>的形式返回新状态,而这个新状态会被表示层使用。</p><p><code>dispatch</code>是一个接收事件并触发<code>mapEventToState</code>的方法。可以从表示层或从Bloc内部调用dispatch（参见示例）并向Bloc通知新事件来了。</p><p><code>initialState</code>是任何事件都没有被处理之前的状态（在调用<code>mapEventToState</code>之前）。initialState是一个可选的getter。如果未实现，则initialState将为null。</p><p><code>transform</code>是一个方法，可以在调用<code>mapEventToState</code>之前重写Stream<event>。这其中允许使用distinct()和debounce()之类的操作。</event></p><p><code>onTransition</code>是一个方法，可以在发生转换时覆盖对其加以处理。转换(<code>Transition</code>)发生在新的事件(<code>event</code>)被发送以及<code>mapEventToState</code>被调用的时候。<code>onTransition</code>在bloc的状态被更新之前被调用。这是添加bloc特有的日志记录/分析的好地方。</p><p>让我们创建一个计数器bloc！</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> CounterEvent &#123; increment, decrement &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterBloc</span> <span class="keyword">extends</span> <span class="title">Bloc</span>&lt;<span class="title">CounterEvent</span>, <span class="title">int</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> initialState =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; mapEventToState(CounterEvent event) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">      <span class="keyword">case</span> CounterEvent.decrement:</span><br><span class="line">        <span class="keyword">yield</span> currentState - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CounterEvent.increment:</span><br><span class="line">        <span class="keyword">yield</span> currentState + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了创建一个计数器bloc，我们需要做的就是：</p><ul><li>定义我们的事件和状态</li><li>扩展BloC</li><li>覆盖<code>initialState</code>和<code>mapEventToState</code>。</li></ul><p>在这种情况中，我们的事件是<code>CounterEvents</code>，我们的状态是整数类型。</p><p>我们的<code>CounterBloc</code>将<code>CounterEvents</code>转换为整数类型。</p><p>我们可以通过像这样调用<code>dispatch</code>方法来通知CounterBloc发出事件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> counterBloc = CounterBloc();</span><br><span class="line"></span><br><span class="line">  counterBloc.dispatch(CounterEvent.increment);</span><br><span class="line">  counterBloc.dispatch(CounterEvent.decrement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了观察状态变化(<code>Transitions</code>），我们可以覆盖<code>onTransition</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> CounterEvent &#123; increment, decrement &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterBloc</span> <span class="keyword">extends</span> <span class="title">Bloc</span>&lt;<span class="title">CounterEvent</span>, <span class="title">int</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> initialState =&gt; <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> onTransition(Transition&lt;CounterEvent, <span class="built_in">int</span>&gt; transition) &#123;</span><br><span class="line">    <span class="built_in">print</span>(transition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; mapEventToState(CounterEvent event) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">      <span class="keyword">case</span> CounterEvent.decrement:</span><br><span class="line">        <span class="keyword">yield</span> currentState - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CounterEvent.increment:</span><br><span class="line">        <span class="keyword">yield</span> currentState + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>现在，每当我们调度CounterEvent时，我们的Bloc将以新的整数状态响应，我们将看到一个转换记录被打印到到控制台。</p><p>现在让我们使用Flutter构建一个UI，并使用<a href="https://pub.dartlang.org/packages/flutter_bloc" target="_blank" rel="noopener">flutter_bloc</a>包将表示层连接到我们的<code>CounterBloc</code>。</p><p><a href="https://pub.dartlang.org/packages/flutter_bloc" target="_blank" rel="noopener">flutter_bloc</a>包提供了两个widget，使得可以轻松地与Bloc进行交互：</p><h2 id="BlocBuilder"><a href="#BlocBuilder" class="headerlink" title="BlocBuilder"></a>BlocBuilder</h2><p><code>BlocBuilder</code>是一个Flutter widget，它需要一个Bloc和一个builder方法。 BlocBuilder处理了构建widget的工作以响应新状态。BlocBuilder与StreamBuilder非常相似，但它有一个更简单的API来减少所需的样板代码量。</p><h2 id="BlocProvider"><a href="#BlocProvider" class="headerlink" title="BlocProvider"></a>BlocProvider</h2><p><code>BlocProvider</code>是一个Flutter widget，它通过<code>BlocProvider.of(context)</code>为其子节点提供一个集合。它被用作依赖注入(DI)widget，以便可以将BloC的单例提供给子树中的多个widget。</p><p>现在让我们构建我们的Counter App！</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() =&gt; _AppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">App</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> CounterBloc _counterBloc = CounterBloc();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      home: BlocProvider&lt;CounterBloc&gt;(</span><br><span class="line">        bloc: _counterBloc,</span><br><span class="line">        child: CounterPage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _counterBloc.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> CounterBloc _counterBloc = BlocProvider.of&lt;CounterBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Counter'</span>)),</span><br><span class="line">      body: BlocBuilder&lt;CounterEvent, <span class="built_in">int</span>&gt;(</span><br><span class="line">        bloc: _counterBloc,</span><br><span class="line">        builder: (BuildContext context, <span class="built_in">int</span> count) &#123;</span><br><span class="line">          <span class="keyword">return</span> Center(</span><br><span class="line">            child: Text(</span><br><span class="line">              <span class="string">'<span class="subst">$count</span>'</span>,</span><br><span class="line">              style: TextStyle(fontSize: <span class="number">24.0</span>),</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: Column(</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.end,</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.end,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Padding(</span><br><span class="line">            padding: EdgeInsets.symmetric(vertical: <span class="number">5.0</span>),</span><br><span class="line">            child: FloatingActionButton(</span><br><span class="line">              child: Icon(Icons.add),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                _counterBloc.dispatch(CounterEvent.increment);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          Padding(</span><br><span class="line">            padding: EdgeInsets.symmetric(vertical: <span class="number">5.0</span>),</span><br><span class="line">            child: FloatingActionButton(</span><br><span class="line">              child: Icon(Icons.remove),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                _counterBloc.dispatch(CounterEvent.decrement);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的App widget是<code>StatefulWidget</code>，负责创建和处理CounterBloc。它使用我们上面提到的BlocProvider widget使CounterBloc可用于CounterPage widget。</p><p>我们的<code>CounterPage</code> widget是一个<code>StatelessWidget</code>，它使用<code>BlocBuilder</code>重建UI以响应<code>CounterBloc</code>的状态变化。</p><p>此时，我们已经成功地将我们的表示层与业务逻辑层分开。请注意，CounterPage widget 不知道用户点击按钮时会发生什么。widget只是告诉CounterBloc用户按下了递增或递减按钮。</p><p>就这么多。</p><p>有关更多示例和详细文档，请查看<a href="https://felangel.github.io/bloc" target="_blank" rel="noopener">官方bloc文档</a>。</p><p>如果你喜欢这个bloc库，你可以通过⭐️<a href="https://github.com/felangel/bloc" target="_blank" rel="noopener">仓库</a>或者👏来支持我这个文章。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
            <tag> BLoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Flutter+Redux- 如何做一个购物清单应用</title>
      <link href="/2019/04/21/Flutter/development/data-and-backend/state-mgmt/options/Redux/Flutter%20+%20Redux%E2%80%8A%E2%80%94%E2%80%8AHow%20to%20make%20Shopping%20List%20App/"/>
      <url>/2019/04/21/Flutter/development/data-and-backend/state-mgmt/options/Redux/Flutter%20+%20Redux%E2%80%8A%E2%80%94%E2%80%8AHow%20to%20make%20Shopping%20List%20App/</url>
      
        <content type="html"><![CDATA[<p><a href="http://127.0.0.1:4000/flutter/state/management/2019/04/21/Flutter-+-Redux-How-to-make-Shopping-List-App/" target="_blank" rel="noopener">原文链接</a></p><p>嗨，大家好！在本文中，我想向你展示如何使用Redux创建Flutter应用程序。如果你不知道Flutter是什么，我推荐你阅读我的文章<a href="https://medium.com/@pszklarska/flutter-5-reasons-why-you-may-love-it-55021fdbf1aa" target="_blank" rel="noopener">Flutter - 你可能喜欢它的5个理由</a>。但是，如果你知道Flutter是什么，并且你想要创建一个设计良好，易于测试且具有非常可预测的行为的应用程序 - 那么请继续看下去！</p><a id="more"></a><h2 id="什么是Redux？"><a href="#什么是Redux？" class="headerlink" title="什么是Redux？"></a>什么是Redux？</h2><p>首先，让我们首先解释一下Redux是什么。Redux是一种应用程序架构，最初是为JavaScript构建的，现在用于使用反应式框架构建的应用程序(例如React Native或Flutter)。Redux是由Facebook制作的Flux架构的简化版本。但Redux有什么用呢？基本上，你需要知道三件事：</p><ol><li>有一个单一的数据源-你的整个应用程序状态只保存在一个地方（被称为仓库）</li><li>状态是只读的 - 要修改应用状态，你需要发送一个<code>action</code>，然后新状态就被创建出来的</li><li>使用纯方法进行修改 - 纯方法（简单的说，它是没有负效应的方法），采用先前的状态和操作，并返回新状态</li></ol><p>听起来很酷，但该解决方案的优点是什么？</p><ul><li>我们控制了状态 - 这意味着我们确切地知道导致状态变化的原因，我们没有重复状态，我们可以轻松地跟踪数据流</li><li>纯reducer方法很容易对其进行测试 -我们可以传入状态和<code>action</code>,然后看结果是否正确</li><li>应用程序结构清晰 - 我们为<code>action</code>，<code>model</code>，业务逻辑等提供了不同的层 - 因此你要加新功能的时候，你会知道要放在哪里。</li><li>对于更复杂的应用程序来说，这是一个很棒的架构 - 您不需要将整个视图树中的状态从父级传递到子级</li><li>还有一个……</li></ul><h3 id="Redux时间旅行"><a href="#Redux时间旅行" class="headerlink" title="Redux时间旅行"></a>Redux时间旅行</h3><p>Redux中有一个很酷的功能 - 🎉时间旅行！使用Redux和适当的工具，您可以随时跟踪应用程序状态，检查实际状态并随时重新创建。看看这个功能到底是什么样的：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*KL-z2sJRBYEHrnzFASVvVw.gif" alt></p><h2 id="Redux相关Widget在一个简单例子上的应用"><a href="#Redux相关Widget在一个简单例子上的应用" class="headerlink" title="Redux相关Widget在一个简单例子上的应用"></a>Redux相关Widget在一个简单例子上的应用</h2><p>所有上述规则使数据在Redux是单向流动的。但是这是什么意思？事实上，这都是由多个<code>action</code>,多个<code>reducer</code>,<code>store</code>以及多个<code>state</code>完成的。让我们想象显示按钮计数器的应用程序：</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*vM852avXATOs1_1Mq7Bn7w.png" alt></p><ul><li>你的应用程序在开始的有一些状态（点击次数，即0）</li><li>基于该状态视图被渲染出来了。</li><li>如果用户点击按钮，则会发送<code>action</code>（例如IncrementCounter）</li><li><code>reducer</code>收到动作，它知道先前的状态（计数器0），接收动作（IncrementCounter）并且可以返回新状态（计数器1）</li><li>你的应用程序有了新状态（计数器1）</li><li>基于新状态，视图再次被渲染出来</li></ul><p>正如你能看到的，通常都是与状态相关的。你有单个应用程序状态，状态对于视图是只读的，并且要创建新的状态的时候你需要发送一个<code>action</code>。发送<code>action</code>会触发<code>reducer</code>创建并发送一个新的应用状态。循环往复。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*S_BZUDym3j0Vxjfi8D21Zg.png" alt>Redux数据流</p><h2 id="使用Redux的购物清单应用示例"><a href="#使用Redux的购物清单应用示例" class="headerlink" title="使用Redux的购物清单应用示例"></a>使用Redux的购物清单应用示例</h2><p>让我展示一下Redux在更为复杂例子中的实践。我们将创建一个简单的购物车应用程序。在这个应用程序中，将具有以下功能：</p><ul><li>添加条目</li><li>将条目标记为已选中</li><li>就那么多</li></ul><p>该应用程序的样子是这样的:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*F_VsjS0EfcjFI5S-fsTvRQ.png" alt><br>你可以在Github上看到<a href="https://github.com/pszklarska/FlutterShoppingCart" target="_blank" rel="noopener">该程序的完整代码</a>。</p><p>让我们从编码开始吧！ 👇</p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>在本文中，我不会展示应用程序UI创建的部分。您可以查看这个<a href="https://github.com/pszklarska/FlutterShoppingCart/tree/a8120a23232a05d380384bb377f3994ef65ad221" target="_blank" rel="noopener">实现Redux之前的Shopping List应用程序的代码</a>。我们将从这个基础上，把Redux添加到此应用程序中。</p><p>如果你之前从未使用过Flutter，我建议您尝试使用Google推出的<a href="https://codelabs.developers.google.com/codelabs/flutter/" target="_blank" rel="noopener">Flutter Codelabs</a>。</p><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>要在Flutter上使用Redux运行，您需要向pubspec.yaml文件添加依赖项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flutter_redux:</span> <span class="string">^0.5.2</span></span><br></pre></td></tr></table></figure><p>您可以在<a href="https://pub.dartlang.org/packages/flutter_redux" target="_blank" rel="noopener">flutter_redux</a>包页面上查看最新版本。</p><h3 id="模型-Model"><a href="#模型-Model" class="headerlink" title="模型(Model)"></a>模型(Model)</h3><p>我们的应用程序需要管理添加和修改条目，因此我们将使用简单的CartItem模型来存储单个条目的状态。我们的整个应用程序状态将只是多个CartItem组成的列表。如你所见，CartItem只是一个普通的Dart对象</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItem</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> checked;</span><br><span class="line"></span><br><span class="line">  CartItem(<span class="keyword">this</span>.name, <span class="keyword">this</span>.checked);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/model/CartItem.dart" target="_blank" rel="noopener">注意：这里是这个文件的完整源代码</a></p><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a><code>Actions</code></h3><p>首先，我们需要声明<code>action</code>。 Action基本上是可以被调用以更改应用程序状态的任何意图。在我们的应用程序中，我们将有两个<code>action</code>，用于添加和修改条目：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddItemAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> CartItem item;</span><br><span class="line"></span><br><span class="line">  AddItemAction(<span class="keyword">this</span>.item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToggleItemStateAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> CartItem item;</span><br><span class="line"></span><br><span class="line">  ToggleItemStateAction(<span class="keyword">this</span>.item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/redux/actions.dart" target="_blank" rel="noopener">注意：这里是这个文件的完整源代码</a></p><h3 id="Reducers"><a href="#Reducers" class="headerlink" title="Reducers"></a><code>Reducers</code></h3><p>然后，我们需要告诉我们的应用程序应该如何处理这些操作。这就是Reducer的用途 - 它们只是采用当前的<code>State</code>和<code>action</code>，然后它们会创建并返回新的<code>State</code>。我们将有两种<code>Reducer</code>方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;CartItem&gt; appReducers(<span class="built_in">List</span>&lt;CartItem&gt; items, <span class="keyword">dynamic</span> action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action <span class="keyword">is</span> AddItemAction) &#123;</span><br><span class="line">    <span class="keyword">return</span> addItem(items, action);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action <span class="keyword">is</span> ToggleItemStateAction) &#123;</span><br><span class="line">    <span class="keyword">return</span> toggleItemState(items, action);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> items;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>&lt;CartItem&gt; addItem(<span class="built_in">List</span>&lt;CartItem&gt; items, AddItemAction action) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">List</span>.from(items)..add(action.item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>&lt;CartItem&gt; toggleItemState(<span class="built_in">List</span>&lt;CartItem&gt; items, ToggleItemStateAction action) &#123;</span><br><span class="line">  <span class="keyword">return</span> items.map((item) =&gt; item.name == action.item.name ?</span><br><span class="line">    action.item : item).toList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/redux/reducers.dart" target="_blank" rel="noopener">注意：这里是这个文件的完整源代码</a></p><p>方法<code>appReducers()</code>将<code>action</code>委托给正确的方法。 addItem()和toggleItemState()方法都返回新列表-这个列表就是我们的新应用程序状态。如你所见，您不应修改当前列表，而是每次都创建新的列表。</p><h3 id="StoreProvider"><a href="#StoreProvider" class="headerlink" title="StoreProvider"></a>StoreProvider</h3><p>现在，当我们有了<code>action</code>和<code>reducer</code>时，我们需要提供存储应用程序状态的位置。它在Redux中称为仓库，它是我们应用程序的唯一数据源。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> store = <span class="keyword">new</span> Store&lt;<span class="built_in">List</span>&lt;CartItem&gt;&gt;(</span><br><span class="line">      appReducers,</span><br><span class="line">      initialState: <span class="keyword">new</span> <span class="built_in">List</span>());</span><br><span class="line"></span><br><span class="line">  runApp(<span class="keyword">new</span> FlutterReduxApp(store));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/main.dart" target="_blank" rel="noopener">注意：这里是这个文件的完整源代码</a></p><p>要创建仓库，我们需要传递<code>reducers</code>方法和初始应用程序状态。如果我们创建了仓库，我们必须将它传递给<code>StoreProvider</code>，来告诉我们的应用程序它可以被所有请求应用状态的对象使用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterReduxApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Store&lt;<span class="built_in">List</span>&lt;CartItem&gt;&gt; store;</span><br><span class="line"></span><br><span class="line">  FlutterReduxApp(<span class="keyword">this</span>.store);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StoreProvider&lt;<span class="built_in">List</span>&lt;CartItem&gt;&gt;(</span><br><span class="line">      store: store,</span><br><span class="line">      child: <span class="keyword">new</span> ShoppingCartApp(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/main.dart" target="_blank" rel="noopener">注意：这里是这个文件的完整源代码</a></p><p>在上面的示例中，ShoppingCartApp()是主要的应用程序widget。</p><h3 id="StoreConnector"><a href="#StoreConnector" class="headerlink" title="StoreConnector"></a>StoreConnector</h3><p>目前我们拥有除了实际添加和更改条目之外的所有内容都已经做了。那么怎么添加和修改条目呢，我们需要使用<code>StoreConnector</code>。这是一种获取仓库并采取一些行动或读取它的状态的方法。</p><p>首先，我们想要读取当前数据并在列表中显示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingList</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StoreConnector&lt;<span class="built_in">List</span>&lt;CartItem&gt;, <span class="built_in">List</span>&lt;CartItem&gt;&gt;(</span><br><span class="line">      converter: (store) =&gt; store.state,</span><br><span class="line">      builder: (context, list) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListView.builder(</span><br><span class="line">            itemCount: list.length,</span><br><span class="line">            itemBuilder: (context, position) =&gt;</span><br><span class="line">                <span class="keyword">new</span> ShoppingListItem(list[position]));</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/list/shopping_list.dart" target="_blank" rel="noopener">注意：这里是这个文件的完整源代码</a></p><p>上面的代码使用<code>StoreConnector</code>包装默认的<code>ListView.builder</code>。 <code>StoreConnector</code>可以获取当前应用程序状态（List<cartitem>）并将其与转换器方法映射到任何内容。出于这种情况的目的，它将是相同的状态（List<cartitem>)，因为我们需要这里的整个列表。</cartitem></cartitem></p><p>接下来，在builder方法中我们获取到了列表 - 这基本上是来自仓库的CartItems列表，我们可以使用它来构建ListView。</p><hr><p>好的，很酷 - 我们到读取数据这一步了。现在如何去设置一些数据？</p><p>为此，我们还将使用<code>StoreConnector</code>，但方式略有不同。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddItemDialog</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StoreConnector&lt;<span class="built_in">List</span>&lt;CartItem&gt;, OnItemAddedCallback&gt;(</span><br><span class="line">        converter: (store) &#123;</span><br><span class="line">      <span class="keyword">return</span> (itemName) =&gt;</span><br><span class="line">          store.dispatch(AddItemAction(CartItem(itemName, <span class="keyword">false</span>)));</span><br><span class="line">    &#125;, builder: (context, callback) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> AddItemDialogWidget(callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> OnItemAddedCallback = <span class="built_in">Function</span>(<span class="built_in">String</span> itemName);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/add_item/add_item_dialog.dart" target="_blank" rel="noopener">注意：这里是这个文件的完整源代码</a></p><p>我们来看看代码吧。我们使用了<code>StoreConnector</code>，就像前面的例子一样，但这一次，我们将把它映射到OnItemAddedCallback，而不是将CartItems列表映射到同一个列表中。这样我们就可以将回调传递给AddItemDialogWidget，并在用户添加一些新项时调用它：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddItemDialogWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AddItemDialogWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> itemName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> OnItemAddedCallback callback;</span><br><span class="line">  AddItemDialogWidgetState(<span class="keyword">this</span>.callback);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AlertDialog(</span><br><span class="line">      ...</span><br><span class="line">      actions: &lt;Widget&gt;[</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">new</span> FlatButton(</span><br><span class="line">            child: <span class="keyword">const</span> Text(<span class="string">'ADD'</span>),</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              ...</span><br><span class="line">              callback(itemName);</span><br><span class="line">            &#125;)</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/add_item/add_item_dialog.dart" target="_blank" rel="noopener">注意：这里是这个文件的完整源代码</a></p><p>现在，每次用户按“ADD”按钮时，回调都会发送AddItemAction()事件。</p><p>现在，我们可以为切换条目状态做类似的事情：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> CartItem item;</span><br><span class="line"></span><br><span class="line">  ShoppingListItem(<span class="keyword">this</span>.item);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StoreConnector&lt;<span class="built_in">List</span>&lt;CartItem&gt;, OnStateChanged&gt;(</span><br><span class="line">        converter: (store) &#123;</span><br><span class="line">      <span class="keyword">return</span> (item) =&gt; store.dispatch(ToggleItemStateAction(item));</span><br><span class="line">    &#125;, builder: (context, callback) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ListTile(</span><br><span class="line">        title: <span class="keyword">new</span> Text(item.name),</span><br><span class="line">        leading: <span class="keyword">new</span> Checkbox(</span><br><span class="line">            value: item.checked,</span><br><span class="line">            onChanged: (<span class="built_in">bool</span> newValue) &#123;</span><br><span class="line">              callback(CartItem(item.name, newValue));</span><br><span class="line">            &#125;),</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> OnStateChanged = <span class="built_in">Function</span>(CartItem item);</span><br></pre></td></tr></table></figure><p>注意：<a href="https://github.com/pszklarska/FlutterShoppingCart/blob/4756839d5749dfa36073e830b208bb45cb5f8874/lib/list/shopping_list_item.dart" target="_blank" rel="noopener">这里是这个文件的完整源代码</a></p><p>与前面的示例一样，我们使用<code>StoreConnector</code>将List<cartitem>映射到OnStateChanged回调。现在每次更改复选框（在onChanged方法中),回调都会触发ToggleItemStateAction事件。</cartitem></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>以上就是全部内容！在本文中，我们使用Redux架构创建了一个简单的购物清单应用程序。在我们的应用程序中，我们可以添加一些条目并更改其状态。向此应用程序添加新功能就像添加新action和reducer一样简单。</p><p><a href="https://github.com/pszklarska/FlutterShoppingCart" target="_blank" rel="noopener">在这里</a>，您可以查看此应用程序的完整源代码，包括时间旅行widge：</p><p>希望你喜欢这篇文章并敬请期待更多！ 🙌</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Flutter中的Redux简介</title>
      <link href="/2019/04/20/Flutter/development/data-and-backend/state-mgmt/options/Redux/introduction%20to%20Redux%20in%20Flutter/"/>
      <url>/2019/04/20/Flutter/development/data-and-backend/state-mgmt/options/Redux/introduction%20to%20Redux%20in%20Flutter/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.novoda.com/introduction-to-redux-in-flutter/" target="_blank" rel="noopener">原文链接</a></p><p>Redux是一种单向数据流架构，可以轻松开发，维护和测试应用程序。在这篇文章中，我向你解释如何在Flutter中使用Redux架构编写移动应用程序。</p><p>Flutter是一项非常有趣的技术。在许多情况下，它被证明无论是对独立开发者还是软件公司来说都非常有用。Google目前正在使用它，所以未来可期。Flutter在考虑快速迭代的同时，它又是开发人员友好的，并且它是多平台的。让我们来看看Flutter的高层级架构，然后转到Redux。</p><a id="more"></a><h2 id="Flutter-widgets"><a href="#Flutter-widgets" class="headerlink" title="Flutter widgets"></a>Flutter widgets</h2><p>在Flutter中，每个UI组件都是一个<a href="https://flutter.io/widgets-intro/#introduction" target="_blank" rel="noopener"><code>Widget</code></a>，您可以使用包含其他多个Widget的多个Widget组合整个应用程序UI，甚至你的应用程序类也是一个Widget。</p><p>widget要么是<code>StatelessWidget</code>,要么是<code>StatefulWidget</code>：</p><h3 id="FLUTTER-STATELESSWIDGET"><a href="#FLUTTER-STATELESSWIDGET" class="headerlink" title="FLUTTER STATELESSWIDGET"></a>FLUTTER STATELESSWIDGET</h3><p><code>statelessWidget</code>是一个非常简单的Widget，它没有任何可变状态，因此需要使用不同的参数重新创建它以显示不同的数据。</p><p>StatelessWidget的一个示例可以是待办事项列表中的一行：此Widget将获取待办事项文本和“完成”标志作为构造函数参数，然后显示它们。更改待办事项文本或完成标志需要你创建另一个StatelessWidget。</p><h3 id="FLUTTER-STATEFULWIDGET"><a href="#FLUTTER-STATEFULWIDGET" class="headerlink" title="FLUTTER STATEFULWIDGET"></a>FLUTTER STATEFULWIDGET</h3><p>在基于某些可变状态构建UI时，StatefulWidget非常有用。在这种情况下，每次状态发生变化时都会重新创建Widget，从而反映其Widget树中的状态更改。除了创建StatelessWidget也具有的Widget树之外，StatefulWidget还必须创建将持有可变状态的State对象。</p><p>StatefulWidget的一个示例是待办事项列表项的容器：此容器列表将扩展StatefulWidget，并且它会创建一个ToDoState。这个ToDoState是待办事项列表所在的地方，以及我们创建Widget树的地方（即ListView）。一旦有用户操作（当添加，删除待办事项等）时，我们将使用State对象中的setState更新列表，这将重建Widget树，显示添加(会删除)条目后的效果。</p><p>这样可以很好地分离那些不会改变的东西。但它也有其缺点：</p><ul><li>当必须在多个页面中共享状态时，它需要位于应用程序Widget中，然后必须将其传递到每个屏幕的Widget树，这个实现需要样板代码。</li><li>当用户操作必须修改共享状态时，多个widget会紧密耦合，因为必须在wodget树中传达操作。</li><li>紧密耦合的widget不可重用，如果你计划对UI进行修改的时候，则可能很难修改widget树。<br>为了抵消和避免这些缺点，我们可以转向Redux。</li></ul><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Redux是一种具有单向数据流的体系结构，可以轻松开发易于测试和维护的应用程序。</p><p><img src="https://blog.novoda.com/content/images/2018/03/redux-architecture-overview.png" alt></p><p>在Redux中有一个Store，它包含一个用于表示整个应用程序的状态的State对象。每个应用程序事件（来自用户或外部）都表示为一个Action，它被分派到Reducer方法。此Reducer根据收到的操作更新Store的状态。每当通过Store推送新状态时，都会重新创建视图以反映更改。</p><p>使用Redux，大多数组件都是分离的，因此UI修改非常容易。此外，唯一的业务逻辑位于Reducer方法中。 Reducer方法是接受Action和当前应用程序状态，并返回一个新的State对象，因此可以直接测试，因为我们可以编写一个单元测试来设置一个初始状态并检查Reducer是否返回新的修改过的的状态。</p><h2 id="Redux-Middleware"><a href="#Redux-Middleware" class="headerlink" title="Redux Middleware"></a>Redux Middleware</h2><p>以上乍一看似乎很简单，但是当应用程序必须执行某些异步操作时会发生什么，例如从外部API加载数据？这就是人们想出一个名为<code>Middleware</code>的新组件的原因。</p><p><code>Middleware</code>是一个可以在Action到达Reducer之前对它进行处理的组件。它接收当前应用程序状态和已发送出来的Action，它可以运行一些代码（通常是<a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" target="_blank" rel="noopener">负效应</a>），例如与第三方API或数据源通信。最后，<code>Middleware</code>可能会决定发送原始动作，发送一个不同的动作，或者不做任何其他动作。你可以在<a href="https://redux.js.org/advanced/middleware" target="_blank" rel="noopener">此处</a>了解有关<code>Middleware</code>的更多信息。</p><p>使用<code>Middleware</code>之后，上面的图表看起会是这样的：</p><p><img src="https://blog.novoda.com/content/images/2018/03/redux-architecture-overview-middleware.png" alt></p><h2 id="Flutter中的Redux"><a href="#Flutter中的Redux" class="headerlink" title="Flutter中的Redux"></a>Flutter中的Redux</h2><p>将所有这些都带到Flutter，我们有着两个非常有用的包，使用这两个包之后，在Flutter应用程序中实现Redux变得非常简单方便：</p><ul><li><a href="https://pub.dartlang.org/packages/redux" target="_blank" rel="noopener"><code>redux</code></a>：<code>redux</code>包添加了在Dart中使用Redux的所有必要组件，即<code>Store</code>，<code>Reducer</code>和<code>Middleware</code>。</li><li><a href="https://pub.dartlang.org/packages/flutter_redux" target="_blank" rel="noopener"><code>flutter_redux</code></a>：这是一个Flutter特有的包，它在redux库之上提供了额外的组件，这些组件对于在Flutter中实现Redux非常有用，例如：<code>StoreProvider</code>（应用程序用来把Store提供给所有那些需要它的widget的基础widget),<code>StoreBuilder</code>(从<code>StoreProvider</code>接收<code>Store</code>的<code>Widget</code>)和<code>StoreConnector</code>（可以用来代替<code>StoreBuilder</code>的非常有用的<code>Widget</code>，因为你可以将<code>Store</code>转换为<code>ViewModel</code>来构建Widget树，每当<code>Store</code>中的状态被修改，<code>StoreConnector</code>将被重建）。</li></ul><h2 id="让我看看代码"><a href="#让我看看代码" class="headerlink" title="让我看看代码"></a>让我看看代码</h2><p>我已经创建了一个基础的待办事项列表应用程序来演示上面讨论的概念。让我们来看看重要的部分。</p><p>首先，main.dart文件（这是我们应用程序的入口点）定义了一个由初始状态，Reducer方法和<code>Middleware</code>组成的应用程序<code>Store</code>对象。然后它使用StoreProvider包装MaterialApp对象，该StoreProvider获取了Store并能够将其传递给需要它的后代Widget：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(ToDoListApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToDoListApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Store&lt;AppState&gt; store = Store&lt;AppState&gt;(</span><br><span class="line">    appReducer, <span class="comment">/* Function defined in the reducers file */</span></span><br><span class="line">    initialState: AppState.initial(),</span><br><span class="line">    middleware: createStoreMiddleware(),</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; StoreProvider(</span><br><span class="line">        store: <span class="keyword">this</span>.store,</span><br><span class="line">        child: MaterialApp(</span><br><span class="line">          <span class="comment">// Omitting some boilerplate here</span></span><br><span class="line">          home: ToDoListPage(title: <span class="string">'Flutter Demo Home Page'</span>),</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppState类包含待办事项列表和一个用来决定是否显示TextField以添加新的条目的字段：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;ToDoItem&gt; toDos;</span><br><span class="line">  <span class="keyword">final</span> ListState listState;</span><br><span class="line"></span><br><span class="line">  AppState(<span class="keyword">this</span>.toDos, <span class="keyword">this</span>.listState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> AppState.initial() =&gt; AppState(<span class="built_in">List</span>.unmodifiable([]), ListState.listOnly);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ListState &#123;</span><br><span class="line">  listOnly, listWithNewItem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了显示待办事项列表，我们定义了一个ViewModel类，它包含我们需要显示的数据的视图特定表示，以及用户可以执行的操作。此ViewModel从Store创建：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ViewModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> pageTitle;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;_ItemViewModel&gt; items;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Function</span> onNewItem;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> newItemToolTip;</span><br><span class="line"></span><br><span class="line">  _ViewModel(<span class="keyword">this</span>.pageTitle, <span class="keyword">this</span>.items, <span class="keyword">this</span>.onNewItem, <span class="keyword">this</span>.newItemToolTip, <span class="keyword">this</span>.newItemIcon);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> _ViewModel.create(Store&lt;AppState&gt; store) &#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;_ItemViewModel&gt; items = store.state.toDos</span><br><span class="line">        .map((ToDoItem item) =&gt; <span class="comment">/* Omitting some boilerplate here */</span>)</span><br><span class="line">        .toList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _ViewModel(<span class="string">'To Do'</span>, items, () =&gt; store.dispatch(DisplayListWithNewItemAction()), <span class="string">'Add new to-do item'</span>, Icons.add);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以使用<code>ViewModel</code>类来显示待办事项列表。请注意，我们将<code>Widgets</code>包装在<code>StoreConnector</code>中，允许我们从<code>Store</code>创建<code>ViewModel</code>并使用<code>ViewModel</code>构建我们的UI：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToDoListPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; StoreConnector&lt;AppState, _ViewModel&gt;(</span><br><span class="line">        converter: (Store&lt;AppState&gt; store) =&gt; _ViewModel.create(store),</span><br><span class="line">        builder: (BuildContext context, _ViewModel viewModel) =&gt; Scaffold(</span><br><span class="line">              appBar: AppBar(</span><br><span class="line">                title: Text(viewModel.pageTitle),</span><br><span class="line">              ),</span><br><span class="line">              body: ListView(children: viewModel.items.map((_ItemViewModel item) =&gt; _createWidget(item)).toList()),</span><br><span class="line">              floatingActionButton: FloatingActionButton(</span><br><span class="line">                onPressed: viewModel.onNewItem,</span><br><span class="line">                tooltip: viewModel.newItemToolTip,</span><br><span class="line">                child: Icon(viewModel.newItemIcon),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义当用户按下“Add”按钮时，我们将发送DisplayListWithNewItemAction类型的动作，这表示我们需要修改应用程序状态，以便我们显示TextField，让用户创建一个新的待办事项条目。动作类定义为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayListWithNewItemAction</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这是针对此操作的Reducer：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AppState appReducer(AppState state, action) =&gt; AppState(toDoListReducer(state.toDos, action), listStateReducer(state.listState, action));</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Reducer&lt;<span class="built_in">List</span>&lt;ToDoItem&gt;&gt; toDoListReducer = <span class="comment">// Boilerplate ignored</span></span><br><span class="line"><span class="keyword">final</span> Reducer&lt;ListState&gt; listStateReducer = combineReducers&lt;ListState&gt;([</span><br><span class="line">  TypedReducer&lt;ListState, DisplayListOnlyAction&gt;(_displayListOnly),</span><br><span class="line">  TypedReducer&lt;ListState, DisplayListWithNewItemAction&gt;(_displayListWithNewItem),</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">ListState _displayListOnly(ListState listState, DisplayListOnlyAction action) =&gt; ListState.listOnly;</span><br><span class="line"></span><br><span class="line">ListState _displayListWithNewItem(ListState listState, DisplayListWithNewItemAction action) =&gt; ListState.listWithNewItem;</span><br></pre></td></tr></table></figure><p>这是一个简单的例子，但演示了上面解释的概念。这个待办事项列表应用程序的完整源代码可以在<a href="https://github.com/xrigau/todo_demo_flutter_redux" target="_blank" rel="noopener">Github</a>中找到。</p><hr><p>总而言之，在Flutter应用程序中使用此体系结构可以使所有关注点明确定义并彼此分离。然而，只在小项目中尝试了这个（由于Flutter仍处于测试阶段），我想看看它是否能在大型项目中很好地扩展，因为整个应用程序有一个状态会让我觉得你会用较小的<code>State</code>对象组成这个<code>State</code>对象。</p><p>在大型项目中使用Redux进行重构，可能按功能（/home，/settings等）在子文件夹中划分Redux组件，虽然我见过的大多数示例是按组件类型划分的子文件夹（/middleware，/actions等）。</p><p>最后不得不提的是，我真的想尝试使用AngularDart构建一个简单的Web前端，甚至可以使用Redux添加桌面支持，然后看看在移动客户端，网站和桌面客户端之间可以重用多少代码。</p><p>感谢您的关注。如果您有任何意见，建议或想讨论，那么请在Twitter上与我交谈💬</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)点击，拖拽以及输入文本</title>
      <link href="/2019/04/20/Flutter/test/Tapping,%20dragging%20and%20entering%20text/"/>
      <url>/2019/04/20/Flutter/test/Tapping,%20dragging%20and%20entering%20text/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/cookbook/testing/widget/tap-drag" target="_blank" rel="noopener">原文链接</a></p><p>我们构建的许多widget不仅显示信息，还要响应用户交互。这包括用户可以点击的按钮，在屏幕上拖动条目或在TextField中输入文本。</p><p>为了测试这些交互，我们需要一种在测试环境中模拟它们的方法。为此，我们可以使用<a href="https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html" target="_blank" rel="noopener">flutter_test</a>库提供的<a href="https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html" target="_blank" rel="noopener">WidgetTester</a>类。</p><p><code>WidgetTester</code>提供了输入文本，点击和拖动的方法。</p><a id="more"></a><ul><li>enterText</li><li>tap</li><li>darg</li></ul><p>在许多情况下，用户交互将更新我们的应用程序的状态。在测试环境中，当状态更改时，Flutter不会自动重建widget。为了确保在模拟用户交互之后重建我们的Widget树，我们必须调用<code>WidgetTester</code>提供的<a href="https://api.flutter.dev/flutter/flutter_test/WidgetTester/pump.html" target="_blank" rel="noopener">pump</a>或<a href="https://api.flutter.dev/flutter/flutter_test/WidgetTester/pumpAndSettle.html" target="_blank" rel="noopener">pumpAndSettle</a>方法。</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><ol><li>创建一个要测试的widget</li><li>在文本字段中输入文本</li><li>确保点击按钮添加待办事项</li><li>确保滑动删除会删除待办事项</li></ol><h2 id="1-创建一个要测试的widget"><a href="#1-创建一个要测试的widget" class="headerlink" title="1.创建一个要测试的widget"></a>1.创建一个要测试的widget</h2><p>对于此示例，我们将创建一个基本的待办事项应用程序。它将有三个我们想要测试的主要功能：</p><ol><li>在TextField中输入文本</li><li>点击FloatingActionButton会将文本添加到待办事项列表中</li><li>滑动删除会从列表中删除该条目</li></ol><p>为了将重点放在测试上，此配方将不提供有关如何构建待办事项应用程序的详细指南。要了解有关如何构建此应用程序的更多信息，请参阅相关配方：</p><ul><li><a href="https://flutter.dev/docs/cookbook/forms/text-input/" target="_blank" rel="noopener">创建文本字段并设置样式</a></li><li><a href="https://flutter.dev/docs/cookbook/gestures/handling-taps/" target="_blank" rel="noopener">处理点击事件</a></li><li><a href="https://flutter.dev/docs/cookbook/lists/basic-list/" target="_blank" rel="noopener">创建一个基本列表</a></li><li><a href="https://flutter.dev/docs/cookbook/gestures/dismissible/" target="_blank" rel="noopener">实现滑动删除</a></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TodoListState createState() =&gt; _TodoListState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TodoListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TodoList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> _appTitle = <span class="string">'Todo List'</span>;</span><br><span class="line">  <span class="keyword">final</span> todos = &lt;<span class="built_in">String</span>&gt;[];</span><br><span class="line">  <span class="keyword">final</span> controller = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: _appTitle,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(_appTitle),</span><br><span class="line">        ),</span><br><span class="line">        body: Column(</span><br><span class="line">          children: [</span><br><span class="line">            TextField(</span><br><span class="line">              controller: controller,</span><br><span class="line">            ),</span><br><span class="line">            Expanded(</span><br><span class="line">              child: ListView.builder(</span><br><span class="line">                itemCount: todos.length,</span><br><span class="line">                itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">                  <span class="keyword">final</span> todo = todos[index];</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">return</span> Dismissible(</span><br><span class="line">                    key: Key(<span class="string">'<span class="subst">$todo</span><span class="subst">$index</span>'</span>),</span><br><span class="line">                    onDismissed: (direction) =&gt; todos.removeAt(index),</span><br><span class="line">                    child: ListTile(title: Text(todo)),</span><br><span class="line">                    background: Container(color: Colors.red),</span><br><span class="line">                  );</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        floatingActionButton: FloatingActionButton(</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            setState(() &#123;</span><br><span class="line">              todos.add(controller.text);</span><br><span class="line">              controller.clear();</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">          child: Icon(Icons.add),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-在text-field中输入文本"><a href="#2-在text-field中输入文本" class="headerlink" title="2.在text field中输入文本"></a>2.在<code>text field</code>中输入文本</h2><p>现在我们有了一个todo应用程序，我们就可以开始编写测试了！在这种情况下，我们首先在<code>TextField</code>中输入文本。</p><p>我们可以通过以下方式完成此任务</p><ol><li>在测试环境中构建Widget</li><li>使用<code>WidgetTester</code>中的<a href="https://api.flutter.dev/flutter/flutter_test/WidgetTester/enterText.html" target="_blank" rel="noopener">enterText</a>方法</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">testWidgets(<span class="string">'Add and remove a todo'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// Build the Widget</span></span><br><span class="line">  <span class="keyword">await</span> tester.pumpWidget(TodoList());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enter 'hi' into the TextField</span></span><br><span class="line">  <span class="keyword">await</span> tester.enterText(find.byType(TextField), <span class="string">'hi'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：此配方基于之前的Widget测试配方。要了解Widget测试的核心概念，请参阅以下配方：</p><ul><li><a href="/flutter/test/2019/04/19/Anintroductiontowidgettesting/">Widget测试简介</a></li><li><a href="/flutter/test/2019/04/19/Finding-widgets/">在widget测试中查找widget</a></li></ul><h2 id="3-确保点击按钮添加待办事项"><a href="#3-确保点击按钮添加待办事项" class="headerlink" title="3.确保点击按钮添加待办事项"></a>3.确保点击按钮添加待办事项</h2><p>在我们将文本输入TextField之后，我们要确保点击FloatingActionButton将该项添加到列表中。</p><p>这将涉及三个步骤：</p><ol><li>使用tap方法点击添加按钮</li><li>使用pump方法更改状态后重建Widget</li><li>确保列表项显示在页面上</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">testWidgets(<span class="string">'Add and remove a todo'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// Enter text code...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tap the add button</span></span><br><span class="line">  <span class="keyword">await</span> tester.tap(find.byType(FloatingActionButton));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Rebuild the Widget after the state has changed</span></span><br><span class="line">  <span class="keyword">await</span> tester.pump();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Expect to find the item on screen</span></span><br><span class="line">  expect(find.text(<span class="string">'hi'</span>), findsOneWidget);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="4-确保滑动删除会删除待办事项"><a href="#4-确保滑动删除会删除待办事项" class="headerlink" title="4. 确保滑动删除会删除待办事项"></a>4. 确保滑动删除会删除待办事项</h2><p>最后，我们可以确保对todo项执行滑动删除操作会将其从列表中删除。这将涉及三个步骤：</p><ul><li>使用<a href="https://api.flutter.dev/flutter/flutter_test/WidgetController/drag.html" target="_blank" rel="noopener">drag</a>方法执行滑动到解除操作。</li><li>使用<a href="https://api.flutter.dev/flutter/flutter_test/WidgetTester/pumpAndSettle.html" target="_blank" rel="noopener">pumpAndSettle</a>方法不断重建我们的Widget树，直到dismiss动画完成。</li><li>确保屏幕上不再显示该条目。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">testWidgets(<span class="string">'Add and remove a todo'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// Enter text and add the item...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Swipe the item to dismiss it</span></span><br><span class="line">  <span class="keyword">await</span> tester.drag(find.byType(Dismissible), Offset(<span class="number">500.0</span>, <span class="number">0.0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Build the Widget until the dismiss animation ends</span></span><br><span class="line">  <span class="keyword">await</span> tester.pumpAndSettle();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure the item is no longer on screen</span></span><br><span class="line">  expect(find.text(<span class="string">'hi'</span>), findsNothing);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>一旦我们完成了这些步骤，我们应该有了带有测试的一个工作的应用程序，其测试部分能确保它正常工作！</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_test/flutter_test.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  testWidgets(<span class="string">'Add and remove a todo'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// Build the Widget</span></span><br><span class="line">    <span class="keyword">await</span> tester.pumpWidget(TodoList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enter 'hi' into the TextField</span></span><br><span class="line">    <span class="keyword">await</span> tester.enterText(find.byType(TextField), <span class="string">'hi'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tap the add button</span></span><br><span class="line">    <span class="keyword">await</span> tester.tap(find.byType(FloatingActionButton));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rebuild the Widget with the new item</span></span><br><span class="line">    <span class="keyword">await</span> tester.pump();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expect to find the item on screen</span></span><br><span class="line">    expect(find.text(<span class="string">'hi'</span>), findsOneWidget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Swipe the item to dismiss it</span></span><br><span class="line">    <span class="keyword">await</span> tester.drag(find.byType(Dismissible), Offset(<span class="number">500.0</span>, <span class="number">0.0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the Widget until the dismiss animation ends</span></span><br><span class="line">    <span class="keyword">await</span> tester.pumpAndSettle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure the item is no longer on screen</span></span><br><span class="line">    expect(find.text(<span class="string">'hi'</span>), findsNothing);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TodoListState createState() =&gt; _TodoListState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TodoListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TodoList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> _appTitle = <span class="string">'Todo List'</span>;</span><br><span class="line">  <span class="keyword">final</span> todos = &lt;<span class="built_in">String</span>&gt;[];</span><br><span class="line">  <span class="keyword">final</span> controller = TextEditingController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: _appTitle,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(_appTitle),</span><br><span class="line">        ),</span><br><span class="line">        body: Column(</span><br><span class="line">          children: [</span><br><span class="line">            TextField(</span><br><span class="line">              controller: controller,</span><br><span class="line">            ),</span><br><span class="line">            Expanded(</span><br><span class="line">              child: ListView.builder(</span><br><span class="line">                itemCount: todos.length,</span><br><span class="line">                itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">                  <span class="keyword">final</span> todo = todos[index];</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">return</span> Dismissible(</span><br><span class="line">                    key: Key(<span class="string">'<span class="subst">$todo</span><span class="subst">$index</span>'</span>),</span><br><span class="line">                    onDismissed: (direction) =&gt; todos.removeAt(index),</span><br><span class="line">                    child: ListTile(title: Text(todo)),</span><br><span class="line">                    background: Container(color: Colors.red),</span><br><span class="line">                  );</span><br><span class="line">                &#125;,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        floatingActionButton: FloatingActionButton(</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            setState(() &#123;</span><br><span class="line">              todos.add(controller.text);</span><br><span class="line">              controller.clear();</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">          child: Icon(Icons.add),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)查找widget</title>
      <link href="/2019/04/19/Flutter/test/Finding%20widgets/"/>
      <url>/2019/04/19/Flutter/test/Finding%20widgets/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/cookbook/testing/widget/finders" target="_blank" rel="noopener">原文链接</a></p><p>为了在测试环境中定位Widget，我们需要使用<code>Finder</code>类。虽然可以编写我们自己的<code>Finder</code>类，但使用<a href="https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html" target="_blank" rel="noopener">flutter_test</a>包提供的工具定位Widgets通常更方便。</p><p>在这个配方中，我们将查看<code>flutter_test</code>包提供的<code>find</code>常量，并演示如何使用它提供的一些Finder。有关可用查找器的完整列表，请参阅<a href="https://api.flutter.dev/flutter/flutter_driver/CommonFinders-class.html" target="_blank" rel="noopener">CommonFinders文档</a>。</p><p>如果您不熟悉Widget测试和<code>Finder</code>类的角色，请查看<a href="/flutter/test/2019/04/19/Anintroductiontowidgettesting/">Widget测试简介</a>。</p><a id="more"></a><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><ol><li>查找一个文本Widget</li><li>查找带有特定key的Widget</li><li>查找一个特定的widget实例</li></ol><h2 id="1-查找一个文本widget"><a href="#1-查找一个文本widget" class="headerlink" title="1.查找一个文本widget"></a>1.查找一个文本widget</h2><p>在我们的测试中，我们经常需要找到包含特定文本的widget。这正是find.text方法的用途。它将创建一个Finder，用于搜索显示特定文本字符串的widget。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">testWidgets(<span class="string">'finds a Text Widget'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// Build an App with a Text Widget that displays the letter 'H'</span></span><br><span class="line">  <span class="keyword">await</span> tester.pumpWidget(MaterialApp(</span><br><span class="line">    home: Scaffold(</span><br><span class="line">      body: Text(<span class="string">'H'</span>),</span><br><span class="line">    ),</span><br><span class="line">  ));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find a Widget that displays the letter 'H'</span></span><br><span class="line">  expect(find.text(<span class="string">'H'</span>), findsOneWidget);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-查找带有特定key的Widget"><a href="#2-查找带有特定key的Widget" class="headerlink" title="2.查找带有特定key的Widget"></a>2.查找带有特定key的Widget</h2><p>在某些情况下，我们可能希望根据已提供给它的Key找到一个Widget。如果我们显示相同Widget的多个实例，这可能很方便。例如，我们可能有一个ListView，它显示包含相同文本的多个Text Widgets。</p><p>在这种情况下，我们可以为列表中的每个Widget提供一个Key。这将允许我们唯一地标识特定的Widget，从而更容易在测试环境中找到Widget。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">testWidgets(<span class="string">'finds a Widget using a Key'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// Define our test key</span></span><br><span class="line">  <span class="keyword">final</span> testKey = Key(<span class="string">'K'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Build a MaterialApp with the testKey</span></span><br><span class="line">  <span class="keyword">await</span> tester.pumpWidget(MaterialApp(key: testKey, home: Container()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find the MaterialApp Widget using the testKey</span></span><br><span class="line">  expect(find.byKey(testKey), findsOneWidget);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-查找一个特定的widget实例"><a href="#3-查找一个特定的widget实例" class="headerlink" title="3.查找一个特定的widget实例"></a>3.查找一个特定的widget实例</h2><p>最后，我们可能对定位特定的Widget实例感兴趣。例如，在创建带有<code>child</code>属性的Widget时候，并且我们想要确保我们渲染了子Widget时，这可能很有用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">testWidgets(<span class="string">'finds a specific instance'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> childWidget = Padding(padding: EdgeInsets.zero);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Provide our childWidget to the Container</span></span><br><span class="line">  <span class="keyword">await</span> tester.pumpWidget(Container(child: childWidget));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search for the childWidget in the tree and verify it exists</span></span><br><span class="line">  expect(find.byWidget(childWidget), findsOneWidget);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>flutter_test</code>包提供的<code>find</code>常量为我们提供了几种在测试环境中定位Widget的方法。该配方展示了这些方法中的三种，并且存在多种用于不同目的的方法中。</p><p>如果上述示例不适用于特定用例，请参阅<a href="https://api.flutter.dev/flutter/flutter_driver/CommonFinders-class.html" target="_blank" rel="noopener">CommonFinders文档</a>以查看所有可用方法。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_test/flutter_test.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  testWidgets(<span class="string">'finds a Text Widget'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// Build an App with a Text Widget that displays the letter 'H'</span></span><br><span class="line">    <span class="keyword">await</span> tester.pumpWidget(MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        body: Text(<span class="string">'H'</span>),</span><br><span class="line">      ),</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a Widget that displays the letter 'H'</span></span><br><span class="line">    expect(find.text(<span class="string">'H'</span>), findsOneWidget);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  testWidgets(<span class="string">'finds a Widget using a Key'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// Define our test key</span></span><br><span class="line">    <span class="keyword">final</span> testKey = Key(<span class="string">'K'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build a MaterialApp with the testKey</span></span><br><span class="line">    <span class="keyword">await</span> tester.pumpWidget(MaterialApp(key: testKey, home: Container()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the MaterialApp Widget using the testKey</span></span><br><span class="line">    expect(find.byKey(testKey), findsOneWidget);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  testWidgets(<span class="string">'finds a specific instance'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> childWidget = Padding(padding: EdgeInsets.zero);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Provide our childWidget to the Container</span></span><br><span class="line">    <span class="keyword">await</span> tester.pumpWidget(Container(child: childWidget));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for the childWidget in the tree and verify it exists</span></span><br><span class="line">    expect(find.byWidget(childWidget), findsOneWidget);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)widget测试简介</title>
      <link href="/2019/04/19/Flutter/test/Anintroductiontowidgettesting/"/>
      <url>/2019/04/19/Flutter/test/Anintroductiontowidgettesting/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/cookbook/testing/widget/introduction" target="_blank" rel="noopener">原文链接</a></p><p>在<a href="/flutter/test/2019/04/19/An-introduction-to-unit-testing">单元测试介绍</a>中,我们学习了如何使用test包测试Dart类。为了测试Widget类，我们需要一些flutter测试包提供的附加工具，它是随FlutterSDK一起提供的。</p><p>flutter_test包提供了以下用于测试widget的工具：</p><ul><li>WidgetTester，它允许我们在测试环境中构建Widgets并与之交互。</li><li>testWidgets方法。此方法将自动为每个测试用例创建一个新的WidgetTester，并用于代替正常的测试功能。</li><li>Finder类。这些类允许我们在测试环境中查找widget。</li><li>特定于 widget Matcher常量，可帮助我们验证Finder是否在测试环境中找到widget或多个widget。</li></ul><a id="more"></a><p>如果这听起来很难对付，请不要担心！我们将在整个配方中看到所有这些零件是如何组合在一起的。</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><ol><li>添加<code>flutter_test</code>依赖项</li><li>创建一个要测试的小部件</li><li>创建一个<code>testWidgets</code>测试</li><li>使用<code>WidgetTester</code>构建Widget</li><li>使用<code>Finder</code>查找我们的小部件</li><li>使用<code>Matcher</code>验证我们的Widget是否正常工作</li></ol><h2 id="1-添加flutter-test依赖"><a href="#1-添加flutter-test依赖" class="headerlink" title="1. 添加flutter_test依赖"></a>1. 添加flutter_test依赖</h2><p>在我们开始编写测试之前，我们需要在pubspec.yaml文件的<code>dev_dependencies</code>部分中包含<code>flutter_test</code>依赖项。如果使用命令行工具或代码编辑器创建新的Flutter项目，则此依赖项应该已经到位！</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line"><span class="attr">  flutter_test:</span></span><br><span class="line"><span class="attr">    sdk:</span> <span class="string">flutter</span></span><br></pre></td></tr></table></figure><h2 id="2-创建一个要测试的Widget"><a href="#2-创建一个要测试的Widget" class="headerlink" title="2.创建一个要测试的Widget"></a>2.创建一个要测试的Widget</h2><p>接下来，我们需要创建一个我们可以测试的Widget！对于这个配方，我们将创建一个显示标题和消息的widget。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> message;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> MyWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.message,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(title),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Text(message),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-创建一个testWidget测试"><a href="#3-创建一个testWidget测试" class="headerlink" title="3.创建一个testWidget测试"></a>3.创建一个testWidget测试</h2><p>现在我们有一个Widget来测试，我们可以开始编写我们的第一个测试了！首先，我们将使用flutter_test包提供的testWidgets方法来定义测试。 testWidgets方法将允许我们定义一个Widget测试，并将创建一个WidgetTester供我们使用。</p><p>我们的测试将验证MyWidget是否显示给定的标题和消息。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// Define a test. The TestWidgets function will also provide a WidgetTester</span></span><br><span class="line">  <span class="comment">// for us to work with. The WidgetTester will allow us to build and interact</span></span><br><span class="line">  <span class="comment">// with Widgets in the test environment.</span></span><br><span class="line">  testWidgets(<span class="string">'MyWidget has a title and message'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// Test code will go here!</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-使用WidgetTester构建Widget"><a href="#4-使用WidgetTester构建Widget" class="headerlink" title="4.使用WidgetTester构建Widget"></a>4.使用WidgetTester构建Widget</h2><p>接下来，我们将要在测试环境中构建MyWidget。为此，我们可以使用WidgetTester提供的pumpWidget方法。 pumpWidget方法将构建并渲染我们提供的Widget。</p><p>在这种情况下，我们将创建一个MyWidget实例，将“T”显示为标题，将“M”显示为消息。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  testWidgets(<span class="string">'MyWidget has a title and message'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// Create the Widget tell the tester to build it</span></span><br><span class="line">    <span class="keyword">await</span> tester.pumpWidget(MyWidget(title: <span class="string">'T'</span>, message: <span class="string">'M'</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<br>在初始调用<code>pumpWidget</code>之后，<code>WidgetTester</code>提供了重建相同Widget的其他方法。如果您正在使用StatefulWidget或动画，这将非常有用。</p><p>例如，如果我们点击一​​个按钮，并且此按钮调用setState，Flutter将不会在测试环境中自动重建您的Widget。我们需要使用以下方法之一来让Flutter再次构建我们的Widget。</p><ul><li>tester.pump（）<br>在给定的持续时间后触发Widget的重建。</li><li>tester.pumpAndSettle（）<br>在给定的持续时间内反复呼叫泵，直到不再安排任何帧。这基本上要等待所有动画完成。</li></ul><p>这些方法提供了对构建生命周期的细粒度控制，这在测试时特别有用。</p><h2 id="5-使用Finder查找我的Widget"><a href="#5-使用Finder查找我的Widget" class="headerlink" title="5.使用Finder查找我的Widget"></a>5.使用<code>Finder</code>查找我的Widget</h2><p>现在我们已经在测试环境中构建了Widget，我们想要使用Finder在Widget树中查找标题和消息Text Widgets。这将允许我们验证我们是否正确显示这些widget！</p><p>在这种情况下，我们将使用flutter_test包提供的顶级find方法来创建Finders。由于我们知道我们正在查找Textwidget，我们可以使用find.text方法。</p><p>有关Finder类的更多信息，请参阅<a href="https://flutter.dev/docs/cookbook/testing/widget/finders" target="_blank" rel="noopener">widget测试配方中的查找widget</a>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  testWidgets(<span class="string">'MyWidget has a title and message'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> tester.pumpWidget(MyWidget(title: <span class="string">'T'</span>, message: <span class="string">'M'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create our Finders</span></span><br><span class="line">    <span class="keyword">final</span> titleFinder = find.text(<span class="string">'T'</span>);</span><br><span class="line">    <span class="keyword">final</span> messageFinder = find.text(<span class="string">'M'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-使用Matcher验证我们的Widget是否正常工作"><a href="#6-使用Matcher验证我们的Widget是否正常工作" class="headerlink" title="6. 使用Matcher验证我们的Widget是否正常工作"></a>6. 使用Matcher验证我们的Widget是否正常工作</h2><p>最后，我们可以使用flutter_test提供的Matcher常量验证标题和消息Text Widgets在屏幕上显示。 Matcher类是测试包的核心部分，并提供了一种通用方法来验证给定值是否符合我们的期望。</p><p>在这种情况下，我们希望确保我们的widget只出现在屏幕上一次。因此，我们可以使用findsOneWidget Matcher。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  testWidgets(<span class="string">'MyWidget has a title and message'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> tester.pumpWidget(MyWidget(title: <span class="string">'T'</span>, message: <span class="string">'M'</span>));</span><br><span class="line">    <span class="keyword">final</span> titleFinder = find.text(<span class="string">'T'</span>);</span><br><span class="line">    <span class="keyword">final</span> messageFinder = find.text(<span class="string">'M'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the `findsOneWidget` matcher provided by flutter_test to verify our</span></span><br><span class="line">    <span class="comment">// Text Widgets appear exactly once in the Widget tree</span></span><br><span class="line">    expect(titleFinder, findsOneWidget);</span><br><span class="line">    expect(messageFinder, findsOneWidget);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他Matcher"><a href="#其他Matcher" class="headerlink" title="其他Matcher"></a>其他Matcher</h2><p>除了findsOneWidget之外，flutter_test还为常见案例提供了其他的Matcher。</p><ul><li>findsNothing<br>验证没有找到Widgets</li><li>findsWidgets<br>验证是否找到一个或多个小部件</li><li>findsNWidgets<br>验证是否找到特定数量的小部件</li></ul><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_test/flutter_test.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// Define a test. The TestWidgets function will also provide a WidgetTester</span></span><br><span class="line">  <span class="comment">// for us to work with. The WidgetTester will allow us to build and interact</span></span><br><span class="line">  <span class="comment">// with Widgets in the test environment.</span></span><br><span class="line">  testWidgets(<span class="string">'MyWidget has a title and message'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// Create the Widget tell the tester to build it</span></span><br><span class="line">    <span class="keyword">await</span> tester.pumpWidget(MyWidget(title: <span class="string">'T'</span>, message: <span class="string">'M'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create our Finders</span></span><br><span class="line">    <span class="keyword">final</span> titleFinder = find.text(<span class="string">'T'</span>);</span><br><span class="line">    <span class="keyword">final</span> messageFinder = find.text(<span class="string">'M'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the `findsOneWidget` matcher provided by flutter_test to verify our</span></span><br><span class="line">    <span class="comment">// Text Widgets appear exactly once in the Widget tree</span></span><br><span class="line">    expect(titleFinder, findsOneWidget);</span><br><span class="line">    expect(messageFinder, findsOneWidget);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> message;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> MyWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.message,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(title),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: Text(message),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)使用Mockito模拟外部依赖</title>
      <link href="/2019/04/19/Flutter/test/MockdependenciesusingMockito/"/>
      <url>/2019/04/19/Flutter/test/MockdependenciesusingMockito/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/cookbook/testing/unit/mocking" target="_blank" rel="noopener">原文链接</a></p><p>在某些情况下，单元测试可能依赖于从实时Web服务或数据库获取数据的类。<br>这是很不方便的，以下给出了几个原因：</p><ul><li>调用实时服务或数据库会降低测试执行速度。</li><li>如果Web服务或数据库返回意外结果，则目前的测试可能会失败。这被称为“薄片测试”。</li><li>使用实时Web服务或数据库很难测试所有可能的成功和失败场景。</li></ul><p>因此，您可以“模拟”这些外部依赖，而不是依赖于实时Web服务或数据库。模拟允许我们模拟实时Web服务或数据库，并根据情况返回特定结果。</p><p>一般来说，您可以通过创建类的替代实现来模拟依赖项。您可以手动编写这些替代实现，也可以使用<a href="https://pub.dartlang.org/packages/mockito" target="_blank" rel="noopener">Mockito包</a>作为快捷方式。</p><p>本文演示了使用Mockito软件包进行模拟的基础知识。有关详细信息，请参阅<a href="https://pub.dartlang.org/packages/mockito" target="_blank" rel="noopener">Mockito软件包文档</a>。</p><a id="more"></a><h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><ol><li>添加<code>mockito</code>以及<code>test</code>依赖</li><li>创建一个用来测试的方法</li><li>创建一个带有模拟<code>http.Client</code>的test文件</li><li>为每种情况写一个test</li><li>运行测试</li></ol><h2 id="1-添加mockito依赖"><a href="#1-添加mockito依赖" class="headerlink" title="1.添加mockito依赖"></a>1.添加mockito依赖</h2><p>要使用<code>mockito</code>包，首先需要将其与dev_dependencies部分中的flutter_test依赖项一起添加到<code>pubspec.yaml</code>文件中。</p><p>您还将在此示例中使用<code>http</code>包，并将在dependencies部分中定义该依赖项。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  http:</span> <span class="string">&lt;newest_version&gt;</span></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line"><span class="attr">  test:</span> <span class="string">&lt;newest_version&gt;</span></span><br><span class="line"><span class="attr">  mockito:</span> <span class="string">&lt;newest_version&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-创建一个用来测试的方法"><a href="#2-创建一个用来测试的方法" class="headerlink" title="2.创建一个用来测试的方法"></a>2.创建一个用来测试的方法</h2><p>在此示例中，您将需要从Internet配方的Fetch数据中对fetchPost函数进行单元测试。要测试此功能，您需要进行两项更改：</p><ol><li>为方法提供http.Client。这允许您基于不同情况提供正确的http.Client。对于Flutter和服务器端的项目，您可以提供http.IOClient。对于浏览器应用程序，您可以提供http.BrowserClient。对于测试，您提供模拟的http.Client。</li><li>使用提供的客户端从Internet获取数据，而不是静态的http.get方法，因为这很难模拟。</li></ol><p>该方法现在应该如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Post&gt; fetchPost(http.Client client) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> response =</span><br><span class="line">      <span class="keyword">await</span> client.<span class="keyword">get</span>(<span class="string">'https://jsonplaceholder.typicode.com/posts/1'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// If the call to the server was successful, parse the JSON</span></span><br><span class="line">    <span class="keyword">return</span> Post.fromJson(json.decode(response.body));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If that call was not successful, throw an error.</span></span><br><span class="line">    <span class="keyword">throw</span> Exception(<span class="string">'Failed to load post'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-创建一个带有模拟的http-client的测试文件"><a href="#3-创建一个带有模拟的http-client的测试文件" class="headerlink" title="3.创建一个带有模拟的http.client的测试文件"></a>3.创建一个带有模拟的<code>http.client</code>的测试文件</h2><p>接下来，创建一个测试文件以及<code>MockClient</code>类。按照<a href="/flutter/test/2019/04/19/An-introduction-to-unit-testing.html">单元测试配方简介中</a>的建议，在根<code>test</code>文件夹中创建一个名为<code>fetch_post_test.dart</code>的文件。</p><p>MockClient类实现<code>http.Client</code>类。这允许您将<code>MockClient</code>传递给<code>fetchPost</code>函数，并允许您在每个测试中返回不同的http响应。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a MockClient using the Mock class provided by the Mockito package.</span></span><br><span class="line"><span class="comment">// Create new instances of this class in each test.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockClient</span> <span class="keyword">extends</span> <span class="title">Mock</span> <span class="keyword">implements</span> <span class="title">http</span>.<span class="title">Client</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">// Tests go here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-为每种情况写一个test"><a href="#4-为每种情况写一个test" class="headerlink" title="4.为每种情况写一个test"></a>4.为每种情况写一个test</h2><p>如果你考虑下fetchPost函数，它将做两件事中的一件：</p><ol><li>如果http调用成功，则返回一个<code>Post</code></li><li>如果http调用失败，则抛出异常</li></ol><p>因此，你需要针对这两种情况进行测试。您可以使用MockClient类为成功测试返回“Ok”响应，并为不成功的测试返回错误响应。</p><p>为此，请使用Mockito提供的when方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a MockClient using the Mock class provided by the Mockito package.</span></span><br><span class="line"><span class="comment">// Create new instances of this class in each test.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockClient</span> <span class="keyword">extends</span> <span class="title">Mock</span> <span class="keyword">implements</span> <span class="title">http</span>.<span class="title">Client</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  group(<span class="string">'fetchPost'</span>, () &#123;</span><br><span class="line">    test(<span class="string">'returns a Post if the http call completes successfully'</span>, () <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> client = MockClient();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Use Mockito to return a successful response when it calls the</span></span><br><span class="line">      <span class="comment">// provided http.Client.</span></span><br><span class="line">      when(client.<span class="keyword">get</span>(<span class="string">'https://jsonplaceholder.typicode.com/posts/1'</span>))</span><br><span class="line">          .thenAnswer((_) <span class="keyword">async</span> =&gt; http.Response(<span class="string">'&#123;"title": "Test"&#125;'</span>, <span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">      expect(<span class="keyword">await</span> fetchPost(client), isInstanceOf&lt;Post&gt;());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    test(<span class="string">'throws an exception if the http call completes with an error'</span>, () &#123;</span><br><span class="line">      <span class="keyword">final</span> client = MockClient();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Use Mockito to return an unsuccessful response when it calls the</span></span><br><span class="line">      <span class="comment">// provided http.Client.</span></span><br><span class="line">      when(client.<span class="keyword">get</span>(<span class="string">'https://jsonplaceholder.typicode.com/posts/1'</span>))</span><br><span class="line">          .thenAnswer((_) <span class="keyword">async</span> =&gt; http.Response(<span class="string">'Not Found'</span>, <span class="number">404</span>));</span><br><span class="line"></span><br><span class="line">      expect(fetchPost(client), throwsException);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-运行测试"><a href="#5-运行测试" class="headerlink" title="5.运行测试"></a>5.运行测试</h2><p>现在你的fetchPost()方法和测试都就位了，运行测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dart test/fetch_post_test.dart</span><br></pre></td></tr></table></figure><p>您还可以按照<a href="/flutter/test/2019/04/19/An-introduction-to-unit-testing.html">单元测试配方简介</a>中的说明的那样，在你喜欢的编辑器中运行测试。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在此示例中，您已经学习了如何使用Mockito来测试依赖于Web服务或数据库的函数或类。这只是对Mockito库和模拟概念的简短介绍。有关更多信息，请参阅<a href="https://pub.dartlang.org/packages/mockito" target="_blank" rel="noopener">Mockito包</a>提供的文档。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)单元测试介绍</title>
      <link href="/2019/04/19/Flutter/test/An%20introduction%20to%20unit%20testing/"/>
      <url>/2019/04/19/Flutter/test/An%20introduction%20to%20unit%20testing/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/cookbook/testing/unit/introduction" target="_blank" rel="noopener">原文链接</a></p><p>如何确保在添加更多功能或更改现有功能时，应用程序继续正常工作？通过编写测试。</p><p>单元测试可以方便地验证单个函数，方法或类的行为。<a href="https://pub.dartlang.org/packages/test" target="_blank" rel="noopener">test</a>包提供了编写单元测试的核心框架，<a href="https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html" target="_blank" rel="noopener">flutter_test</a>包提供了用于测试Widgets的其他实用工具。</p><p>此方法演示了<code>test</code>包提供的核心功能。有关test包的更多信息，请参阅<a href="https://github.com/dart-lang/test/blob/master/README.md" target="_blank" rel="noopener">test包文档</a>。</p><a id="more"></a><h2 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h2><p>1.添加test或flutter_test依赖项</p><p>2.创建一个测试文件</p><p>3.创建一个要测试的类</p><p>4.为我们的类写一个测试</p><p>5.在一个组中组合多个测试</p><p>6.运行测试</p><h2 id="1-添加测试依赖"><a href="#1-添加测试依赖" class="headerlink" title="1. 添加测试依赖"></a>1. 添加测试依赖</h2><p>如果您正在处理不依赖于Flutter的Dart包，则可以导入测试包。测试包提供了在Dart中编写测试的核心功能。在编写将由Web，服务器和Flutter应用程序使用的包时，这是最好的方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dev_dependencies:</span><br><span class="line">  test: &lt;latest_version&gt;</span><br></pre></td></tr></table></figure><h2 id="2-创建一个测试文件"><a href="#2-创建一个测试文件" class="headerlink" title="2.创建一个测试文件"></a>2.创建一个测试文件</h2><p>在此示例中，创建两个文件：<code>counter.dart</code>和<code>counter_test.dart</code>。</p><p><code>counter.dart</code>文件将包含您要测试的类，并归属于lib文件夹。<code>counter_test.dart</code>文件将包含多个测试并存在于<code>test</code>文件夹中。</p><p>通常，测试文件应该归属于于Flutter应用程序或程序包根目录的test文件夹中。</p><p>完成后，文件夹结构应如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">counter_app/</span></span><br><span class="line">  <span class="string">lib/</span></span><br><span class="line">    <span class="string">counter.dart</span></span><br><span class="line">  <span class="string">test/</span></span><br><span class="line">    <span class="string">counter_test.dart</span></span><br></pre></td></tr></table></figure><h2 id="3-创建一个类来对它进行测试"><a href="#3-创建一个类来对它进行测试" class="headerlink" title="3. 创建一个类来对它进行测试"></a>3. 创建一个类来对它进行测试</h2><p>接下来，您需要一个“单位”来测试。请记住：“unit”是函数，方法或类的设想名称。在此示例中，在lib/counter.dart文件中创建Counter类。它将负责递增和递减从0开始的值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> increment() =&gt; value++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> decrement() =&gt; value--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：为简单起见，本教程不遵循“测试驱动开发”方法。如果你对这种开发方式更加满意，你可以随时走这条路。</p><h2 id="4-为我们的类写一个测试"><a href="#4-为我们的类写一个测试" class="headerlink" title="4. 为我们的类写一个测试"></a>4. 为我们的类写一个测试</h2><p>在counter_test.dart文件中，编写第一个单元测试。测试是由顶级测试功能定义的，您可以使用顶级expect功能检查结果是否正确。这两个功能都来自<code>test</code>包。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Import the test package and Counter class</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:test/test.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:counter_app/counter.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  test(<span class="string">'Counter value should be incremented'</span>, () &#123;</span><br><span class="line">    <span class="keyword">final</span> counter = Counter();</span><br><span class="line"></span><br><span class="line">    counter.increment();</span><br><span class="line"></span><br><span class="line">    expect(counter.value, <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-在一个组中组合多个测试"><a href="#5-在一个组中组合多个测试" class="headerlink" title="5. 在一个组中组合多个测试"></a>5. 在一个组中组合多个测试</h2><p>如果您有多个彼此相关的测试，请使用<code>test</code>包提供的组功能将它们组合在一起。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:test/test.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:counter_app/counter.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  group(<span class="string">'Counter'</span>, () &#123;</span><br><span class="line">    test(<span class="string">'value should start at 0'</span>, () &#123;</span><br><span class="line">      expect(Counter().value, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    test(<span class="string">'value should be incremented'</span>, () &#123;</span><br><span class="line">      <span class="keyword">final</span> counter = Counter();</span><br><span class="line"></span><br><span class="line">      counter.increment();</span><br><span class="line"></span><br><span class="line">      expect(counter.value, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    test(<span class="string">'value should be decremented'</span>, () &#123;</span><br><span class="line">      <span class="keyword">final</span> counter = Counter();</span><br><span class="line"></span><br><span class="line">      counter.decrement();</span><br><span class="line"></span><br><span class="line">      expect(counter.value, <span class="number">-1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-运行测试"><a href="#6-运行测试" class="headerlink" title="6.运行测试"></a>6.运行测试</h2><p>现在Counter类和test已经就位了，你可以运行测试了。</p><h3 id="使用IntelliJ或VSCode运行测试"><a href="#使用IntelliJ或VSCode运行测试" class="headerlink" title="使用IntelliJ或VSCode运行测试"></a>使用IntelliJ或VSCode运行测试</h3><p>IntelliJ和VSCode的Flutter插件支持运行测试。这通常是编写测试时的最佳选择，因为它提供了最快的反馈循环以及设置断点的能力。</p><ul><li>IntelliJ</li></ul><ol><li>打开<code>counter_test.dart</code>文件</li><li>选择<code>Run</code>菜单</li><li>单击<code>Run&#39;test in counter_test.dart&#39;</code>选项</li><li>或者，针对你的平台使用适当的快捷键。</li></ol><ul><li>VSCode</li></ul><ol><li>打开<code>counter_test.dart</code>文件</li><li>选择<code>Debug</code>菜单</li><li>单击<code>start Debugging</code>选项</li><li>或者，针对你的平台使用适当的快捷键。</li></ol><h3 id="在终端中运行测试"><a href="#在终端中运行测试" class="headerlink" title="在终端中运行测试"></a>在终端中运行测试</h3><p>您还可以使用终端通过从项目的根目录执行以下命令来运行测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter test test/counter_test.dart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)你可能不需要Redux：Flutter版</title>
      <link href="/2019/04/18/Flutter/development/data-and-backend/state-mgmt/options/InheritedWidget-Scopedmodel/YouMightNotNeedReduxThe%20FlutterEdition/"/>
      <url>/2019/04/18/Flutter/development/data-and-backend/state-mgmt/options/InheritedWidget-Scopedmodel/YouMightNotNeedReduxThe%20FlutterEdition/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/800/1*D1hjP93cVtw5v2x-4rpztw.png" alt></p><p>长话短说：SetState-&gt;<a href="https://pub.dartlang.org/packages/scoped_model" target="_blank" rel="noopener">scoped_model</a>-&gt;<a href="https://pub.dartlang.org/packages/redux" target="_blank" rel="noopener">redux</a>.</p><p>如果你是从事移动开发相关工作的，你可能听过<a href="https://flutter.io/" target="_blank" rel="noopener">Flutter</a>这个小玩意。这是一个非常棒的移动UI框架，您无法想象应用程序开发可以犹如游戏开发，运行时随应用程序一起提供，可以在不放弃性能的情况下实现完全可定制的体验。</p><a id="more"></a><p>当你研究如何使用Flutter构建应用的时候，你可能遇到<code>setState</code>和<code>redux</code>这两种最流行的管理应用状态的模式。虽然它们彼此都有一席之地，但是<code>setState</code>的简易性和<code>redux</code>的灵活性之间存在着鸿沟。</p><h2 id="setState有什么问题？"><a href="#setState有什么问题？" class="headerlink" title="setState有什么问题？"></a>setState有什么问题？</h2><p>要清楚，使用setState没有任何问题。这种更新小部件状态的方法是Flutter和React最强大的功能之一。您可以在此处阅读有关如何使用自上而下的数据流有效管理React应用程序中的状态的信息。该模式同样适用于Flutter。</p><p>也就是说，如果你熟悉React，那么你就会遇到“螺旋钻”的痛苦。对于初学者来说，这是通过不关心数据的组件传递道具的过程，这样您就可以将它发送给那些关心的组件。重构组件时，问题被放大，使维护成为一场噩梦，并且您还可能通过为一个窗口小部件重新呈现窗口小部件树的部分而体验性能下降。</p><h2 id="Redux有什么问题"><a href="#Redux有什么问题" class="headerlink" title="Redux有什么问题?"></a>Redux有什么问题?</h2><p>与setState一样，redux没有任何问题。这是一个完美的模式，可以根据需要管理应用程序的状态。</p><p>也就是说，使用redux并非没有缺点，其主要原因是它可能没有必要时增加的复杂性。作为好公民，我们</p><p>不应该过度优化。</p><p>不应该使用模式或库，因为它们很受欢迎。</p><p>Redux，无论它对于前端开发有多么棒，也不例外。</p><p>##在状态管理上获取setState般的简易性</p><p>作为React的重要支持者，我非常喜欢社区中库日益增长的趋势，他们利用其新的Context API在状态管理中获得了一席之地。在搜索类似的模式时，我遇到了scoped_model。</p><p>如果您对在flutter应用程序中管理状态感兴趣，我强烈建议您使用Scoped Models。<br>请注意，目前这不是在flutter应用程序中管理状态的“常规”方式，但我们发现它非常有用。<br>就个人而言，我认为你应该尽可能少地使用StatefulWidgets。 Scoped Models非常有用。</p><p>就像<a href="https://github.com/jamiebuilds/unstated" target="_blank" rel="noopener">unstated</a>利用React和上下文中已存在的模式一样，scoped_model构建在您已经熟悉的模式上（如果使用setState）。</p><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>scoped_model是基于三个主要的概念：</p><h3 id="1-model"><a href="#1-model" class="headerlink" title="1.model"></a>1.model</h3><p>从概念上讲，Model与redux store 非常相似。它是一个类似于widget的类，只包含与状态相关的部分。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*R1Dw1D5iEf_XB1cILeQG6A.png" alt><br>扩展Model的CounterModel</p><h3 id="2-ScopedModel"><a href="#2-ScopedModel" class="headerlink" title="2.ScopedModel"></a>2.ScopedModel</h3><p>ScopedModel包含状态模型，将其提供给请求它的所有widget。这类似于unstated的Provider。<br><img src="https://cdn-images-1.medium.com/max/800/1*TKhNRYBHTSE1VDJtqi0Hmw.png" alt><br>在应用顶层创建ScopedModel</p><h3 id="3-ScopedModelDescendant"><a href="#3-ScopedModelDescendant" class="headerlink" title="3. ScopedModelDescendant"></a>3. ScopedModelDescendant</h3><p>ScopedModelDescendant小部件允许您将状态从Model传递到窗口小部件。状态更改将触发重新呈现，您可以在模型上调用方法。这与unstated的Subscribe组件非常相似。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*gDBbNOWQ4-crhkySIFETxw.png" alt><br>ScopedModelDescendant接受传入模型的build()函数。</p><h3 id="添加多个Container到widget"><a href="#添加多个Container到widget" class="headerlink" title="添加多个Container到widget"></a>添加多个Container到widget</h3><p>在查看API之后，我遇到的第一个问题是如何向widget添加多个模型？</p><p>使用mixins这是相当简单的。让我们重写前面的例子，增加递减和重置计数的能力：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*LZAdc8a3pl1wyL80-hyGrg.png" alt><br>然后，我们可以在应用程序的根下用MainModel替换我们的CounterModel创建<br><img src="https://cdn-images-1.medium.com/max/800/1*oymne0NLUoZk8VFIPsBVsQ.png" alt><br>将CounterModel替换为MainModel</p><p>最后，我们可以使用多个模型完成我们的示例<br><img src="https://cdn-images-1.medium.com/max/800/1*5B58dyaB_6jwDd19v_nsoQ.png" alt></p><p>build()方法可以访问所有MainModel道具</p><p>你可能在想</p><p>为什么他不把所有这些方法放在一起形成一个逻辑模型？<br>你的评估是正确的，这个例子分离没有多大意义。将此视为更多的能力演示。</p><p>实际上，您应该组合代表不同类型状态的模型（CounterState，AuthState，ProfileState等）。</p><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><p>由于模型的简单性，异步操作变成了贪睡的盛会。一旦状态改变，触发notifyListeners基本上就像setState一样运行。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本文开头，我提到使用setState或redux进行状态管理没有任何问题，我想重申这一说法。本文更多的是关于填补两者之间空白而作出的努力。</p><p>类似于React中状态管理演变的unstated，scoped_model是Flutter中的演变。与unstated一样，它降低了复杂性并保持在Flutter的范围内。</p><p>在考虑状态管理时，scoped_model值得与setState和redux放在一起，特别是当你需要比setState更强大但又不需要太厚重的时候。</p><p>如果您想查看本文的完整工作演示，可以在此处找到<a href="https://github.com/chimon2000/hello_scoped_model" target="_blank" rel="noopener">它</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
            <tag> ScopedModel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)高效地使用Inherited widget</title>
      <link href="/2019/04/18/Flutter/development/data-and-backend/state-mgmt/options/InheritedWidget-Scopedmodel/Using%20Flutter%20Inherited%20Widgets%20Effectively/"/>
      <url>/2019/04/18/Flutter/development/data-and-backend/state-mgmt/options/InheritedWidget-Scopedmodel/Using%20Flutter%20Inherited%20Widgets%20Effectively/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ericwindmill.com/posts/inherited_widget/" target="_blank" rel="noopener">原文链接</a></p><p>如果你之前就使用过Flutter,你可能遇到过随处可见的不同类的<code>of</code>方法：</p><a id="more"></a><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Theme.of(context).textTheme</span><br><span class="line">MediaQuery.of(context).size</span><br></pre></td></tr></table></figure><p>这些widget(Theme,MediaQ)是<code>Inherited widget</code>。在你应用中几乎所有地方，你都可以访问你的主题，因为它们是继承而来的。</p><p>在Flutter中，sdk的每个部分都是暴露给开发者的，所以你自己可以利用<code>Inherited widget</code>。 你可以把自定义的InheritedWidget作为内置的中央状态存储，与Redux仓库或Vue的Vuex仓库类似。</p><p>当你建立了好像这样的仓库之后，你将能够做到像这样的事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class RedText extends StatelessWidget &#123;</span><br><span class="line">  // ...</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    var state = StateContainer.of(context).state;</span><br><span class="line">    return new Text(</span><br><span class="line">      state.user.username,</span><br><span class="line">      style: const TextStyle(color: Colors.red),</span><br><span class="line">    );</span><br><span class="line">  // ...</span><br></pre></td></tr></table></figure><h2 id="把状态向上抬"><a href="#把状态向上抬" class="headerlink" title="把状态向上抬"></a>把状态向上抬</h2><p>当你使用一个<code>Inherited widget</code>作为你的状态管理工具，你可能要依赖于叫做<code>把状态向上抬</code>架构模式。</p><p>考虑下当你新建一个项目时生成的入门Flutter应用。如果你想要把应用分成两个页面，一个展示数字，一个允许你对数字进行更改。突然之间，这个简单的应用就变得令人困惑了。每当变更路由的时候，你需要把这个状态片传过来传传去。</p><p><code>Inherited widget</code>通过让整个widget树能访问相同的状态片来解决这个问题。</p><p><img src="http://res.cloudinary.com/ericwindmill/image/upload/v1518974500/flutter_by_example/medium_tree.png" alt></p><p>有关不同Flutter架构概念的超级精彩详细解释,请看<a href="https://www.youtube.com/watch?v=zKXz3pUkw9A&t=1467s" target="_blank" rel="noopener">Brain Egan在 DartConf2018中的演讲</a>。只是不要看太多，不然你就会被被说服去使用flutter_redux，然后你就一点都不关心这篇文章了。</p><p>把状态向上抬来这种模式相较于Redux之类的优势是，使用Inherited Widget的设置和使用非常简单。</p><p>注意：毫无疑问，我是Redux、Vuex以及所有‘ux’之类的东西的粉丝。这只是你工具箱的另一件工具，毕竟杀鸡焉用牛刀。</p><h2 id="何必呢"><a href="#何必呢" class="headerlink" title="何必呢?"></a>何必呢?</h2><p>此时，您可能会问为什么要使用InheritedWidget。为什么不仅仅应用程序根那里架<code>stateful widget</code>呢？</p><p>对没错，这就是这里接下来要做的。<code>InheritedWidget</code>与<code>stateful widget</code>一起使用，并允许您将StatefulWidgets的状态传递给其所有祖先。它是一个实用的widget。因此，您不必在每个类中都写上代码才能把状态传递给其后代。</p><h2 id="建立一个样板应用"><a href="#建立一个样板应用" class="headerlink" title="建立一个样板应用"></a>建立一个样板应用</h2><p>关于这个例子，让我创建一个简单的应用：<br><img src="http://res.cloudinary.com/ericwindmill/image/upload/v1523742041/blog_posts/inherited_test.gif" alt></p><p>基本上这个应用程序的状态被抬到根Widget之上，当你提交表单时，它会在该<code>inherited widget</code>上调用<code>setState</code>，这个步骤会告诉主页面有新的信息要渲染。</p><h2 id="1-Material-App-根目录"><a href="#1-Material-App-根目录" class="headerlink" title="1.Material App 根目录"></a>1.Material App 根目录</h2><p>这只是您标准的Flutter应用程序设置部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  runApp(new UserApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class UserApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new MaterialApp(</span><br><span class="line">      home: new HomeScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-HomeScreen-Widget"><a href="#2-HomeScreen-Widget" class="headerlink" title="2 HomeScreen Widget"></a>2 HomeScreen Widget</h2><p>现在这也是非常基本的。这只是当好东西要来的时候你要遵从的样板</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  HomeScreenState createState() =&gt; <span class="keyword">new</span> HomeScreenState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomeScreen</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  Widget <span class="keyword">get</span> _logInPrompt &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Center(</span><br><span class="line">      child: <span class="keyword">new</span> Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="keyword">new</span> Text(</span><br><span class="line">            <span class="string">'Please add user information'</span>,</span><br><span class="line">            style: <span class="keyword">const</span> TextStyle(fontSize: <span class="number">18.0</span>),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// All this method does is bring up the form page.</span></span><br><span class="line">  <span class="keyword">void</span> _updateUser(BuildContext context) &#123;</span><br><span class="line">    Navigator.push(</span><br><span class="line">      context,</span><br><span class="line">      <span class="keyword">new</span> MaterialPageRoute(</span><br><span class="line">        fullscreenDialog: <span class="keyword">true</span>,</span><br><span class="line">        builder: (context) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UpdateUserScreen();</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        title: <span class="keyword">new</span> Text(<span class="string">'Inherited Widget Test'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: _logInPrompt,</span><br><span class="line">      floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">        onPressed: () =&gt; _updateUser(context),</span><br><span class="line">        child: <span class="keyword">new</span> Icon(Icons.edit),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-最后，目前没有做任何事情的表单页面"><a href="#3-最后，目前没有做任何事情的表单页面" class="headerlink" title="3.最后，目前没有做任何事情的表单页面"></a>3.最后，目前没有做任何事情的表单页面</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateUserScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> GlobalKey&lt;FormState&gt; formKey = <span class="keyword">new</span> GlobalKey&lt;FormState&gt;();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> GlobalKey&lt;FormFieldState&lt;<span class="built_in">String</span>&gt;&gt; firstNameKey =</span><br><span class="line">  <span class="keyword">new</span> GlobalKey&lt;FormFieldState&lt;<span class="built_in">String</span>&gt;&gt;();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> GlobalKey&lt;FormFieldState&lt;<span class="built_in">String</span>&gt;&gt; lastNameKey =</span><br><span class="line">  <span class="keyword">new</span> GlobalKey&lt;FormFieldState&lt;<span class="built_in">String</span>&gt;&gt;();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> GlobalKey&lt;FormFieldState&lt;<span class="built_in">String</span>&gt;&gt; emailKey =</span><br><span class="line">  <span class="keyword">new</span> GlobalKey&lt;FormFieldState&lt;<span class="built_in">String</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> UpdateUserScreen(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        title: <span class="keyword">new</span> Text(<span class="string">'Edit User Info'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: <span class="keyword">new</span> Padding(</span><br><span class="line">        padding: <span class="keyword">new</span> EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">        child: <span class="keyword">new</span> Form(</span><br><span class="line">          key: formKey,</span><br><span class="line">          autovalidate: <span class="keyword">false</span>,</span><br><span class="line">          child: <span class="keyword">new</span> ListView(</span><br><span class="line">            children: [</span><br><span class="line">              <span class="keyword">new</span> TextFormField(</span><br><span class="line">                key: firstNameKey,</span><br><span class="line">                style: Theme.of(context).textTheme.headline,</span><br><span class="line">                decoration: <span class="keyword">new</span> InputDecoration(</span><br><span class="line">                  hintText: <span class="string">'First Name'</span>,</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">              <span class="keyword">new</span> TextFormField(</span><br><span class="line">                key: lastNameKey,</span><br><span class="line">                style: Theme.of(context).textTheme.headline,</span><br><span class="line">                decoration: <span class="keyword">new</span> InputDecoration(</span><br><span class="line">                  hintText: <span class="string">'Last Name'</span>,</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">              <span class="keyword">new</span> TextFormField(</span><br><span class="line">                key: emailKey,</span><br><span class="line">                style: Theme.of(context).textTheme.headline,</span><br><span class="line">                decoration: <span class="keyword">new</span> InputDecoration(</span><br><span class="line">                  hintText: <span class="string">'Email Address'</span>,</span><br><span class="line">                ),</span><br><span class="line">              )</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="keyword">final</span> form = formKey.currentState;</span><br><span class="line">          <span class="keyword">if</span> (form.validate()) &#123;</span><br><span class="line">            <span class="keyword">var</span> firstName = firstNameKey.currentState.value;</span><br><span class="line">            <span class="keyword">var</span> lastName = lastNameKey.currentState.value;</span><br><span class="line">            <span class="keyword">var</span> email = emailKey.currentState.value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Later, do some stuff here</span></span><br><span class="line"></span><br><span class="line">            Navigator.pop(context);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/ericwindmill/32e73cc1fbf65114b5aa875500395f5a" target="_blank" rel="noopener">boilder plate的Github Gist</a></p><h2 id="pt2-添加Inherited-widget的功能"><a href="#pt2-添加Inherited-widget的功能" class="headerlink" title="pt2: 添加Inherited widget的功能"></a>pt2: 添加<code>Inherited widget</code>的功能</h2><h3 id="1-StateContainer以及InheritedStateContainer-Widgets"><a href="#1-StateContainer以及InheritedStateContainer-Widgets" class="headerlink" title="1.StateContainer以及InheritedStateContainer Widgets"></a>1.StateContainer以及InheritedStateContainer Widgets</h3><p>创建一个新的叫做state_container.dart文件。这是所有事情发生的地方。</p><p>首先，在该文件中，创建一个名为User的简单类。在真实的应用程序中，这可能是一个更大的类AppState，您可以在其中保存要在整个应用程序中访问的所有属性。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lass User &#123;</span><br><span class="line">  <span class="built_in">String</span> firstName;</span><br><span class="line">  <span class="built_in">String</span> lastName;</span><br><span class="line">  <span class="built_in">String</span> email;</span><br><span class="line"></span><br><span class="line">  User(<span class="keyword">this</span>.firstName, <span class="keyword">this</span>.lastName, <span class="keyword">this</span>.email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InheritedWidget通过连接到StatefulWidget作为存储。所以你的StateContainer实际上是三个类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateContainer</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">StateContainerState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StateContainer</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">_InheritedStateContainer</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span></span></span><br></pre></td></tr></table></figure><p><code>InheritedWidget</code>和<code>StateContainer</code>是最简单的设置，一旦设置它们就不会改变。逻辑主要存在于StateContainerState中。设置前两个:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InheritedStateContainer</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Data is your entire state. In our case just 'User' </span></span><br><span class="line">  <span class="keyword">final</span> StateContainerState data;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// You must pass through a child and your state.</span></span><br><span class="line">  _InheritedStateContainer(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.data,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is a built in method which you can use to check if</span></span><br><span class="line">  <span class="comment">// any state has changed. If not, no reason to rebuild all the widgets</span></span><br><span class="line">  <span class="comment">// that rely on your state.</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(_InheritedStateContainer old) =&gt; <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateContainer</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">   <span class="comment">// You must pass through a child. </span></span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">  <span class="keyword">final</span> User user;</span><br><span class="line"></span><br><span class="line">  StateContainer(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="keyword">this</span>.user,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is the secret sauce. Write your own 'of' method that will behave</span></span><br><span class="line">  <span class="comment">// Exactly like MediaQuery.of and Theme.of</span></span><br><span class="line">  <span class="comment">// It basically says 'get the data from the widget of this type.</span></span><br><span class="line">  <span class="keyword">static</span> StateContainerState of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> (context.inheritFromWidgetOfExactType(_InheritedStateContainer)</span><br><span class="line">            <span class="keyword">as</span> _InheritedStateContainer).data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StateContainerState createState() =&gt; <span class="keyword">new</span> StateContainerState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>‘of’方法应该永远不会做任何其他事情。实际上，这两个类可以永远保持独立。</p><h3 id="2-StateContainerState-widget"><a href="#2-StateContainerState-widget" class="headerlink" title="2. StateContainerState widget"></a>2. StateContainerState widget</h3><p>这个Widget是您所有状态和逻辑可以存在的地方。对于这个应用程序，你只需能够存储和操纵你的用户信息。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateContainerState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StateContainer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Whichever properties you wanna pass around your app as state</span></span><br><span class="line">  User user;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You can (and probably will) have methods on your StateContainer</span></span><br><span class="line">  <span class="comment">// These methods are then used through our your app to </span></span><br><span class="line">  <span class="comment">// change state.</span></span><br><span class="line">  <span class="comment">// Using setState() here tells Flutter to repaint all the </span></span><br><span class="line">  <span class="comment">// Widgets in the app that rely on the state you've changed.</span></span><br><span class="line">  <span class="keyword">void</span> updateUserInfo(&#123;firstName, lastName, email&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">      user = <span class="keyword">new</span> User(firstName, lastName, email);</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        user = user;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        user.firstName = firstName ?? user.firstName;</span><br><span class="line">        user.lastName = lastName ?? user.lastName;</span><br><span class="line">        user.email = email ?? user.email;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Simple build method that just passes this state through</span></span><br><span class="line">  <span class="comment">// your InheritedWidget</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _InheritedStateContainer(</span><br><span class="line">      data: <span class="keyword">this</span>,</span><br><span class="line">      child: widget.child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你以前使用过Redux，你可以看到这里涉及的样板少了多少，看起来是远远不够的，这当然会导致潜在的bug，但对于一个简单的应用程序，这是太棒了。这实际上是设置仓库所需的所有工作。然后，您只需根据需要向该类添加属性和方法。</p><p>#3.重构主页面和表单页面</p><p>首先，将你的应用包裹在StateContainer中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  runApp(new StateContainer(child: new UserApp()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样：现在您可以在整个应用程序中访问你的仓库。像这样做：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomeScreen</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Make a class property for the data you want</span></span><br><span class="line">  User user;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This Widget will display the users info:</span></span><br><span class="line">  </span><br><span class="line">  Widget <span class="keyword">get</span> _userInfo &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Center(</span><br><span class="line">      child: <span class="keyword">new</span> Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="comment">// This refers to the user in your store</span></span><br><span class="line">          <span class="keyword">new</span> Text(<span class="string">"<span class="subst">$&#123;user.firstName&#125;</span> <span class="subst">$&#123;user.lastName&#125;</span>"</span>,</span><br><span class="line">              style: <span class="keyword">new</span> TextStyle(fontSize: <span class="number">24.0</span>)),</span><br><span class="line">          <span class="keyword">new</span> Text(user.email, style: <span class="keyword">new</span> TextStyle(fontSize: <span class="number">24.0</span>)),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget <span class="keyword">get</span> _logInPrompt &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _updateUser(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// This is how you access your store. This container</span></span><br><span class="line">    <span class="comment">// is where your properties and methods live</span></span><br><span class="line">    <span class="keyword">final</span> container = StateContainer.of(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set the class's user</span></span><br><span class="line">    user = container.user;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body = user != <span class="keyword">null</span> ? _userInfo : _logInPrompt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        title: <span class="keyword">new</span> Text(<span class="string">'Inherited Widget Test'</span>),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// The body will rerender to show user info</span></span><br><span class="line">      <span class="comment">// as its updated</span></span><br><span class="line">      body: body,</span><br><span class="line">      floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">        onPressed: () =&gt; _updateUser(context),</span><br><span class="line">        child: <span class="keyword">new</span> Icon(Icons.edit),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很简单的变化。表单页面没有太大区别：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// form_page.dart</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateUserScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// get reference to your store</span></span><br><span class="line">    <span class="keyword">final</span> container = StateContainer.of(context);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      <span class="comment">// the form is the same until here:</span></span><br><span class="line">      floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="keyword">final</span> form = formKey.currentState;</span><br><span class="line">          <span class="keyword">if</span> (form.validate()) &#123;</span><br><span class="line">            <span class="keyword">var</span> firstName = firstNameKey.currentState.value;</span><br><span class="line">            <span class="keyword">var</span> lastName = lastNameKey.currentState.value;</span><br><span class="line">            <span class="keyword">var</span> email = emailKey.currentState.value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This is a hack that isn't important</span></span><br><span class="line">            <span class="comment">// To this lesson. Basically, it prevents </span></span><br><span class="line">            <span class="comment">// The store from overriding user info</span></span><br><span class="line">            <span class="comment">// with an empty string if you only want</span></span><br><span class="line">            <span class="comment">// to change a single attribute</span></span><br><span class="line">            <span class="keyword">if</span> (firstName == <span class="string">''</span>) &#123;</span><br><span class="line">              firstName = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lastName == <span class="string">''</span>) &#123;</span><br><span class="line">              lastName = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (email == <span class="string">''</span>) &#123;</span><br><span class="line">              email = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// You can call the method from your store,</span></span><br><span class="line">            <span class="comment">// which will call set state and rerender</span></span><br><span class="line">            <span class="comment">// the widgets that rely on the user slice of state.</span></span><br><span class="line">            <span class="comment">// In this case, thats the home page</span></span><br><span class="line">            container.updateUserInfo(</span><br><span class="line">              firstName: firstName,</span><br><span class="line">              lastName: lastName,</span><br><span class="line">              email: email,</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">            Navigator.pop(context);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅此而已！InheritedWidget很简单，对于简单的应用程序，原型等来说，非常可行。</p><p><a href="https://gist.github.com/ericwindmill/f790bd2456e6489b1ab97eba246fd4c6" target="_blank" rel="noopener">完成时的Github Gist</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
            <tag> Inherited Widget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Google Flutter 中的简单状态管理</title>
      <link href="/2019/04/18/Flutter/development/data-and-backend/state-mgmt/options/setState/Basic%20state%20management%20in%20Google%20Flutter/"/>
      <url>/2019/04/18/Flutter/development/data-and-backend/state-mgmt/options/setState/Basic%20state%20management%20in%20Google%20Flutter/</url>
      
        <content type="html"><![CDATA[<p><a href="https://medium.com/@agungsurya/basic-state-management-in-google-flutter-6ee73608f96d" target="_blank" rel="noopener">原文链接</a></p><h2 id="我是如何遇见-Google-Flutter的"><a href="#我是如何遇见-Google-Flutter的" class="headerlink" title="我是如何遇见 Google Flutter的"></a>我是如何遇见 Google Flutter的</h2><p>这对我来这是像往常一样的码代码的一天。我的一个朋友在我们的开发者群组中发了这么一个问题，是否有人尝试过Google Flutter。它想要知道React Native 和 Google Flutter之间的比较。这个问题让我种草了Google Flutter。我之前从没有听过Google Flutter。它是否值得与React Native进行比较，就像AngularJS相较于ReactJS?</p><p>我必须承认。我是一个React的迷弟。我已经使用ReactJS差不多两年了。我也写React Natice。但是不要对我有所误解。我之前也曾为AngularJS疯狂。有大约一年的时间我是一个AngularJS的开发者。然后我换了一家使用ReactJS的新公司。后来的事你们都知道了。</p><a id="more"></a><p>##长话短说 我渴望尝试使用Flutter</p><p>Google Flutter是一个新的平台，在这个平台之上你可以用一份Dart代码同时开发Android和iOS应用。迁移到新的开发栈之后，我知道做一个简单的应用，至少要优先处理的是状态管理。它把我引向了三个问题：</p><p>1.如何在widget树种向下传递一个应用的状态</p><p>2.如何在更新应用的状态之后对widget进行重建</p><p>3.如何在在页面之间跳转的同时保持状态同步。</p><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>默认情况下，flutter会创建main.dart。这是程序运行的地方。由于我要创建两个页面直接的跳转，我额外创建了两个文件：MyHomePage.dart以及MySecondPage.dart。</p><p>这个应用程序的目的是让用户做以下几件事：</p><ul><li>使MyHomePage中的计数器自增</li><li>跳转到MySecondPage</li><li>使MySecondPage中的计数器递减</li></ul><p>这虽然看起来很简单，但是我要找到一种方式保持MyHomePage和MySecondPage之间计数器的同步。</p><p>计数器的初始值是0。如果在MyHomePage中用户自增了两次，当用户跳转到MySecondPage之后，计数器必须展示位2。</p><p>与此同时，如果在MySecondPage中用户自减了两次，当用户跳转到MyHomePage，计数器必须展示为0。</p><p>这叫做状态管理。</p><p>我得知Google Flutter有着setState()的机制，而这个机制React也有。这使我能更快地找出解决方案。</p><p>在我的main.dart文件中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_redux_example/screens/MyHomePage.dart'</span>;</span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyAppState createState() =&gt; <span class="keyword">new</span> _MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyApp</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> counter;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    counter = counter ?? <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> _decrementCounter(_) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      counter--;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'decrement: <span class="subst">$counter</span>'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> _incrementCounter(_) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      counter++;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'increment: <span class="subst">$counter</span>'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: <span class="keyword">new</span> MyHomePage(</span><br><span class="line">        title: <span class="string">'My Home Page'</span>,</span><br><span class="line">        counter: counter,</span><br><span class="line">        decrementCounter: _decrementCounter,</span><br><span class="line">        incrementCounter: _incrementCounter,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上的代码，你可以看到_decrementCounter()和_incrementCounter()。它们是负责操作counter的值的，然后我把它们传递给了MyHomePage的构造器。</p><p>在我的MyHomePage.dart文件中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_redux_example/screens/MySecondPage.dart'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyHomePage(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="keyword">this</span>.counter,</span><br><span class="line">    <span class="keyword">this</span>.decrementCounter,</span><br><span class="line">    <span class="keyword">this</span>.incrementCounter</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> counter;</span><br><span class="line">  <span class="keyword">final</span> ValueChanged&lt;<span class="keyword">void</span>&gt; decrementCounter;</span><br><span class="line">  <span class="keyword">final</span> ValueChanged&lt;<span class="keyword">void</span>&gt; incrementCounter;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; <span class="keyword">new</span> _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> _onPressed() &#123;</span><br><span class="line">    widget.incrementCounter(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        title: <span class="keyword">new</span> Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: <span class="keyword">new</span> Center(</span><br><span class="line">        child: <span class="keyword">new</span> Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">new</span> Text(<span class="string">'You have pushed the button this many times:'</span>),</span><br><span class="line">            <span class="keyword">new</span> Text(</span><br><span class="line">              widget.counter.toString(),</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> RaisedButton(</span><br><span class="line">              child: <span class="keyword">new</span> Text(<span class="string">'Next Screen'</span>),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                Navigator.push(</span><br><span class="line">                  context,</span><br><span class="line">                  <span class="keyword">new</span> MaterialPageRoute(</span><br><span class="line">                    builder: (context) =&gt; <span class="keyword">new</span> MySecondPage(</span><br><span class="line">                      widget.decrementCounter,</span><br><span class="line">                      title: <span class="string">'My Second Page'</span>,</span><br><span class="line">                      counter: widget.counter,</span><br><span class="line">                    ),</span><br><span class="line">                  ),</span><br><span class="line">                );</span><br><span class="line">              &#125;,</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">        onPressed: _onPressed,</span><br><span class="line">        tooltip: <span class="string">'Increment'</span>,</span><br><span class="line">        child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码，你可以看到我把decrementCounter()向下传递给了MySecondPage的构造器。</p><p>在我的MySecondPage.dart文件中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySecondPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MySecondPage(</span><br><span class="line">    <span class="keyword">this</span>.decrementCounter, </span><br><span class="line">    &#123;Key key, <span class="keyword">this</span>.title, <span class="keyword">this</span>.counter&#125;</span><br><span class="line">  ): <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> counter;</span><br><span class="line">  <span class="keyword">final</span> ValueChanged&lt;<span class="keyword">void</span>&gt; decrementCounter;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MySecondPageState createState() =&gt; <span class="keyword">new</span> _MySecondPageState();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MySecondPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MySecondPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> onPressed() &#123;</span><br><span class="line">    widget.decrementCounter(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        title: <span class="keyword">new</span> Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: <span class="keyword">new</span> Center(</span><br><span class="line">        child: <span class="keyword">new</span> Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">new</span> Text(<span class="string">'You have pushed the button this many times :'</span>),</span><br><span class="line">            <span class="keyword">new</span> Text(</span><br><span class="line">              <span class="keyword">super</span>.widget.counter.toString(),</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">      onPressed: onPressed,</span><br><span class="line">      tooltip: <span class="string">'Decrement'</span>,</span><br><span class="line">      child: <span class="keyword">new</span> Icon(Icons.indeterminate_check_box),</span><br><span class="line">      backgroundColor: Colors.red),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>对于有着React背景的的开发者来说，玩弄Google Flutter中的基础状态管理不是已经特别难得事情。方法看起来很类似：存在一个setState()机制来对视图进行更新。StatefulWidget以及StatelessWidget的概念，对于我来说就行Component和PureComponent。Flutter把它们叫做Widget而React把它叫做Component。</p><p>那么，基本上，主要的问题就是 Google Flutter 所使用的编程语言了。由于它使用了Dart,我适应了Dart所拥有的语法和范式。目前为止，不是特别困难。对于我来说，Dart就像Java和Javascript生了一个孩子。</p><p>在这篇文章中，我设法解决我之前提及到的三个问题：</p><p>1.如何在widget树种向下传递一个应用的状态 /通过</p><p>2.如何在更新应用的状态之后对widget进行重建 /通过</p><p>3.如何在在页面之间跳转的同时保持状态同步。/通过</p><p>记住，这只是一个很简单的应用。在大型应用上事情会变得复杂很多。想象你要在应用所有widget中向下传递变量。这会是一件令人苦恼的事情。</p><p>在React环境下，我使用Redux来管理应用状态。我得知Redux也适用于Google Flutter。事实上，我已经成功地在Google Flutter应用上实现了Redux。让我们拭目以待我是否能发布关于此内容的文章。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
            <tag> setState </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)为你的 Flutter 应用加入交互体验</title>
      <link href="/2019/04/18/Flutter/development/ui/interactive/"/>
      <url>/2019/04/18/Flutter/development/ui/interactive/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/development/ui/interactive" target="_blank" rel="noopener">原文链接</a></p><p>你将学到什么</p><ul><li>如何对点击做出响应</li><li>如何创建一个自定义的widget</li><li>stateless widget和 stateful widget的区别</li></ul><a id="more"></a><p>如何修改您的应用程序以使其对用户输入做出响应？在本教程中，您将为仅包含非交互式widget的应用程序添加交互性。具体来说，您将通过创建自定义有状态widget来对两个无状态widget进行管理的方式修改图标，使其可以被点击。</p><p><a href="https://flutter.dev/docs/development/ui/layout/tutorial" target="_blank" rel="noopener">布局教程</a>已经向你展示了如何为以下的截图创建布局。</p><p><img src="https://flutter.dev/assets/ui/layout/lakes-2e8707102ca4f56f44e40ce3703606e1600ac1574fe5544c0f2d96f966bed853.jpg" alt></p><p>当应用程序首次启动时，星星是实心的红色，表明这个湖泊以前曾受到喜欢。这颗星旁边的数字表明有41人喜欢这个湖。完成本教程后，点击星形会移除其喜爱状态，用描边的星星替换实心的星星并减少数量。再次点击喜欢湖泊，就会绘制一颗实心的星星并增加数量。</p><p><img src="https://flutter.dev/assets/ui/favorited-not-favorited-e819c6dfba41b33418caa51282b524f04c12ec5217c41b19cefed685fb4d814b.png" alt></p><p>要实现此目的，您将创建一个包含星星和计数的widget，它们本身就是widget。因为点击星星会改变两个widget的状态，所以widget应该同时管理两个widget。</p><p>您可以马上开始 第2步：Subclass StatefulWidget中的代码。如果您想尝试不同的管理状态方法，请跳至管理状态。</p><p>为Flutter构建布局显示了如何为以下屏幕截图创建布局。<br><img src="https://flutter.cn/docs/development/ui/interactive/images/lakes.jpg" alt="img"></p><p><img src="https://flutter.cn/docs/development/ui/interactive/images/favorited-not-favorited.png" alt="img"></p><h2 id="有状态和无状态的widget"><a href="#有状态和无状态的widget" class="headerlink" title="有状态和无状态的widget"></a>有状态和无状态的widget</h2><p>widget可以是有状态的也可以是无状态的。例如，一个widget当用户与之交互的时候它能发生变化，它就是有状态的。</p><p>无状态widget从不发生变化。Icon,IconButton以及Text是无状态widget。无状态widget是StatelessWidget。</p><p>有状态widget是动态的，例如，它可以响应用户交互触发的事件或接收数据时改变它的外观。CheckBox,Radio,Slider,InkWell,Form,以及TextField是有状态widget。有状态的 Widget是StatefulWidget。</p><p>widget的状态被保存在<a href="https://api.flutter.dev/flutter/widgets/State-class.html" target="_blank" rel="noopener">State</a>对象中，将widget的状态与它的外观分离开来。状态包含了可以改变的值，像是进度条当前的值或是复选框是否选中。当widget的状态发生了变化，状态对象调用了setState(),告知框架对widget进行重新绘制。</p><h2 id="创建有状态小部件"><a href="#创建有状态小部件" class="headerlink" title="创建有状态小部件"></a>创建有状态小部件</h2><p>重点是什么？</p><ul><li>有状态的widget是由两个类实现的:一个StatefulWidget的子类以及一个State的子类。</li><li>state类包含了widget的可修改的状态以及widget的build()方法。</li><li>当widget的状态发生变化，state对象调用setState(),告知框架对widget进行重新绘制。</li></ul><p>在这个章节中，你会要创建一个自定义的有状态widget。你会把两个无状态的widget-实心红心以及它旁边的数量放到一个自定义的有状态widget中。这个widget管理了由两个孩子widget，IconButton以及Text组成的行。</p><p>实现一个自定义的widget需要创建两个类：</p><ul><li>定义这个widget的一个StatefulWidget的子类</li><li>包含这个widget状态和定义这个widget的build()方法的State子类。</li></ul><p>在这个章节中向你展示了如何为湖泊应用程序构建一个叫做FavoriteWidget的有状态widget。设置好之后，你要做的第一件事是选择如何管理FavoriteWidget的状态。</p><h2 id="第0步：做好准备"><a href="#第0步：做好准备" class="headerlink" title="第0步：做好准备"></a>第0步：做好准备</h2><p>如果您已经在Flutter中的Building Layouts中构建了布局，请跳到下一部分。</p><ul><li>确保您已设置环境。</li><li>创建一个基本的“Hello world”Flutter应用程序。</li><li>用GitHub中的main.dart替换lib/main.dart文件。</li><li>将pubspec.yaml文件替换为来自GitHub的pubspec.yaml。</li><li>在项目中创建一个images目录，然后添加lake.jpg。</li></ul><p>一旦你有一个连接和启用的设备，或者你已经启动了iOS模拟器（Flutter安装的一部分),你就已经做好准备了。</p><h3 id="第1步：确定哪个对象管理widget的状态"><a href="#第1步：确定哪个对象管理widget的状态" class="headerlink" title="第1步：确定哪个对象管理widget的状态"></a>第1步：确定哪个对象管理widget的状态</h3><p>可以通过多种方法管理widget的状态，但在我们的示例中，widget本身（FavoriteWidget）将管理自己的状态。在此示例中，切换星形是一个独立的操作，不会影响父widget或UI的其余部分，因此widget件可以在内部处理其状态。</p><p>在管理状态中，详细了解窗口小部件和状态的分离以及状态的管理方法。</p><h3 id="第2步：子类StatefulWidget"><a href="#第2步：子类StatefulWidget" class="headerlink" title="第2步：子类StatefulWidget"></a>第2步：子类StatefulWidget</h3><p>FavoriteWidget类管理自己的状态，因此它会覆盖createState()以创建State对象。框架在想要构建widget时调用createState()。在此示例中，createState()创建_FavoriteWidgetState的实例，您将在下一步中实现该实例。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FavoriteWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _FavoriteWidgetState createState() =&gt; _FavoriteWidgetState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：以下划线（_）开头的成员或类是私有的。有关更多信息，请参阅<a href="https://www.dartlang.org/guides/language/language-tour" target="_blank" rel="noopener">Dart语言导览</a>中的<a href="https://www.dartlang.org/guides/language/language-tour#libraries-and-visibility" target="_blank" rel="noopener">库和可见性</a>部分。</p><h3 id="第3步：子类状态"><a href="#第3步：子类状态" class="headerlink" title="第3步：子类状态"></a>第3步：子类状态</h3><p> _FavoriteWidgetState类存储了可以在widget生命周期内盖板的可修改数据。当应用程序首次启动时，UI会显示一个红色实心星星，表示该湖被喜欢了，并且有41个“喜欢”。 state对象将此信息存储在_isFavorited和_favoriteCount变量中:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FavoriteWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FavoriteWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> _isFavorited = <span class="keyword">true</span>;</span><br><span class="line">  <span class="built_in">int</span> _favoriteCount = <span class="number">41</span>;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">这个类还定义了一个build()方法。此build()方法创建一个包含红色IconButton和Text的行。widget使用IconButton(而不是Icon)，因为它有一个onPressed属性，用于定义处理tap的回调方法。你接下里会定义回调方法。</span><br><span class="line"></span><br><span class="line">```dart</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FavoriteWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FavoriteWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Row(</span><br><span class="line">      mainAxisSize: MainAxisSize.min,</span><br><span class="line">      children: [</span><br><span class="line">        Container(</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">0</span>),</span><br><span class="line">          child: IconButton(</span><br><span class="line">            icon: (_isFavorited ? Icon(Icons.star) : Icon(Icons.star_border)),</span><br><span class="line">            color: Colors.red[<span class="number">500</span>],</span><br><span class="line">            onPressed: _toggleFavorite,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        SizedBox(</span><br><span class="line">          width: <span class="number">18</span>,</span><br><span class="line">          child: Container(</span><br><span class="line">            child: Text(<span class="string">'<span class="subst">$_favoriteCount</span>'</span>),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：将文本放在SizedBox中并设置其宽度可防止在文本在40和41之间发生变化时出现明显的“跳跃” - 否则会发生这种情况，因为这些值具有不同的宽度。</p><p>_toggleFavorite()方法，会在IconButton被按下的时候被调用，然后会调用setState()。调用setState()是至关重要的，因为这会告诉框架widget的状态以及发生变化了，并且widget需要被重绘。setState()的方法参数切换这两种状态之间的UI：</p><ul><li>一个星星图标以及数字41</li><li>一个描边的星星图标以及数字40</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _toggleFavorite() &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_isFavorited) &#123;</span><br><span class="line">      _favoriteCount -= <span class="number">1</span>;</span><br><span class="line">      _isFavorited = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _favoriteCount += <span class="number">1</span>;</span><br><span class="line">      _isFavorited = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第4步：将有状态窗口小部件插入窗口小部件树"><a href="#第4步：将有状态窗口小部件插入窗口小部件树" class="headerlink" title="第4步：将有状态窗口小部件插入窗口小部件树"></a>第4步：将有状态窗口小部件插入窗口小部件树</h3><p>在应用程序的build()方法中将自定义有状态widget添加到widget树。首先，找到创建图标和文本的代码，然后将其删除：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Icon(</span><br><span class="line">  Icons.star,</span><br><span class="line">  color: Colors.red[<span class="number">500</span>],</span><br><span class="line">),</span><br><span class="line">Text(<span class="string">'41'</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>在同一位置，创建有状态小部件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    Widget titleSection = Container(</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      child: Row(</span><br><span class="line">        children: [</span><br><span class="line">          Expanded(</span><br><span class="line">            child: Column(</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">          ),</span><br><span class="line">          FavoriteWidget(),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅此而已！当你热重新加载应用程序时，星形图标现在应该能响应点击了。</p><h3 id="问题？"><a href="#问题？" class="headerlink" title="问题？"></a>问题？</h3><p>如果无法运行代码，请在IDE中查找可能的错误。调试Flutter Apps可能会有所帮助。如果仍然无法找到问题，请在GitHub上针对交互式Lakes示例检查代码。</p><p><a href="https://github.com/cfug/flutter.cn/tree/master/src/_includes/code/layout/lakes-interactive/main.dart" target="_blank" rel="noopener">lib/main.dart</a></p><p><a href="https://github.com/cfug/flutter.cn/tree/master/src/_includes/code/layout/lakes-interactive/pubspec.yaml" target="_blank" rel="noopener">pubspec.yaml</a> </p><p><a href="https://github.com/flutter/website/tree/master/src/_includes/code/layout/lakes-interactive/images/lake.jpg" target="_blank" rel="noopener">lakes.jpg</a></p><p>如果您仍有疑问，请参阅<a href="https://flutter.cn/community" target="_blank" rel="noopener">获取支持</a>。</p><p>本页的其余部分介绍了可以管理widget状态的几种方法，并列出了其他可用的交互式widget。</p><h2 id="管理状态"><a href="#管理状态" class="headerlink" title="管理状态"></a>管理状态</h2><p>重点是什么？</p><ul><li>管理状态有不同的方法。</li><li>作为widget的设计者，你可以选择使用哪种方法。</li><li>如果有疑问，请从父widget中管理状态开始。</li></ul><p>谁对有状态widget的状态进行管理？widget本身？父widget？两者都？另一个对象？答案是……看情况而定。有几种有效的方法可以使您的小部件具有交互性。作为widget设计者，您可以根据你所预期widget的使用方式做出决策。以下是管理状态的最常用方法：</p><ul><li>widget管理它自己的状态</li><li>父widget管理widget的状态</li><li>混合搭配的方法</li></ul><p>你如何作出使用哪种方法决定？以下原则可以帮助您做出决定：</p><ul><li><p>如果所讨论的状态是用户数据，例如复选框的已选中或未选中模式，或滑块的位置，则状态最好由父窗口小部件管理。</p></li><li><p>如果所讨论的状态是美学的，例如动画，那么状态最好由widget本身管理。</p></li></ul><p>如果有疑问，请从父widget中管理状态开始。</p><p>我们将通过创建三个简单示例（TapboxA，TapboxB和TapboxC）来举例说明管理状态的不同方法。这些示例的工作方式类似 - 每个都创建了一个容器，当轻敲时，可以在绿色或灰色框之间切换。 _active布尔值确定颜色：绿色表示活动，灰色表示不活动。</p><p><img src="https://flutter.cn/docs/development/ui/interactive/images/tapbox-active-state.png" alt="img"><br><img src="https://flutter.cn/docs/development/ui/interactive/images/tapbox-inactive-state.png" alt="img"></p><p>这些示例使用GestureDetector捕获Container上的活动。</p><h3 id="widget管理自己的状态"><a href="#widget管理自己的状态" class="headerlink" title="widget管理自己的状态"></a>widget管理自己的状态</h3><p>有时，widget在内部管理其状态是最有意义的是。例如，ListView在其内容超出渲染框时自动滚动。大多数使用ListView的开发人员不想管理ListView的滚动行为，因此ListView本身管理其滚动偏移。</p><p>_TapboxAState类：</p><ul><li>管理TapboxA的状态。</li><li>定义_active布尔值，用于确定框的当前颜色。</li><li>定义_handleTap（）函数，该函数在点击框时更新_active并调用setState（）函数来更新UI。</li><li>实现窗口小部件的所有交互行为。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TapboxA manages its own state.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------- TapboxA ----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TapboxA</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  TapboxA(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TapboxAState createState() =&gt; _TapboxAState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TapboxAState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TapboxA</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> _active = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTap() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _active = !_active;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">      onTap: _handleTap,</span><br><span class="line">      child: Container(</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Text(</span><br><span class="line">            _active ? <span class="string">'Active'</span> : <span class="string">'Inactive'</span>,</span><br><span class="line">            style: TextStyle(fontSize: <span class="number">32.0</span>, color: Colors.white),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        width: <span class="number">200.0</span>,</span><br><span class="line">        height: <span class="number">200.0</span>,</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">          color: _active ? Colors.lightGreen[<span class="number">700</span>] : Colors.grey[<span class="number">600</span>],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------- MyApp ----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Flutter Demo'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: TapboxA(),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="父widget管理widget的状态"><a href="#父widget管理widget的状态" class="headerlink" title="父widget管理widget的状态"></a>父widget管理widget的状态</h3><p>通常，父widget要告知其子窗口小部件何时更新，这时候由父widget管理是最有意义的。例如，IconButton允许您将图标视为可点击按钮。 IconButton是一个无状态小部件，因为我们确定父widget需要知道按钮是否已被点击，从而它可以采取适当的操作。</p><p>在以下示例中，TapboxB通过回调将其状态导出到其父级。因为TapboxB不管理任何状态，所以它是StatelessWidget的子类。</p><p>ParentWidgetState类：</p><ul><li>管理TapboxB的_active状态。</li><li>实现_handleTapboxChanged()，即点击框时调用的方法。</li><li>当状态改变时，调用setState（）来更新UI。</li></ul><p>TapboxB类：</p><ul><li>扩展StatelessWidget，因为所有状态都由其父级处理。</li><li>检测到点击时，它会通知父母。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParentWidget manages the state for TapboxB.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------ ParentWidget --------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ParentWidgetState createState() =&gt; _ParentWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ParentWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ParentWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> _active = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTapboxChanged(<span class="built_in">bool</span> newValue) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _active = newValue;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: TapboxB(</span><br><span class="line">        active: _active,</span><br><span class="line">        onChanged: _handleTapboxChanged,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------- TapboxB ----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TapboxB</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  TapboxB(&#123;Key key, <span class="keyword">this</span>.active: <span class="keyword">false</span>, <span class="meta">@required</span> <span class="keyword">this</span>.onChanged&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> active;</span><br><span class="line">  <span class="keyword">final</span> ValueChanged&lt;<span class="built_in">bool</span>&gt; onChanged;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTap() &#123;</span><br><span class="line">    onChanged(!active);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">      onTap: _handleTap,</span><br><span class="line">      child: Container(</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Text(</span><br><span class="line">            active ? <span class="string">'Active'</span> : <span class="string">'Inactive'</span>,</span><br><span class="line">            style: TextStyle(fontSize: <span class="number">32.0</span>, color: Colors.white),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        width: <span class="number">200.0</span>,</span><br><span class="line">        height: <span class="number">200.0</span>,</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">          color: active ? Colors.lightGreen[<span class="number">700</span>] : Colors.grey[<span class="number">600</span>],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：在创建API时，请考虑对代码所依赖的任何参数使用@required注释。要使用@required，请导入基础库（重新导出Dart的meta.dart库）：</p><p>content_copy<br>import’package：flutter / foundation.dart’;</p><h3 id="混合搭配的方法"><a href="#混合搭配的方法" class="headerlink" title="混合搭配的方法"></a>混合搭配的方法</h3><p>对于某些小部件，混合搭配方法最有意义。在这种情况下，有状态窗口小部件管理一些状态，父窗口小部件管理状态的其他方面。</p><p>在TapboxC示例中，在点击时，框周围会出现深绿色边框。点击后，边框消失，框的颜色也会改变。 TapboxC将其_active状态导出到其父级，但在内部管理其_highlight状态。此示例有两个State对象，_ParentWidgetState和_TapboxCState。</p><p>_ParentWidgetState对象：</p><ul><li>管理_active状态。</li><li>实现_handleTapboxChanged（），即点击框时调用的方法。</li><li>调用setState（）以在点击发生且_active状态更改时更新UI。</li></ul><p>_TapboxCState对象：</p><ul><li>管理_highlight状态。</li><li>GestureDetector监听所有点击事件。当用户点击时，它会添加突出显示（实现为深绿色边框）。当用户释放水龙头时，它会删除突出显示。</li><li>调用setState（）以在点击，点击或点击取消时更新UI，并且_highlight状态更改。</li><li>在tap事件上，将状态更改传递给父窗口小部件，以使用窗口小部件属性执行适当的操作。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------- ParentWidget ----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ParentWidgetState createState() =&gt; _ParentWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ParentWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ParentWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> _active = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTapboxChanged(<span class="built_in">bool</span> newValue) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _active = newValue;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: TapboxC(</span><br><span class="line">        active: _active,</span><br><span class="line">        onChanged: _handleTapboxChanged,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------- TapboxC ------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TapboxC</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  TapboxC(&#123;Key key, <span class="keyword">this</span>.active: <span class="keyword">false</span>, <span class="meta">@required</span> <span class="keyword">this</span>.onChanged&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> active;</span><br><span class="line">  <span class="keyword">final</span> ValueChanged&lt;<span class="built_in">bool</span>&gt; onChanged;</span><br><span class="line"></span><br><span class="line">  _TapboxCState createState() =&gt; _TapboxCState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TapboxCState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TapboxC</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> _highlight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTapDown(TapDownDetails details) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _highlight = <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTapUp(TapUpDetails details) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _highlight = <span class="keyword">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTapCancel() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _highlight = <span class="keyword">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTap() &#123;</span><br><span class="line">    widget.onChanged(!widget.active);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// This example adds a green border on tap down.</span></span><br><span class="line">    <span class="comment">// On tap up, the square changes to the opposite state.</span></span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">      onTapDown: _handleTapDown, <span class="comment">// Handle the tap events in the order that</span></span><br><span class="line">      onTapUp: _handleTapUp, <span class="comment">// they occur: down, up, tap, cancel</span></span><br><span class="line">      onTap: _handleTap,</span><br><span class="line">      onTapCancel: _handleTapCancel,</span><br><span class="line">      child: Container(</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Text(widget.active ? <span class="string">'Active'</span> : <span class="string">'Inactive'</span>,</span><br><span class="line">              style: TextStyle(fontSize: <span class="number">32.0</span>, color: Colors.white)),</span><br><span class="line">        ),</span><br><span class="line">        width: <span class="number">200.0</span>,</span><br><span class="line">        height: <span class="number">200.0</span>,</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">          color:</span><br><span class="line">              widget.active ? Colors.lightGreen[<span class="number">700</span>] : Colors.grey[<span class="number">600</span>],</span><br><span class="line">          border: _highlight</span><br><span class="line">              ? Border.all(</span><br><span class="line">                  color: Colors.teal[<span class="number">700</span>],</span><br><span class="line">                  width: <span class="number">10.0</span>,</span><br><span class="line">                )</span><br><span class="line">              : <span class="keyword">null</span>,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替代实现可能已将高亮状态导出到父级，同时保持活动状态为内部，但如果您要求某人使用该分接框，他们可能会抱怨它没有多大意义。开发人员关心该框是否处于活动状态。开发人员可能并不关心如何管理突出显示，并且更喜欢点按框处理这些细节。</p><h2 id="其它交互式widget"><a href="#其它交互式widget" class="headerlink" title="其它交互式widget"></a>其它交互式widget</h2><p>Flutter提供各种按钮和类似的交互式widget。这些小部件中的大多数都实现了Material Design准则，该准则定义了一组具有固定用户界面的组件。</p><p>如果您愿意，可以使用GestureDetector在任何自定义小部件中构建交互性。您可以在“管理状态”和“颤动图库”中找到GestureDetector的示例。</p><p>注意：Flutter还提供了一组名为Cupertino的iOS风格小部件。</p><p>当您需要交互性时，最简单的方法是使用其中一个预制小部件。这是一个部分列表：</p><h3 id="标准widgets"><a href="#标准widgets" class="headerlink" title="标准widgets"></a>标准widgets</h3><ul><li><a href="https://api.flutter.dev/flutter/widgets/Form-class.html" target="_blank" rel="noopener">Form</a></li><li><a href="https://api.flutter.dev/flutter/widgets/FormField-class.html" target="_blank" rel="noopener">FormField</a></li></ul><h3 id="Material-组件"><a href="#Material-组件" class="headerlink" title="Material 组件"></a>Material 组件</h3><ul><li><a href="https://api.flutter.dev/flutter/material/Checkbox-class.html" target="_blank" rel="noopener">checkbox</a></li><li><a href="https://api.flutter.dev/flutter/material/DropdownButton-class.html" target="_blank" rel="noopener">DropdownButton</a></li><li><a href="https://api.flutter.dev/flutter/material/FlatButton-class.html" target="_blank" rel="noopener">FlatButton</a></li><li><a href="https://api.flutter.dev/flutter/material/FloatingActionButton-class.html" target="_blank" rel="noopener">FloatingActionButton</a></li><li><a href="https://api.flutter.dev/flutter/material/IconButton-class.html" target="_blank" rel="noopener">IconButton</a></li><li><a href="https://api.flutter.dev/flutter/material/Radio-class.html" target="_blank" rel="noopener">Radio</a></li><li><a href="https://api.flutter.dev/flutter/material/RaisedButton-class.html" target="_blank" rel="noopener">RaisedButton</a></li><li><a href="https://api.flutter.dev/flutter/material/Slider-class.html" target="_blank" rel="noopener">slider</a></li><li><a href="https://api.flutter.dev/flutter/material/Switch-class.html" target="_blank" rel="noopener">Switch</a></li><li><a href="https://api.flutter.dev/flutter/material/TextField-class.html" target="_blank" rel="noopener">TextField</a></li></ul><h3 id="资源列表"><a href="#资源列表" class="headerlink" title="资源列表"></a>资源列表</h3><p>在为您的应用添加交互性时，以下资源可能会有所帮助。</p><ul><li><p><a href="https://flutter.dev/docs/development/ui/widgets-intro#handling-gestures" target="_blank" rel="noopener">手势</a>，<a href="https://flutter.dev/docs/development/ui/widgets-intro" target="_blank" rel="noopener">Flutter Widget框架之旅</a>中的一个部分</p><p>如何创建按钮并使其响应输入。</p></li><li><p><a href="https://flutter.dev/docs/development/ui/advanced/gestures" target="_blank" rel="noopener">Flutter的手势</a></p><p>Flutter手势机制的描述。</p></li><li><p><a href="https://api.flutter.dev/" target="_blank" rel="noopener">Flutter API文档</a></p><p>所有Flutter库的参考文档。</p></li><li><p><a href="https://github.com/flutter/flutter/tree/master/examples/flutter_gallery" target="_blank" rel="noopener">Flutter相册</a></p><p>演示应用程序展示了许多Material组件和其他Flutter功能。</p></li><li><p><a href="https://www.youtube.com/watch?v=dkyY9WCGMi0" target="_blank" rel="noopener">Flutter的分层设计</a>(视频)</p><p>此视频包含有关由状态和无状态widget的信息。由Google工程师Ian Hickson主讲。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
            <tag> setState </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)BLoC-ScopedModel-Redux之间的比较</title>
      <link href="/2019/04/17/Flutter/development/data-and-backend/state-mgmt/options/comparsion/BLoC%20-%20ScopedModel%20-%20Redux%20-%20Comparison/"/>
      <url>/2019/04/17/Flutter/development/data-and-backend/state-mgmt/options/comparsion/BLoC%20-%20ScopedModel%20-%20Redux%20-%20Comparison/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.didierboelens.com/2019/04/bloc---scopedmodel---redux---comparison/" target="_blank" rel="noopener">原文链接</a></p><p>BLoC-ScopedModel-Redux之间的比较，什么时候使用它们，以及原因是什么？</p><p>难度：初级</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>BLoC,ScopedModel,Redux这三者之间差异，各自的使用场景以及各自的优缺点。</p><p>在网上可以找到许多关于这个话题的问题和和答案，但是其中有没有正确的选择呢？</p><p>为了给出我自己的分析，我考虑了两种不同类型的用例，使用3个框架覆盖这些用例，构建了出一个快速解决方案，并进行比较。</p><p>可以在GitHub上找到包含Redux，ScopedModel和BLoC解决方案的<a href="https://github.com/boeledi/redux_scopedmodel_bloc" target="_blank" rel="noopener">完整源代码</a>。</p><hr><h2 id="它们是什么？"><a href="#它们是什么？" class="headerlink" title="它们是什么？"></a>它们是什么？</h2><p>为了更好地理解这些差异，我认为快速的过一下它们的主要原则是有所帮助的。</p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>介绍</p><p>Redux是一个应用程序状态管理框架。换句话说，它的主要目标是管理状态。</p><p>Redux的架构基于以下原则：</p><ul><li><p>单向数据流</p></li><li><p>一个仓库(Store)<br> 仓库(Store)的行为就像是Redux的协调者。仓库(Store)：</p><ul><li>只储存一个状态<ul><li>公开叫做dispatch一个入口，它的入参只有Actions</li><li>暴露一个getter来获取当前状态</li><li>允许通过注册StreamSubscription，从而能接收到任何应用于状态的变化</li><li>将actions和store分发到第一个MiddleWare</li><li>将actions和当前状态分发给Reducer（可能是由多个reducer组成的外观）</li></ul></li></ul></li><li><p>Actions</p></li></ul><p>Actions是Store接入点唯一接受的数据类型。Actions结合当前的状态供中间件和Reducer用来处理一些功能，这可能导致状态的修改。</p><p>Actions只描述发生过的事情。</p><ul><li>中间件</li></ul><p>中间件通常是一种旨在基于Action异步(但不一定)运行的功能。中间件只使用状态(或一个Action作为触发器)但不会改变状态。</p><ul><li>Reducer</li></ul><p>Reducer通常是一个同步函数，它根据Action-State的结合体进行一些处理。处理的结果可能会导致一个新的状态。</p><p>Reducer是唯一允许改变状态的对象。</p><p>值得注意的是，根据Redux的建议和良好实践，每个应用程序只有一个仓库。要拆分数据处理逻辑，建议使用<code>reducer composition</code>,而不是使用许多仓库。</p><p>它是如何工作的</p><p>如下的动图展示了Redux的工作原理：</p><p><img src="https://www.didierboelens.com/images/models_redux_animation.gif" alt></p><p>说明：</p><ul><li>当UI层发生某些事情(但实际上不限于UI)时，会创建一个Action并将其发送到Store(通过store.dispatch(action));</li><li>如果配置了一个或多个中间件，则按顺序调用它们，向它们传递Action和指向Store的引用（因此,也是State,间接);</li><li>中间件本身可以在处理过程中向仓库发送一个Action;</li><li>然后Action和当前状态也被发送到Reducer</li><li>Reducer是唯一可能改变状态的对象</li><li>当状态发生改变，仓库会通知所有已注册的听众，告诉它们状态发生了变化</li><li>然后,UI(但不限于UI)可以采取与状态更改相关联的适当操作。</li></ul><p>实现</p><p>Redux最初是为Javascript开发的，并以包的形式移植到Dart。</p><p>Flutter专用包(flutter_redux)提供了widget,例如：</p><ul><li>StoreProvider将Store传递给所有后代Widget</li><li>StoreBuilder从StoreProvider获取Store并将其传递给Widget build方法</li><li>StoreConnector从最近的StoreProvider祖先获取Store，将其转换为ViewModel并将其传递给一个build方法。</li></ul><hr><h3 id="ScopedModel"><a href="#ScopedModel" class="headerlink" title="ScopedModel"></a>ScopedModel</h3><p>介绍</p><p>ScopedModel是一组实用工具，它允许从父Widget向下传递数据模型到它的后代。</p><p>ScopedModel约有3个类：</p><ul><li>Model</li></ul><p>Model是一个包含与数据和数据相关业务逻辑的类。它被实现为可监听的，并且能在发生变化的时候通知那些对其感兴趣的。</p><ul><li>ScopedModel</li></ul><p>ScopedModel是一个Widget，类似于Provider，它持有Model并允许：</p><ul><li>通过常用的ScopedModel.of<model>(context)调用来获取Model</model></li><li>在请求时，将context注册为底层InheritedWidget的依赖项。</li></ul><p>ScopedModel基于一个AnimatedBuilder,它监听Model发送的通知，然后重建一个InheritedWidget，转而InheritedWidget将要求所有依赖项重建。</p><ul><li>ScopedModelDescendant</li></ul><p>ScopedModelDescendant是一个Widget，它对模型的变化作出反应;当模型通知发生变化的时候，它就会重建。</p><p>它是如何工作的？</p><p>以下代码提取了使用Scoped Model模拟“计数器”应用程序的代码。</p><p><img src="https://www.didierboelens.com/images/models_scopedmodel_code.png" alt></p><p>以下动画展示用户点击Button时会发生什么。</p><p><img src="https://www.didierboelens.com/images/models_scopedmodel_animation.gif" alt></p><p>说明：</p><ul><li>当用户点击RaisedButton时，将调用model.increment（）方法</li><li>此方法只是增加计数器值，然后调用notifyListeners（）API，因为Model实现了Listenable abstracts类。</li><li>这个notifyListeners（）被AnimatedBuilder截获，它重建了它的InheritedWidget子节点</li><li>InheritedWidget插入Column及其子项</li><li>其中一个子节点是ScopedModelDescendant，它调用其构建器，该构建器引用现在拥有新计数器值的Model。</li></ul><h3 id="BLoC"><a href="#BLoC" class="headerlink" title="BLoC"></a>BLoC</h3><p>介绍</p><p>BLoC模式不需要任何外部库或包，因为它只依赖于Streams的使用。但是，对于更友好的功能（例如主题），它经常与RxDart包结合使用。</p><p>BLoC模式依赖于：</p><ul><li>StreamController</li></ul><p>StreamController公开StreamSink，从而在Stream和Stream中注入数据，从而监听在Stream内部流动的数据。</p><ul><li>StreamBuilder</li></ul><p>StreamBuilder是一个Widget，它监听流并在Stream发出新数据时重建。</p><ul><li>StreamSubscription</li></ul><p>StreamSubscription允许监听流发出的数据并做出响应。</p><ul><li>BlocProvider</li></ul><p>BlocProvider是一个实用的Widget，通常用于保存BLoC并使其可用于后代Widgets。</p><p>它是如何工作的？</p><p>以下动画显示了当我们将一些数据注入其中一个Sink或通过API时BLoC如何工作。<br>（我知道，BLoC只应该与Sinks和Streams一起使用……但是没有什么能真正阻止使用API​​ ……）</p><p><img src="https://www.didierboelens.com/images/models_bloc_animation.gif" alt></p><p>说明：</p><ul><li>一些数据被注入其中一个BLoC接收器</li><li>数据由BLoC处理，最终从一个输出流中发出一些数据</li><li>使用BLoC API时也同样适用…</li></ul><p>有关BLoC概念的其他信息，请参阅我关于该话题的2篇文章：</p><p>2018年8月20日 - <a href="/flutter/state/bloc/2019/04/13/ReactiveProgramming-Streams-BLoC.html">Reactive Programming - Streams - BLoC</a></p><p>2018年12月1日 - <a href="/flutter/state/bloc/2019/04/13/ReactiveProgramming-Streams-BLoC-PracticalUseCases.html">Reactive Programming - Streams - BLoC - Practical Use Cases</a></p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>现在我们对于它们是什么以及它们是如何工作的有了更好的了解，让我们开始对它们进行比较。</p><p>为此，我将举两个例子来说明它们的差别，以及各自的优缺点。</p><h3 id="例1：用户认证"><a href="#例1：用户认证" class="headerlink" title="例1：用户认证"></a>例1：用户认证</h3><p>这个常见的用例非常有趣，因为它涉及某种类型的共享状态。在此示例中，我希望页面的行为如下：</p><p><img src="https://www.didierboelens.com/images/models_case_1.gif" alt></p><ul><li>显示用户未经过身份验证的文本以及用于模拟身份验证的按钮;</li><li>模拟身份验证过程正在进行时的CircularProgressIndicator;</li><li>经过身份验证的用户的名字和姓氏，以及要注销的按钮。</li></ul><h3 id="代码比较"><a href="#代码比较" class="headerlink" title="代码比较"></a>代码比较</h3><p>以下2张图片并排显示了应用程序初始化以及页面相关的代码。<br><img src="https://www.didierboelens.com/images/models_comp_appl_case1.png" alt><br>例1-Application<br><img src="https://www.didierboelens.com/images/models_comp_page_case1.png" alt><br>例1-page</p><p>我们可以看到，没有太大的区别。</p><p>缺乏重大差异可能是我做出的架构决策的结果，因为我要求我们能够从应用程序的任何地方“注销”。因此，我需要ScopedModel和BLoC解决方案将各自的模型和bloc注入到MaterialApp之上，以后可以在任何地方都可以使用。</p><p>但是，还是有区别的，让我们来看下。</p><hr><h3 id="差异和观察结果"><a href="#差异和观察结果" class="headerlink" title="差异和观察结果"></a>差异和观察结果</h3><h4 id="文件数量"><a href="#文件数量" class="headerlink" title="文件数量"></a>文件数量</h4><p>Redux这个解决方案会导致更多文件(如果我们想要坚持“一个实体，一个文件”范式的话)。即使我们根据它们的职责重新组合实体(例如将所有操作放在一起),我们仍然有更多的文件。</p><p>ScopedModel解决方案需要更少的文件，因为模型同时包含数据和逻辑。</p><p>与ScopedModel相比,如果我们想要拆分模型和逻辑，BLoC解决方案需要一个额外的文件，但这不是强制性的。</p><h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><p>在Redux中，由于它的运行方式，我们会无缘无故有着更多的代码被执行。实际上，编写reducer的方法是基于状态评估的，例如：“if action is…then”，同样适用于中间件。</p><p>此外，可能是由于flutter_redux包的实现原因，StoreConnector需要一个Conveter，尽管它有时这不是必需的。这个Converter旨在提供一种生成ViewModel的方法。</p><p>ScopedModel和BLoC解决方案似乎都需要较少的代码执行。</p><h4 id="代码复杂度"><a href="#代码复杂度" class="headerlink" title="代码复杂度"></a>代码复杂度</h4><p>如果你记住了它总是由Action触发所有中间件，使其按顺序运行（直到它们要实现一些异步的事情),那么reducer需要基于action的类型的比较来做一些事情，代码还是相对简单的。但是,很快它将需要使用reducer组合的概念（请参阅combineReducers与TypedReducer）。</p><p>ScopedModel解决方案看起来像是代码最简单的解决方案:您调用了一个更新model的方法，model会通知监听者。但是，对于监听者来说，知道导致被通知的原因并不明显，因为对model的任何修改都会生成通知(即使它对该某个监听器不感兴趣）。</p><p>BLoC解决方案有点复杂，因为它涉及Streams的概念。</p><p>在背后，flutter_redux解决方案还依赖于Streams的使用，但从开发人员的角度来看这是隐藏的。</p><h4 id="re-Build的数量"><a href="#re-Build的数量" class="headerlink" title="(re-)Build的数量"></a>(re-)Build的数量</h4><p>如果我们看一下应用程序重建部分的次数，就会变得有趣了。</p><p>在内部，flutter_redux使用Streams的概念来响应应用于State的更改，如果您不尝试通过StoreProvider.of(context)API访问Store，则只有StoreConnector将重建（如使用StreamBuilder)。这使得flutter_redux实现从重建角度来看很有趣。</p><p>ScopedModel解决方案是生成更多build的解决方案，因为每次Model通知其监听器时，它都会在ScopedModel()widget(实际上在底层AnimatedBuilder下)下重建整个树。</p><p>理想情况下，基于StreamBuilder响应变化的BLoC解决方案是flutter_redux，它导致较少的build（仅重建与StreamBuilder相关的部分）。</p><h4 id="代码隔离"><a href="#代码隔离" class="headerlink" title="代码隔离"></a>代码隔离</h4><p>在Redux中，reducer和middleware是“通常”但不一定是顶级函数/方法，意味着不属于类。因此，没有什么能阻止它们超出Redux Store的范围，这不是理想的。</p><p>ScopedModel和BLoC都倾向于易于代码隔离：对于model或bloc会有特定的类。</p><hr><h4 id="例1：结论"><a href="#例1：结论" class="headerlink" title="例1：结论"></a>例1：结论</h4><p>对于这种特定情况，因为没有性能限制(重建方面的限制),我个人认为没有孰优孰劣之分。</p><p>我需要指出的Redux的一个优点，就是能够插入一个中间件来记录不同的Action:你只需要在初始化Store时添加中间件方法的引用。</p><p>对于ScopedModel和BLoC，这还有很大的提升空间。</p><h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><p>针对这种情况，我们将模拟某种仪表板，用户可以在其中动态添加新面板。每个面板模拟一些实时数据演变(例如股票交易所)。用户可以单独为每个面板打开/关闭实时数据。</p><p>这是应用程序的样子：</p><p><img src="https://www.didierboelens.com/images/models_case_2.gif" alt></p><h4 id="代码比较-1"><a href="#代码比较-1" class="headerlink" title="代码比较"></a>代码比较</h4><p>由于我想坚持Redux主要原则（每个应用程序一个Store），因此在Redux中实现这一点更难，因为ApplicationState需要记住和处理每个单独的Pan​​el。</p><p>现在，如果你不想坚持这个原则，实际上没有任何东西阻止你使用多个仓库，每个面板一个。这么处理的话，代码会变得简单一点。</p><p>关于ScopedModel和BLoC版本，代码则非常相似。</p><hr><h3 id="差异和观察结果-1"><a href="#差异和观察结果-1" class="headerlink" title="差异和观察结果"></a>差异和观察结果</h3><h4 id="文件数量-1"><a href="#文件数量-1" class="headerlink" title="文件数量"></a>文件数量</h4><p>同样，Redux比起其它2个解决方案需要更多文件(即使我们尽可能重新组合)。</p><p>对于这种情况，ScopedModel和BLoC解决方案都需要相同数量的文件。</p><h4 id="代码执行-1"><a href="#代码执行-1" class="headerlink" title="代码执行"></a>代码执行</h4><p>与案例1的评论相同。</p><p>Redux执行的代码比ScopedModel和BLoC解决方案多得多，因为reducer基于状态评估，例如：“if action is … then”，同样适用于中间件。此外，还需要3个StoreConnector实例：</p><ul><li>在页面级别添加新的Panel</li><li>在Widget级别获取统计信息</li><li>在Widget级别处理打开/关闭统计数据的按钮。</li><li>ScopedModel需要额外的代码执行而不是BLoC，因为ScopedModel依赖于Listenable / InheritedWidget来在每次模型更改时重建。</li></ul><p>每个Panel，基于ScopedModel的解决方案需要：</p><ul><li>一个ScopedModel（注入）</li><li>一个ScopedModelDescendant来处理统计信息的显示</li><li>一个ScopedModelDescendant处理打开/关闭统计数据的按钮</li></ul><p>BLoC执行的代码代码。每个Panel,解决方案需要：</p><ul><li>一个StreamBuilder来显示统计数据</li><li>一个StreamBuilder来处理打开/关闭统计数据的按钮</li></ul><h4 id="代码复杂度-1"><a href="#代码复杂度-1" class="headerlink" title="代码复杂度"></a>代码复杂度</h4><p>Redux解决方案更复杂，因为它需要在3个不同的地方调度Actions：</p><ul><li>在页面级别，当我们需要实例化一个新的Panel时</li><li>在Widget级别，我们需要通过按钮打开/关闭定时器</li><li>在中间件级别，从服务器获取新的统计信息值</li></ul><p>ScopedModel和BLoC解决方案的复杂度分别仅位于Model和BLoC级别。由于每个Panel都有自己的Model或BLoC，因此代码不那么复杂。</p><h4 id="re-Build的数量-1"><a href="#re-Build的数量-1" class="headerlink" title="(re-)Build的数量"></a>(re-)Build的数量</h4><p>Redux解决方案是导致大部分重建的解决方案。</p><p>在实现中，基于“每个应用程序一个仓库”，每次更改应用于ApplicationState时，都会重建所有内容，这意味着：</p><ul><li>当我们添加一个新的Panel</li><li>当我们打开/关闭统计数据集时，所有面板都会重建</li><li>将新值添加到一个Panel时，将重建所有Panel</li></ul><p>如果我选择每个面板有一个Store，那么(重新)构建的数量会少很多。</p><p>关于ScopedModel解决方案，重建次数会少一些：</p><ul><li>当我们添加一个新的Panel</li><li>限于一个小组，何时<ul><li>我们打开/关闭统计数据集</li><li>为特定Panel收集新值</li></ul></li></ul><p>最后，BLoC解决方案需要更少的重建：</p><ul><li>当我们添加一个新的Panel</li><li>当我们打开/关闭统计数据集时，只重建与特定面板相关的按钮</li><li>当为特定Panel收集新值时，仅重建Panel。</li></ul><h4 id="例2：结论"><a href="#例2：结论" class="headerlink" title="例2：结论"></a>例2：结论</h4><p>对于这个特定情况，我个人发现BLoC解决方案是代码复杂性和重建方面的最佳选择。</p><p>次之是ScopedModel解决方案。</p><p>Redux架构不是此解决方案的最佳选择，但仍可以使用它。</p><h3 id="其他包"><a href="#其他包" class="headerlink" title="其他包"></a>其他包</h3><p>在下结论之前，我想提一下现在围绕Redux的概念存在其余包，下面两个可能会引起倾向使用Redux的人的兴趣：</p><ul><li><a href="https://pub.dartlang.org/packages/rebloc" target="_blank" rel="noopener">rebloc</a>，结合了Redux和BLoC的各个方面</li></ul><p>这个包非常有趣，但仍然没有解决与reducer的概念相关联（如果action是……那么）的代码执行的开销问题。但是，它是值得一看的。</p><ul><li><a href="https://pub.dartlang.org/packages/fish_redux" target="_blank" rel="noopener">fish_redux</a>，来自阿里巴巴闲鱼团队。</li></ul><p>此包与其说是状态管理框架，还不如说是基于Redux的应用程序框架。这个包非常有趣，但需要完全改变开发应用程序的方式。此解决方案使得根据Actions和Reducers更容易构建代码。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>这个分析让我基于两个不同的用例，一览无余地比较了三个最常使用的框架。</p><p>这三个框架各有利弊，我会在下面一一列出，这当然只是我个人的观点。</p><p>Redux</p><ul><li><p>优点</p><ul><li>由于Reducers是唯一可以执行从一个状态到另一个状态的过渡的对象，Redux允许集中管理一个状态。这使得状态转换完全可预测并且可以完全测试。</li><li>在流程中插入中间件的便利性也是一个优点。例如，如果您需要不断验证与服务器的连接或跟踪活动，这是此类例程的完美占位符。</li><li>它迫使开发人员根据“事件 -&gt;操作 -&gt;模型 -&gt;视图模型 -&gt;视图”来构建应用程序。</li></ul></li><li><p>缺点</p><ul><li>一个Store和一个巨大的状态（如果你想坚持Redux良好实践）</li><li>使用顶级功能/方法</li><li>reducers和middlewares级别的“如果……然后”比较太多了</li><li>重建次数过多（每次状态发生变化）</li><li>需要使用外部包，其中包含随着更改而发生的风险。</li></ul></li><li><p>要使用</p><ul><li>当您需要处理全局应用程序状态时，我可以推荐Redux，例如用户身份验证，购物车，偏好(语言，货币)</li></ul></li><li><p>不使用</p><ul><li>当你需要处理多个事件的实例时，我不会推荐Redux，每个实例都有自己的状态</li></ul></li></ul><p>Scoped Model</p><ul><li><p>优点</p><ul><li>ScopedModel使模型及其逻辑在一个位置重新组合变得非常容易。</li><li>ScopedModel不需要任何Streams概念的知识，这使得初学者更容易实现。</li><li>ScopedModel可用于全局和本地逻辑</li><li>ScopedModel不仅限于状态管理</li></ul></li><li><p>缺点</p><ul><li>ScopedModel没有提供任何方法让代码知道模型的哪个部分发生了变化并导致调用ScopedModelDescendant太多(重新)构建。</li><li>每次模型通知其侦听器时，与该模型相关的所有内容都会重建（AnimatedBuilder，InheritedWidget ……）<ul><li>需要使用外部包，其中包含随着更改而发生的风险。</li></ul></li></ul></li><li><p>要使用</p><ul><li>当开发人员不熟悉Streams时<ul><li>当模型不是太复杂时</li></ul></li></ul></li><li><p>不使用</p><ul><li>当出于性能原因，应用程序需要减少build数量时。</li><li>当应用程序需要准确知道模型的哪个部分已经改变时</li></ul></li></ul><p>BLoc</p><ul><li><p>优点</p><ul><li>BLoC可以轻松地将业务逻辑重新组合到一个位置</li><li>BLoC使得很容易精确地确定任何变化的性质（通过其基于Streams的输出接口）</li><li>由于使用了StreamBuilder Widget，BLoC可以很容易地将(重新)构建的数量限制到严格的最小值</li><li>Streams的使用非常强大，为许多动作打开了大门（转换，分离，去抖……）</li><li>BLoC可用于全局和本地逻辑</li><li>BLoC不仅限于状态管理</li><li>不需要使用任何外部包。</li></ul></li><li><p>缺点</p><ul><li>如果你想坚持总体原则，我们就只能处理sinks和streams。</li><li>就个人而言，我的BLoC还会暴露getter/setters/API，这会消除这种“缺点”。</li><li>初学者很难从BLoC开始，因为它需要对Flutter实际工作方式有更多的了解</li></ul></li><li><p>要使用的</p><ul><li>我没有看到任何限制。</li></ul></li><li><p>不使用</p><ul><li>我没有看到任何建议不使用BLoC的情况，除非开发人员不熟悉Streams的概念。</li></ul></li></ul><p>因此，有没有一个完美的解决方案？</p><p>事实上，我会说没有“单一”的完美解决方案。这实际上取决于您的使用案例，而且，它实际上取决于你对框架的熟悉程度。</p><p>作为结论，我只谈论下自己的看法。</p><p>到目前为止，我从未在任何项目中使用过Redux，而且我从来没有感觉到我错过了什么。这同样适用于ScopedModel。</p><p>几个月前，我开始使用BLoC，我几乎可以在任何地方使用这个概念，它非常方便。它确实使我的代码更清晰，更容易测试，更加结构化和可重用。</p><p>我希望这篇文章能给你一些更多的见解。</p><p>请继续关注新文章，让我祝你编程愉快！</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
            <tag> BLoC </tag>
            
            <tag> ScopedModel </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)简单的共享状态管理</title>
      <link href="/2019/04/16/Flutter/development/data-and-backend/state-mgmt/simple/"/>
      <url>/2019/04/16/Flutter/development/data-and-backend/state-mgmt/simple/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/simple" target="_blank" rel="noopener">原文链接</a></p><p>现在你已了解<a href="Start-thinking-declaratively.html">状态管理中的声明式编程思维</a>以及<a href="Differentiate-between-ephemeral-state-and-app-state.html">短时状态和共享</a>，你已经做好了解简单的应用程序状态管理的准备。</p><p>在此篇文章中，我们将使用 scoped_model 包。如果你是 Flutter 的新手并且没有充分的理由选择其他方法（Redux，Rx，钩子等），这可能是你刚开始应该使用的方法。 scoped_model很容易理解，它不会使用太多代码。它还使用适用于所有其他方法的概念。</p><a id="more"></a><p>也就是说，如果你来自其它响应式框架中的强大状态管理的背景，那么你将在<a href="https://flutter.cn/docs/development/data-and-backend/state-mgmt/options" target="_blank" rel="noopener">接下来的文章</a>上找到包和教程。</p><h2 id="我们的例子"><a href="#我们的例子" class="headerlink" title="我们的例子"></a>我们的例子</h2><p>为了便于说明，请思考以下简单应用。</p><p>该应用程序有三个独立的页面：登录提示，目录和购物车（分别由 MyLoginScreen，MyCatalog 和 MyCart 这三个 widget 表示）。它可能是一个购物应用程序，但你可以在一个简单的社交网络应用程序中想象相同的结构（把购物车替代为照片墙，购物车替代为喜爱的人）。</p><p>目录屏幕包括自定义应用栏（MyAppBar）和由许多列表项（MyListItems）组成滑动视图。</p><p>这是可视化为 widget 树的应用程序。</p><p><img src="https://flutter.cn/assets/development/data-and-backend/state-mgmt/simple-widget-tree-19cb2528c56ef04924de364b4d0e08b73f4bcf7231aad0d6bc0eb1919e543fb9.png" alt="img"></p><p>所以我们至少有6个 Widget 子类。它们中的许多 widget 会需要访问属于其他地方的状态。例如，每个 MyListItem 都希望能够添加到购物车。它可能还想查看它显示的项目是否已经在购物车中。</p><p>这就把我们带到了第一个问题：我们应该把购物车的当前状态放在哪里？</p><h3 id="向上移动状态"><a href="#向上移动状态" class="headerlink" title="向上移动状态"></a>向上移动状态</h3><p>在 Flutter 中，将状态保存在使用它的 widget 之上是有意义的。</p><p>为什么？在像 Flutter 这样的声明性框架中，如果要更改 UI，则必须重新构建它。 没有简单的方法可以使用 MyCart.updateWith(somethingNew)。 换句话说，通过调用其上的方法很难从外部强制更改 widget。 即使你能做到这一点，你也会跟框架作对，而不是让它帮你。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BAD: DO NOT DO THIS</span></span><br><span class="line"><span class="keyword">void</span> myTapHandler() &#123;</span><br><span class="line">  <span class="keyword">var</span> cartWidget = somehowGetMyCartWidget();</span><br><span class="line">  cartWidget.updateWith(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使你使用上述代码，你也必须在 MyCart widget 中处理以下内容：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BAD: DO NOT DO THIS</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> SomeWidget(</span><br><span class="line">    <span class="comment">// The initial state of the cart.</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> updateWith(Item item) &#123;</span><br><span class="line">  <span class="comment">// Somehow you need to change the UI from here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你需要考虑 UI 的当前状态并将新数据应用于它。以这种方式很难避免错误。</p><p>在 Flutter 中，每次内容更改时都会构造一个新 widget。 你使用 MyCart（内容）（构造函数），而不是 MyCart.updateWith（somethingNew）（方法调用）。 因为你只能在父节点的构建方法中构建新的 widget，如果你想改变内容，它需要存在于 MyCart 的父级或更高级别。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GOOD</span></span><br><span class="line"><span class="keyword">void</span> myTapHandler(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">var</span> cartModel = somehowGetMyCartModel(context);</span><br><span class="line">  cartModel.add(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，MyCart 只有一个代码路径来构建任何版本的 UI。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GOOD</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">var</span> cartModel = somehowGetMyCartModel(context);</span><br><span class="line">  <span class="keyword">return</span> SomeWidget(</span><br><span class="line">    <span class="comment">// Just construct the UI once, using the current state of the cart.</span></span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的示例中，内容需要存在于 MyApp 中。 每当它发生变化时，它都会从上面重建MyCart（稍后会详细介绍）。 因此，MyCart 不需要担心生命周期 - 它只是声明了为任何给定内容显示的内容。 当更改时，旧的 MyCart widget 将消失，并完全被新的 widget 取代。</p><p><img src="https://flutter.cn/assets/development/data-and-backend/state-mgmt/simple-widget-tree-with-cart-088b22c4ef4e4389a1cababaceaadcd36ba3de37613080942885263c36e29595.png" alt="img"></p><p>当我们说 widget 是不可变的时，这就是我们的意思。 它们没有改变 - 它们被取代了。</p><p>现在我们知道了购物车状态的位置，让我们看看如何访问它。</p><h2 id="访问状态"><a href="#访问状态" class="headerlink" title="访问状态"></a>访问状态</h2><p>当用户单击目录中的某个条目时，它会添加到购物车中。 但由于购物车位于MyListItem之上，我们该如何做？</p><p>一个简单的选项是提供 MyListItem 单击时可以调用的回调。 Dart的方法是甲级对象，因此您可以以任何方式传递它们。 因此，在 MyCatalog 中，你可以拥有以下内容：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> SomeWidget(</span><br><span class="line">    <span class="comment">// Construct the widget, passing it a reference to the method above.</span></span><br><span class="line">    MyListItem(myTapCallback),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myTapCallback(Item item) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'user tapped on <span class="subst">$item</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以正常工作，但对于你需要从许多不同的地方进行修改的 app 状，你必须传递大量的回调 - 这很快就会使人变老。</p><p>幸运的是，Flutter 有 widget 机制为他们的后代提供数据和服务（换句话说，不仅仅是他们的孩子，而是它们下面的任何 widget）。 正如您对 Flutter 所期望的那样，所有东西是Widget™，这些机制只是特殊类型的widget-  <code>InheritedWidget</code>，<code>InheritedNotifier</code>，<code>InheritedModel</code>等。 我们不会在这里介绍那些，因为它们对我们想要做的事情来说有点过于底层。</p><p>相反，我们将使用一个适用于底层 widget 的包，但却易于使用。 它叫做 scoped_model。</p><p>使用 <code>scoped_model</code>，你无需担心回调或 <code>InheritedWidgets</code>。 但你确实需要理解3个概念：</p><ul><li>Model</li><li>ScopedModel</li><li>ScopedModelDescedant</li></ul><p>在 scoped_model 中，Model封装了你的应用程序状态。 对于非常简单的应用程序，你可以使用单个模型。在复杂的，你会有几个模型。</p><p>在我们的购物应用示例中，我们希望在模型中管理购物车的状态。 我们创建了一个扩展 Model 的新类。 像这样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartModel</span> <span class="keyword">extends</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// Internal, private state of the cart.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Item&gt; _items = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// An unmodifiable view of the items in the cart.</span></span><br><span class="line">  UnmodifiableListView&lt;Item&gt; <span class="keyword">get</span> items =&gt; UnmodifiableListView(_items);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The current total price of all items (assuming all items cost $1).</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> totalPrice =&gt; _items.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Adds [item] to cart. This is the only way to modify the cart from outside.</span></span><br><span class="line">  <span class="keyword">void</span> add(Item item) &#123;</span><br><span class="line">    _items.add(item);</span><br><span class="line">    <span class="comment">// This call tells [Model] that it should rebuild the widgets that</span></span><br><span class="line">    <span class="comment">// depend on it.</span></span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一特定于 Model 的代码是对 notifyListeners() 的调用。 只要模型发生变化，可能会改变应用程序的 UI，就可以调用此方法。 CartModel 中的其他所有内容都是模型本身及其业务逻辑。</p><p>模型不依赖于 Flutter 中的任何高级类，因此它很容易测试（你甚至不需要使用 widget 测试)。 例如，这是 CartModel 的简单单元测试：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'adding item increases total cost'</span>, () &#123;</span><br><span class="line">  <span class="keyword">final</span> cart = CartModel();</span><br><span class="line">  <span class="keyword">final</span> startingPrice = cart.totalPrice;</span><br><span class="line">  cart.addListener(() &#123;</span><br><span class="line">    expect(cart.totalPrice, greaterThan(startingPrice));</span><br><span class="line">  &#125;);</span><br><span class="line">  cart.add(Item(<span class="string">'Dash'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是当与 scoped_model 包的其余部分一起使用时，Model 真正开始有意义。</p><h2 id="ScopedModel"><a href="#ScopedModel" class="headerlink" title="ScopedModel"></a>ScopedModel</h2><p>ScopedModel是为其后代提供Model实例的widget。</p><p>我们已经知道在哪里放置它：在需要访问它的widget之上。 对于CartModel，这意味着在MyCart和MyCatalog之上。</p><p>你不希望将 ScopedModel 放在高于必要的位置（因为你不想污染范围）。但在我们的案例中，MyCart 和 MyCatalog 之上唯一的小部件是 MyApp。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> cart = CartModel();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You could optionally connect [cart] with some database here.</span></span><br><span class="line"></span><br><span class="line">  runApp(</span><br><span class="line">    ScopedModel&lt;CartModel&gt;(</span><br><span class="line">      model: cart,</span><br><span class="line">      child: MyApp(),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，我们正在创建 ScopedModel &lt;CartModel&gt;（读作：“CartModel的ScopedModel”）。 scoped_model 包依赖于类型来查找正确的模型，<cartmodel>部分清楚地说明了我们在这里提供的类型。</cartmodel></p><p>如果要提供多个模型，则需要嵌套 ScopedModel：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScopedModel&lt;SomeOtherModel&gt;(</span><br><span class="line">  model: myOtherModel,</span><br><span class="line">  child: ScopedModel&lt;CartModel&gt;(</span><br><span class="line">    model: cart,</span><br><span class="line">    child: MyApp(),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="ScopedModelDescendant"><a href="#ScopedModelDescendant" class="headerlink" title="ScopedModelDescendant"></a>ScopedModelDescendant</h2><p>现在 CartModel 通过顶部的 ScopedModel &lt;CartModel&gt; 声明提供给我们应用程序中的widget，我们可以开始使用它。</p><p>这是通过 ScopedModelDescendant widget 完成的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ScopedModelDescendant&lt;CartModel&gt;(</span><br><span class="line">  builder: (context, child, cart) &#123;</span><br><span class="line">    <span class="keyword">return</span> Text(<span class="string">"Total price: <span class="subst">$&#123;cart.totalPrice&#125;</span>"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们必须指定我们想要访问的模型的类型。 在这种情况下，我们需要 CartModel，因此我们编写 ScopedModelDescendant &lt;CartModel&gt;。 如果未指定泛型（&lt;CartModel&gt;），则scoped_model 包将无法帮助您。 如上所述，scoped_model 基于类型，没有类型，它不知道你想要什么。</p><p>ScopedModelDescendant widget 唯一必需的参数是构建器。 Builder 是一个在模型更改时调用的函数。(换句话说，当你在模型中调用 notifyListeners() 时，将调用所有相应ScopedModelDescendant widget 的所有构建器方法。）</p><p>构建器被调用的时候使用了三个属性。第一个是 context，你可以在每个构建方法中获得它。</p><p>第二个属性是child，它用于优化。 如果你的 ScopedModelDescendant 下有一个大的widget 子树，它在模型更改时不会更改，你可以构造它一次并通过构建器获取它。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ScopedModelDescendant&lt;CartModel&gt;(</span><br><span class="line">  builder: (context, child, cart) =&gt; Stack(</span><br><span class="line">        children: [</span><br><span class="line">          <span class="comment">// Use SomeExpensiveWidget here, without rebuilding every time.</span></span><br><span class="line">          child,</span><br><span class="line">          Text(<span class="string">"Total price: <span class="subst">$&#123;cart.totalPrice&#125;</span>"</span>),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">  <span class="comment">// Build the expensive widget here.</span></span><br><span class="line">  child: SomeExpensiveWidget(),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>构建器函数的第三个参数是模型。这就是我们首先要求的。 你可以使用模型中的数据来定义 UI 在任何给定点的外观。</p><p>最佳做法是将 ScopedModelDescendant widget 尽可能深入树中。 你不希望重建UI的大部分内容只是因为某些细节发生了变化。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DON'T DO THIS</span></span><br><span class="line"><span class="keyword">return</span> ScopedModelDescendant&lt;CartModel&gt;(</span><br><span class="line">  builder: (context, child, cart) &#123;</span><br><span class="line">    <span class="keyword">return</span> HumongousWidget(</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      child: AnotherMonstrousWidget(</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        child: Text(<span class="string">'Total price: <span class="subst">$&#123;cart.totalPrice&#125;</span>'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>而是：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DO THIS</span></span><br><span class="line"><span class="keyword">return</span> HumongousWidget(</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  child: AnotherMonstrousWidget(</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    child: ScopedModelDescendant&lt;CartModel&gt;(</span><br><span class="line">      builder: (context, child, cart) &#123;</span><br><span class="line">        <span class="keyword">return</span> Text(<span class="string">'Total price: <span class="subst">$&#123;cart.totalPrice&#125;</span>'</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="ScopedModel-of"><a href="#ScopedModel-of" class="headerlink" title="ScopedModel.of"></a>ScopedModel.of</h3><p>有时，你并不真正需要模型中的数据来更改 UI，但你仍然需要访问它。 例如，ClearCart 按钮希望允许用户从购物车中删除所有内容。 它不需要显示购物车的内容，只需要调用clear() 方法即可。</p><p>我们可以使用 ScopedModelDescendant &lt;CartModel&gt;，但这样做会很浪费。 我们要求框架重建一个不需要重建的widget。</p><p>对于这个用例，我们可以使用 ScopedModel.of</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScopedModel.of&lt;CartModel&gt;(context).add(item);</span><br></pre></td></tr></table></figure><p>在调用 notifyListeners 时，在构建方法中使用上述行不会导致此 widget 重建。</p><p>注意：你还可以使用 ScopedModelDescendant &lt;CartModel&gt;（Builder：myBuilder，rebuildOnChange：false），但这样做更长，并且需要你定义构建器函数。</p><h2 id="把它们放在一起"><a href="#把它们放在一起" class="headerlink" title="把它们放在一起"></a>把它们放在一起</h2><p>你可以查看本文中介绍的<a href="https://github.com/filiph/samples/tree/scoped-model-shopper/model_shopper" target="_blank" rel="noopener">示例</a>。 如果你想要更简单的东西，你可以看到使用<a href="https://github.com/flutter/samples/tree/master/scoped_model_counter" target="_blank" rel="noopener">scoped_model构建简单的Counter应用程序时的样子</a>。</p><p>当你准备好自己玩 scoped_model 时，不要忘记首先将它的依赖项添加到 pubspec.yaml。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name: my_name</span><br><span class="line">description: Blah blah blah.</span><br><span class="line"></span><br><span class="line"># ...</span><br><span class="line"></span><br><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line"></span><br><span class="line">  scoped_model: ^<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">dev_dependencies:</span><br><span class="line">  # ...</span><br></pre></td></tr></table></figure><p>现在你可以导入’package：scoped_model / scoped_model.dart’; 并开始构建。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)短时状态和共享状态的区别</title>
      <link href="/2019/04/16/Flutter/development/data-and-backend/state-mgmt/ephemeral-vs-app/"/>
      <url>/2019/04/16/Flutter/development/data-and-backend/state-mgmt/ephemeral-vs-app/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/ephemeral-vs-app" target="_blank" rel="noopener">原文链接</a></p><p>本文档介绍了应用状态，短时状态以及如何在 Flutter 应用中对这两种状态进行管理。</p><a id="more"></a><p>在广义上，应用程序的状态是应用程序运行时在内存中存在的所有内容。这包括应用程序的<code>assets</code>，Flutter框架维护的关于UI，动画状态，纹理，字体等等的所有变量。虽然这种最广泛的状态定义是有效的，但它对于构建应用程序并不是很有用。</p><p>首先，你甚至不管理某些状态（如纹理）。 框架会为你处理这些问题。因此，更有用的状态定义是“在任何时刻重建UI所需的任何数据”。其次，你自己管理的状态可以分为两种概念类型：短时状态和应用状态。</p><h2 id="短时状态"><a href="#短时状态" class="headerlink" title="短时状态"></a>短时状态</h2><p>短暂状态（有时称为 UI 状态或本地状态）是您可以整齐地包含在单个 widget 中的状态。</p><p>这是一个模糊的定义，所以这里有一些例子。</p><ul><li><code>pageView</code> 的当前页</li><li>复杂动画的当前状态</li><li><code>BottomNavigatorBar</code> 选中的当前标签</li></ul><p>widget 树的其他部分很少需要存取这种状态。 没有必要对其进行序列化，并且它不会以复杂的方式发生变化。</p><p>换句话说，不需要在这种状态下使用状态管理技术（ScopedModel，Redux 等。你只需要一个StatefulWidget。</p><p>以下，你将看到底部导航栏中当前所选项目如何保存在 _MyHomepageState 类的 _index 字段中。 在此例中，_index 是短时状态。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomepage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomepageState createState() =&gt; _MyHomepageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomepageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomepage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> BottomNavigationBar(</span><br><span class="line">      currentIndex: _index,</span><br><span class="line">      onTap: (newIndex) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          _index = newIndex;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ... items ...</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，使用 setState() 和 StatefulWidget 的 State 类中的字段是完全自然的。 你的应用没有其他任何部分需要存取 _index。 该变量仅在 MyHomepage widget 内更改。 而且，如果用户关闭并重新启动应用程序，你不介意 _index 重置为零。</p><h2 id="共享状态"><a href="#共享状态" class="headerlink" title="共享状态"></a>共享状态</h2><p>那些不是短时的状态，你希望在应用程序的许多部分之间共享，并且你希望在用户会话之间保持 - 这就是我们所说的应用程序状态（有时也被称为共享状态）。</p><p>应用程序状态的示例：</p><ul><li>用户偏好</li><li>登录信息</li><li>社交网络应用中的通知</li><li>电子商务应用中的购物车</li><li>新闻应用中的文章的已读/未读状态</li></ul><p>对于管理应用状态，你会对你手里的选项做一番研究。您的选择取决于你的应用程序的复杂性和特性，团队以前的经验以及许多其他方面。继续看。</p><h2 id="没有明确的规则"><a href="#没有明确的规则" class="headerlink" title="没有明确的规则"></a>没有明确的规则</h2><p>要清楚，你可以使用 State 和 setState() 来管理应用中的所有状态。 实际上，Flutter 团队在许多简单的应用程序示例中都会这样做（包括每次创建时都会获得的入门应用程序)。</p><p>它也有另一种方式。 例如，你可能决定 - 在特定应用程序的上下文中 - 底部导航栏中的选定选项卡不是短时状态。 你可能需要从类外部更改它，在会话之间保留它，依此类推。 在这种情况下，_index 变量是 app 状态。</p><p>没有明确的通用规则来区分特定变量是短时状态还是应用状态。 有时，你必须将一个重构为另一个。 例如，你会从一些清晰的短时状态开始，但随着你的应用程序功能的增加，它将需要变动到应用程序状态。</p><p>因此，让我们以下示意图持保留态度：</p><p><img src="https://flutter.cn/assets/development/data-and-backend/state-mgmt/ephemeral-vs-app-state-3137024aa509b4df5d20ed7ed30fb8a0f7cff54ebc8ab0d6e39794bced87e27c.png" alt="img"></p><p>当被问及 React 的 setState 与 Redux 的 store 时，Redux 的作者 Dan Abramov 回答说：</p><p>经验法则是：哪个方便用哪个</p><p>总之，任何 Flutter 应用程序中都有两种概念类型的状态。 短时状态可以使用 State 和setState() 来实现，并且通常是 widget 本地状态。 剩下的就是你的应用状态。 这两种类型在任何 Flutter 应用程序中都占有一席之地，两者之间的分割取决于你自己的偏好和应用程序的复杂性。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)声明式用户界面介绍</title>
      <link href="/2019/04/16/Flutter/get-started/flutter-for/declarative/"/>
      <url>/2019/04/16/Flutter/get-started/flutter-for/declarative/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/get-started/flutter-for/declarative" target="_blank" rel="noopener">原文链接</a></p><p>这篇介绍描述了 Flutter 使用的声明样式与许多其他用户界面框架使用的命令式样式之间的概念差异。</p><a id="more"></a><h2 id="为什么是声明式用户界面"><a href="#为什么是声明式用户界面" class="headerlink" title="为什么是声明式用户界面?"></a>为什么是声明式用户界面?</h2><p>从 Win32 到 Web 到 Android 和 iOS 的框架通常使用命令式的用户界面编程风格。这可能是你最熟悉的样式 - 您手动构建全功能UI实体（如UIView或等效实体），然后在用户界面更改时使用方法和 setter 对其进行变更。</p><p>为了减轻开发人员的负担，无需编写如何在不同的用户界面状态之间进行切换的代码，相比之下，Flutter 让开发人员描述当前的用户界面状态，并把状态切换的的工作留给了框架。</p><p>然而，这需要在思考如何操纵用户界面方面略有转变。</p><h2 id="如何在声明式框架中改变-UI"><a href="#如何在声明式框架中改变-UI" class="headerlink" title="如何在声明式框架中改变 UI"></a>如何在声明式框架中改变 UI</h2><p>思考以下一个简单的例子：</p><p><img src="https://flutter.cn/images/declarativeUIchanges.png" alt="img"></p><p>在命令式风格中，你通常会转到 ViewB 的所有者并使用选择器或 findViewById 或类似函数获得实例 b，并在其上调用修改（并隐式对其刷新）。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Imperative style</span></span><br><span class="line">b.setColor(red)</span><br><span class="line">b.clearChildren()</span><br><span class="line">ViewC c3 = <span class="keyword">new</span> ViewC(...)</span><br><span class="line">b.add(c3)</span><br></pre></td></tr></table></figure><p>你可能还需要在 ViewB 的构造函数中复制此配置，因为用户界面的数据源可能比实例 b 本身存活更长时间。</p><p>在声明式样式中，视图配置（例如Flutter的小部件）是不可变的，并且只是轻量级的“蓝图”。要更改用户界面，Widget 会在自身上触发重建（最常见的是通过在 Flutter 中的 StatefulWidget 上调用 setState() ）并构造一个新的 Widget 子树。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarative style</span></span><br><span class="line"><span class="keyword">return</span> ViewB(</span><br><span class="line">  color: red,</span><br><span class="line">  child: ViewC(...),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里，Flutter 构建新的 Widget 实例，而不是在用户界面更改时改变旧实例 b。该框架使用RenderObject 管理传统 UI 对象的许多职责（例如维护布局的状态）。 RenderObject 在帧之间保持不变，Flutter 的轻量级 Widget 告诉框架在状态之间改变 RenderObject。 Flutter 框架处理其余部分。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)开始声明式地思考</title>
      <link href="/2019/04/16/Flutter/development/data-and-backend/state-mgmt/declarative/"/>
      <url>/2019/04/16/Flutter/development/data-and-backend/state-mgmt/declarative/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/declarative" target="_blank" rel="noopener">原文链接</a></p><p>如果你是从一个命令式的框架（例如 Android SDK 或是 iOS UIKit ）转而开始学习 Flutter 的，你需要从一个新的角度开始思考应用开发。</p><a id="more"></a><p>许多你可能有的假定在 Flutter 上不再适用。例如，在 Flutter 中从零开始重新构建你的部分用户界面而不去修改它们是没有问题的。Flutter 足够快以至于能做到，如果需要的话甚至可以在每一帧上这么做。</p><p>Flutter 是声明式的。这就意味着 Flutter 构建它的用户界面对你应用的当前状态进行反映：</p><p><img src="https://flutter.cn/assets/development/data-and-backend/state-mgmt/ui-equals-function-of-state-54b01b000694caf9da439bd3f774ef22b00e92a62d3b2ade4f2e95c8555b8ca7.png" alt="img"></p><p>当你的应用的状态发生变化(例如，用户点了下设置界面的一个开关按钮)，你改变了状态，并且状态触发了用户界面的重新绘制。不存在命令式地改变UI本身的方式(比如 widget.setText )-你改变了状态，然后 UI 就从头开始构建。</p><p>想要知道更多关于响应式 UI 编程，就看下这篇<a href="https://jinyulei.cn/2019/04/16/Flutter/get-started/flutter-for/declarative/">使用指南</a>。</p><p>响应式的 UI 编程有许多优点。最显著的优点就是，对于UI的所有状态都只有一条代码路径。你对于所有状态下 UI 应该长什么样描述一次就够了。</p><p>起初，这种编程风格可能看起来不像命令式风格那么直观。这也就是本文存在的原因,让你能够进行思维方式的转变。想要知道更多关于响应式编程的内容,就继续看下去。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)状态管理介绍</title>
      <link href="/2019/04/16/Flutter/development/data-and-backend/state-mgmt/intro/"/>
      <url>/2019/04/16/Flutter/development/data-and-backend/state-mgmt/intro/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/intro" target="_blank" rel="noopener">原文链接</a></p><p>如果你早已熟悉响应式应用中的状态管理，你可以跳过这个部分，不过你可能想要看下 <a href="https://jinyulei.cn/2019/05/30/Flutter/development/data-and-backend/state-mgmt/options/">不同方式的清单</a> </p><a id="more"></a><p><img src="https://flutter.cn/assets/development/data-and-backend/state-mgmt/state-management-explainer-5495afe6c3d6162f145107fe45794583bc4f2b55be377c76a92ab210be74c033.gif" alt="img"></p><p>当你探索 Flutter 时，你需要在应用程序中的页面之间共享应用程序状态。有多种方式供你使用的同时，也有很多问题需要你进行思考。</p><p>在接下来的几篇文章中，你会学到的是在 Flutter 应用程序中处理状态的基础知识。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)使用BloC模式来架构你的Flutter项目(第二部分)</title>
      <link href="/2019/04/15/Flutter/development/data-and-backend/state-mgmt/options/BloC/Architect%20your%20Flutter%20project%20using%20BLOC%20pattern%20(Part%202)/"/>
      <url>/2019/04/15/Flutter/development/data-and-backend/state-mgmt/options/BloC/Architect%20your%20Flutter%20project%20using%20BLOC%20pattern%20(Part%202)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://medium.com/flutterpub/architect-your-flutter-project-using-bloc-pattern-part-2-d8dd1eca9ba5" target="_blank" rel="noopener">原文链接</a></p><p>嗨伙计！本文是我之前的文章“构建您的Flutter项目”的延续。正如我在上一篇文章中所承诺的那样，我将解决当前架构设计中的一些缺陷，并为我们正在构建的应用程序添加一些新功能。在开始旅程之前，让我向你展示四个我们要涉及的地方并对它们进行学习。以下是我们将在本文中介绍的话题。</p><h2 id="我们将讨论的话题："><a href="#我们将讨论的话题：" class="headerlink" title="我们将讨论的话题："></a>我们将讨论的话题：</h2><ol><li>解决当前架构设计中的缺陷</li><li>单实例与范围有限的实例（BLoC访问）</li><li>导航</li><li>RxDart的变形<br>注意：在看下去之前。我强烈建议您阅读我之前的文章，以便更好地了解我们正在构建的应用程序以及我们正在遵循的架构设计（BLoC模式）。</li></ol><a id="more"></a><h2 id="当前架构设计中的缺陷"><a href="#当前架构设计中的缺陷" class="headerlink" title="当前架构设计中的缺陷"></a>当前架构设计中的缺陷</h2><p>在解决问题或讨论变化之前。如果你们读过上篇文章的话，我想你们都一定在会有一个问题，让我来回答这个问题。</p><p>为什么你没有更新上一篇文章而不是写一篇新的文章？</p><p>是!当然我当然可以这样做的。我可以直接向您展示一个可以让您满意的可以工作和无错误的代码。但在这里，我想告诉你在构建这个应用程序时所经历的一切。我遇到的问题或失败。通过这种方式，您可以构建任何Flutter应用程序，并在完成整个过程时调试或解决您遇到的任何问题。不要废话，让我们回到我们的目标。</p><p>如果你已经看过我之前的文章和代码，第一个缺陷是我在MoviesBloc类中创建了一个名为dispose()的方法。此方法负责关闭所有打开的流以避免内存泄漏。我创建了该方法，但从未在movie_list.dart文件中的任何位置调用它，这会导致内存泄漏。另一个主要缺陷是我在构建方法中进行网络请求，这是非常危险的。让我们试着解决这两个主要缺陷。</p><p>目前，MovieList类是一个StatelessWidget，而StatelessWidget的工作方式是，添加到Widget树上的时候build()方法被调用，它的所有属性都是不可变的。build方法是入口，由于配置更改会被多次调用。所以它不是进行任何网络请求的好地方（我在之前的文章中做过）。我们甚至在StatelessWidget中没有一个可以在其中调用bloc的dispose方法。我们必须找到一个可以进行网络请求的地方，最后调用dispose方法。</p><p>要点是StatelessWidget像StatefulWidget那样提供initState和dispose方法。首先调用StatefulWidget中的initState方法来分配资源，并在处理这些分配的资源时调用dispose方法(更多详细内容请看<a href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html" target="_blank" rel="noopener">这里</a>）。因此，让我们将MovieList类从StatelessWidget转换为StatefulWidget，并在StatefulWidget内的initState()作出网络请求，在StatefulWidget内的dispose()调用MovieBloc的dispose()。</p><p>只需用下面的实现替换movie_list.dart代码即可。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../models/item_model.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../blocs/movies_bloc.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieList</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> MovieListState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MovieList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    bloc.fetchAllMovies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    bloc.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Popular Movies'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: StreamBuilder(</span><br><span class="line">        stream: bloc.allMovies,</span><br><span class="line">        builder: (context, AsyncSnapshot&lt;ItemModel&gt; snapshot) &#123;</span><br><span class="line">          <span class="keyword">if</span> (snapshot.hasData) &#123;</span><br><span class="line">            <span class="keyword">return</span> buildList(snapshot);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snapshot.hasError) &#123;</span><br><span class="line">            <span class="keyword">return</span> Text(snapshot.error.toString());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Center(child: CircularProgressIndicator());</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget buildList(AsyncSnapshot&lt;ItemModel&gt; snapshot) &#123;</span><br><span class="line">    <span class="keyword">return</span> GridView.builder(</span><br><span class="line">        itemCount: snapshot.data.results.length,</span><br><span class="line">        gridDelegate:</span><br><span class="line">            <span class="keyword">new</span> SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: <span class="number">2</span>),</span><br><span class="line">        itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">          <span class="keyword">return</span> GridTile(</span><br><span class="line">            child: Image.network(</span><br><span class="line">              <span class="string">'https://image.tmdb.org/t/p/w185<span class="subst">$&#123;snapshot.data</span></span></span><br><span class="line"><span class="string"><span class="subst">                  .results[index].poster_path&#125;</span>'</span>,</span><br><span class="line">              fit: BoxFit.cover,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上的代码中，我在initState()中调用了bloc.fetchAllMovies()，在MovieListState类的dispose()中调用了bloc.dispose()。运行该应用程序，你可以像往常一样看到加载电影列表的应用程序。你不会看到任何视觉上的变化，但在内部你已经确定，不会有任何多次的网络请求，也不会有任何内存泄漏。哇！这看起来很整洁。 😍</p><p>主题演讲：永远不要在构建方法中进行任何网络或数据库调用，并始终确保关闭处于开启状态的流。</p><h2 id="新的功能实现"><a href="#新的功能实现" class="headerlink" title="新的功能实现"></a>新的功能实现</h2><p>现在是我们为现有应用添加新功能的时候了。在我们开始讨论或实现新功能之前。让我向你展示一下。这是一个小视频。</p><p>如你所见，我们添加了一个的页面，你可以在其中查看从列表中选择的特定电影的详细信息。</p><h2 id="让我们规划下应用流程"><a href="#让我们规划下应用流程" class="headerlink" title="让我们规划下应用流程"></a>让我们规划下应用流程</h2><p>在向应用添加任何新功能之前，最好先做一些案头工作(决定流程)。所以在这里我分享了我在分析应用程序的所有功能后想出的应用程序流程。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*dkKlfFewf6CBVbwFIeCNHQ.png" alt></p><p>我想大多数人在看完图表后都会很容易理解这个流程，因为我使用的新术语很少。但是我仍然要解释下上面的图表。</p><ol><li>电影列表页面：这是你可以看到所有电影的网格列表的页面。</li><li>电影列表BloC：这是根据需要从存储库获取数据并将其传递到电影列表页面的桥梁(随后我将对单例机进行解释)。</li><li>电影详细信息页面：在此页面中，您将看到从列表屏幕中选择的电影的详细信息。在这里你可以看到电影的名称，评级，发布日期，描述和预告片（我随后将解释范围有限的实例）。</li><li>仓库：这是控制数据流的中心点。</li><li>API提供者：持有了网络请求的实现。</li></ol><p>现在你一定在想。什么是图中的“单例和范围有限的实例”。让我们详细了解它们。</p><h2 id="单例与范围有限的实例"><a href="#单例与范围有限的实例" class="headerlink" title="单例与范围有限的实例"></a>单例与范围有限的实例</h2><p>如图所示，两个页面都可以访问各自的BLoC类。您可以通过两种方式将这些BLoC类暴露给各自的页面，即单例或范围有限的实例。当我说Single Instance时，我的意思是BLoC类的单个引用（Singleton）将暴露给页面。可以从应用程序的任何部分访问此类型的BLoC类。任何屏幕都可以使用单实例BLoC类。</p><p>但是Scoped Instance BLoC类具有有限的访问权限。我的意思是它只对与它相关联页面或这暴露给的页面是可访问的。这是有一个对其进行解释的小图。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*rID6hLMzUfIwSA6m8UkM2g.png" alt></p><p>正如你在上图中所看到的，只有widget和页面下方的其他2个自定义widget能访问bloc。我们使用的是InheritedWidget，它将BLoC保存在其中。InheritedWidget将 Screen widget进行包装，让Screen widget及其下方的widget可以访问BLoC。Screen Widget的父widget都无法访问BLoC。</p><p>希望您了解单例和范围有限的实例之间的区别。当您使用小型应用程序时，单例访问BLoC的方式非常有用。但是如果你正在开发一个大型项目，那么范围有限的实例是首选方式。</p><h2 id="添加详情页"><a href="#添加详情页" class="headerlink" title="添加详情页"></a>添加详情页</h2><p>是时候将详情页添加到我们的应用程序中。详情页背后的逻辑是，用户将点击电影列表中的电影条目。用户将进入详情页，用户可以在其中查看电影的详细信息。一些细节（电影名称，评级，发布日期，描述，海报）将从列表页面传递到详情页。预告片将从服务器加载。让我们把购物车部分放在一边，先专注于显示从列表页面传递而来的数据。</p><p>在创建文件之前，我希望你使用与上一篇文章中提到相同的项目结构。如果是一样的结构，则在ui包内创建一个名为movie_detail.dart的文件。复制将以下代码粘贴到文件中。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieDetail</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> posterUrl;</span><br><span class="line">  <span class="keyword">final</span> description;</span><br><span class="line">  <span class="keyword">final</span> releaseDate;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> voteAverage;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> movieId;</span><br><span class="line"></span><br><span class="line">  MovieDetail(&#123;</span><br><span class="line">    <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="keyword">this</span>.posterUrl,</span><br><span class="line">    <span class="keyword">this</span>.description,</span><br><span class="line">    <span class="keyword">this</span>.releaseDate,</span><br><span class="line">    <span class="keyword">this</span>.voteAverage,</span><br><span class="line">    <span class="keyword">this</span>.movieId,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> MovieDetailState(</span><br><span class="line">      title: title,</span><br><span class="line">      posterUrl: posterUrl,</span><br><span class="line">      description: description,</span><br><span class="line">      releaseDate: releaseDate,</span><br><span class="line">      voteAverage: voteAverage,</span><br><span class="line">      movieId: movieId,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieDetailState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MovieDetail</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> posterUrl;</span><br><span class="line">  <span class="keyword">final</span> description;</span><br><span class="line">  <span class="keyword">final</span> releaseDate;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> voteAverage;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> movieId;</span><br><span class="line"></span><br><span class="line">  MovieDetailState(&#123;</span><br><span class="line">    <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="keyword">this</span>.posterUrl,</span><br><span class="line">    <span class="keyword">this</span>.description,</span><br><span class="line">    <span class="keyword">this</span>.releaseDate,</span><br><span class="line">    <span class="keyword">this</span>.voteAverage,</span><br><span class="line">    <span class="keyword">this</span>.movieId,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">        top: <span class="keyword">false</span>,</span><br><span class="line">        bottom: <span class="keyword">false</span>,</span><br><span class="line">        child: NestedScrollView(</span><br><span class="line">          headerSliverBuilder: (BuildContext context, <span class="built_in">bool</span> innerBoxIsScrolled) &#123;</span><br><span class="line">            <span class="keyword">return</span> &lt;Widget&gt;[</span><br><span class="line">              SliverAppBar(</span><br><span class="line">                expandedHeight: <span class="number">200.0</span>,</span><br><span class="line">                floating: <span class="keyword">false</span>,</span><br><span class="line">                pinned: <span class="keyword">true</span>,</span><br><span class="line">                elevation: <span class="number">0.0</span>,</span><br><span class="line">                flexibleSpace: FlexibleSpaceBar(</span><br><span class="line">                    background: Image.network(</span><br><span class="line">                  <span class="string">"https://image.tmdb.org/t/p/w500<span class="subst">$posterUrl</span>"</span>,</span><br><span class="line">                  fit: BoxFit.cover,</span><br><span class="line">                )),</span><br><span class="line">              ),</span><br><span class="line">            ];</span><br><span class="line">          &#125;,</span><br><span class="line">          body: Padding(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">            child: Column(</span><br><span class="line">              crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Container(margin: EdgeInsets.only(top: <span class="number">5.0</span>)),</span><br><span class="line">                Text(</span><br><span class="line">                  title,</span><br><span class="line">                  style: TextStyle(</span><br><span class="line">                    fontSize: <span class="number">25.0</span>,</span><br><span class="line">                    fontWeight: FontWeight.bold,</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">                Container(margin: EdgeInsets.only(top: <span class="number">8.0</span>, bottom: <span class="number">8.0</span>)),</span><br><span class="line">                Row(</span><br><span class="line">                  children: &lt;Widget&gt;[</span><br><span class="line">                    Icon(</span><br><span class="line">                      Icons.favorite,</span><br><span class="line">                      color: Colors.red,</span><br><span class="line">                    ),</span><br><span class="line">                    Container(</span><br><span class="line">                      margin: EdgeInsets.only(left: <span class="number">1.0</span>, right: <span class="number">1.0</span>),</span><br><span class="line">                    ),</span><br><span class="line">                    Text(</span><br><span class="line">                      voteAverage,</span><br><span class="line">                      style: TextStyle(</span><br><span class="line">                        fontSize: <span class="number">18.0</span>,</span><br><span class="line">                      ),</span><br><span class="line">                    ),</span><br><span class="line">                    Container(</span><br><span class="line">                      margin: EdgeInsets.only(left: <span class="number">10.0</span>, right: <span class="number">10.0</span>),</span><br><span class="line">                    ),</span><br><span class="line">                    Text(</span><br><span class="line">                      releaseDate,</span><br><span class="line">                      style: TextStyle(</span><br><span class="line">                        fontSize: <span class="number">18.0</span>,</span><br><span class="line">                      ),</span><br><span class="line">                    ),</span><br><span class="line">                  ],</span><br><span class="line">                ),</span><br><span class="line">                Container(margin: EdgeInsets.only(top: <span class="number">8.0</span>, bottom: <span class="number">8.0</span>)),</span><br><span class="line">                Text(description),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所看到的，此类的构造函数需要很少的参数。这些数据将从列表屏幕提供给此类。下一步是实现导航逻辑，将我们从列表页面跳转到详情页。</p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>在Flutter中如果要从一个页面跳转到另一个页面，我们使用的是Navigator类。让我们在movie_list.dart文件中实现导航逻辑。</p><p>因此，想法是，在点击每个网格项目的时候，我们将打开详情页并显示我们从列表页面传递到详情页的内容。这是movie_list.dart文件的代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../models/item_model.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../blocs/movies_bloc.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'movie_detail.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieList</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> MovieListState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MovieList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    bloc.fetchAllMovies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    bloc.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Popular Movies'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: StreamBuilder(</span><br><span class="line">        stream: bloc.allMovies,</span><br><span class="line">        builder: (context, AsyncSnapshot&lt;ItemModel&gt; snapshot) &#123;</span><br><span class="line">          <span class="keyword">if</span> (snapshot.hasData) &#123;</span><br><span class="line">            <span class="keyword">return</span> buildList(snapshot);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snapshot.hasError) &#123;</span><br><span class="line">            <span class="keyword">return</span> Text(snapshot.error.toString());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Center(child: CircularProgressIndicator());</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget buildList(AsyncSnapshot&lt;ItemModel&gt; snapshot) &#123;</span><br><span class="line">    <span class="keyword">return</span> GridView.builder(</span><br><span class="line">        itemCount: snapshot.data.results.length,</span><br><span class="line">        gridDelegate:</span><br><span class="line">        <span class="keyword">new</span> SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: <span class="number">2</span>),</span><br><span class="line">        itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">          <span class="keyword">return</span> GridTile(</span><br><span class="line">            child: InkResponse(</span><br><span class="line">              enableFeedback: <span class="keyword">true</span>,</span><br><span class="line">              child: Image.network(</span><br><span class="line">                <span class="string">'https://image.tmdb.org/t/p/w185<span class="subst">$&#123;snapshot.data</span></span></span><br><span class="line"><span class="string"><span class="subst">                    .results[index].poster_path&#125;</span>'</span>,</span><br><span class="line">                fit: BoxFit.cover,</span><br><span class="line">              ),</span><br><span class="line">              onTap: () =&gt; openDetailPage(snapshot.data, index),</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  openDetailPage(ItemModel data, <span class="built_in">int</span> index) &#123;</span><br><span class="line">    Navigator.push(</span><br><span class="line">      context,</span><br><span class="line">      MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">        <span class="keyword">return</span> MovieDetail(</span><br><span class="line">          title: data.results[index].title,</span><br><span class="line">          posterUrl: data.results[index].backdrop_path,</span><br><span class="line">          description: data.results[index].overview,</span><br><span class="line">          releaseDate: data.results[index].release_date,</span><br><span class="line">          voteAverage: data.results[index].vote_average.toString(),</span><br><span class="line">          movieId: data.results[index].id,</span><br><span class="line">        );</span><br><span class="line">      &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，您可以看到openDetailPage()方法具有导航逻辑。我们将传递将在详情页中显示的数据。运行该应用程序，您可以跳转到新页面。</p><p>哇！我可以跳转了😍<br>现在是时候在详情页面显示预告片了。让我们熟悉下从服务器获取预告片所需的API。点击以下链接就能获得JSON响应体。</p><p><a href="https://api.themoviedb.org/3/movie/" target="_blank" rel="noopener">https://api.themoviedb.org/3/movie/</a><movie_id>/videos?api_key=your_api_key</movie_id></p><p>在上面的API中，我们必须输入两个东西。第一个是movie_id，第二个是api密钥。这是点击链接后返回的响应体。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">299536</span>,</span><br><span class="line">  <span class="attr">"results"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"5a200baa925141033608f5f0"</span>,</span><br><span class="line">      <span class="attr">"iso_639_1"</span>: <span class="string">"en"</span>,</span><br><span class="line">      <span class="attr">"iso_3166_1"</span>: <span class="string">"US"</span>,</span><br><span class="line">      <span class="attr">"key"</span>: <span class="string">"6ZfuNTqbHE8"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Official Trailer"</span>,</span><br><span class="line">      <span class="attr">"site"</span>: <span class="string">"YouTube"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">1080</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Trailer"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"5a200bcc925141032408d21b"</span>,</span><br><span class="line">      <span class="attr">"iso_639_1"</span>: <span class="string">"en"</span>,</span><br><span class="line">      <span class="attr">"iso_3166_1"</span>: <span class="string">"US"</span>,</span><br><span class="line">      <span class="attr">"key"</span>: <span class="string">"sAOzrChqmd0"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Action...Avengers: Infinity War"</span>,</span><br><span class="line">      <span class="attr">"site"</span>: <span class="string">"YouTube"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">720</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Clip"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"5a200bdd0e0a264cca08d39f"</span>,</span><br><span class="line">      <span class="attr">"iso_639_1"</span>: <span class="string">"en"</span>,</span><br><span class="line">      <span class="attr">"iso_3166_1"</span>: <span class="string">"US"</span>,</span><br><span class="line">      <span class="attr">"key"</span>: <span class="string">"3VbHg5fqBYw"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Trailer Tease"</span>,</span><br><span class="line">      <span class="attr">"site"</span>: <span class="string">"YouTube"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">720</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Teaser"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"5a7833440e0a26597f010849"</span>,</span><br><span class="line">      <span class="attr">"iso_639_1"</span>: <span class="string">"en"</span>,</span><br><span class="line">      <span class="attr">"iso_3166_1"</span>: <span class="string">"US"</span>,</span><br><span class="line">      <span class="attr">"key"</span>: <span class="string">"pVxOVlm_lE8"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Big Game Spot"</span>,</span><br><span class="line">      <span class="attr">"site"</span>: <span class="string">"YouTube"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">1080</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Teaser"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"5aabd7e69251413feb011276"</span>,</span><br><span class="line">      <span class="attr">"iso_639_1"</span>: <span class="string">"en"</span>,</span><br><span class="line">      <span class="attr">"iso_3166_1"</span>: <span class="string">"US"</span>,</span><br><span class="line">      <span class="attr">"key"</span>: <span class="string">"QwievZ1Tx-8"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Official Trailer #2"</span>,</span><br><span class="line">      <span class="attr">"site"</span>: <span class="string">"YouTube"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">1080</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Trailer"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"5aea2ed2c3a3682bf7001205"</span>,</span><br><span class="line">      <span class="attr">"iso_639_1"</span>: <span class="string">"en"</span>,</span><br><span class="line">      <span class="attr">"iso_3166_1"</span>: <span class="string">"US"</span>,</span><br><span class="line">      <span class="attr">"key"</span>: <span class="string">"LXPaDL_oILs"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"\"Legacy\" TV Spot"</span>,</span><br><span class="line">      <span class="attr">"site"</span>: <span class="string">"YouTube"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">1080</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Teaser"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"5aea2f3e92514172a7001672"</span>,</span><br><span class="line">      <span class="attr">"iso_639_1"</span>: <span class="string">"en"</span>,</span><br><span class="line">      <span class="attr">"iso_3166_1"</span>: <span class="string">"US"</span>,</span><br><span class="line">      <span class="attr">"key"</span>: <span class="string">"PbRmbhdHDDM"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"\"Family\" Featurette"</span>,</span><br><span class="line">      <span class="attr">"site"</span>: <span class="string">"YouTube"</span>,</span><br><span class="line">      <span class="attr">"size"</span>: <span class="number">1080</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"Featurette"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述响应体，我们需要有一个POJO类。让我们先构建它。在models包中创建名为trailer_model.dart的文件。复制粘贴下面的代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrailerModel</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _id;</span><br><span class="line">  <span class="built_in">List</span>&lt;_Result&gt; _results = [];</span><br><span class="line"></span><br><span class="line">  TrailerModel.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; parsedJson) &#123;</span><br><span class="line">    _id = parsedJson[<span class="string">'id'</span>];</span><br><span class="line">    <span class="built_in">List</span>&lt;_Result&gt; temp = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; parsedJson[<span class="string">'results'</span>].length; i++) &#123;</span><br><span class="line">      _Result result = _Result(parsedJson[<span class="string">'results'</span>][i]);</span><br><span class="line">      temp.add(result);</span><br><span class="line">    &#125;</span><br><span class="line">    _results = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;_Result&gt; <span class="keyword">get</span> results =&gt; _results;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> id =&gt; _id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Result</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> _id;</span><br><span class="line">  <span class="built_in">String</span> _iso_639_1;</span><br><span class="line">  <span class="built_in">String</span> _iso_3166_1;</span><br><span class="line">  <span class="built_in">String</span> _key;</span><br><span class="line">  <span class="built_in">String</span> _name;</span><br><span class="line">  <span class="built_in">String</span> _site;</span><br><span class="line">  <span class="built_in">int</span> _size;</span><br><span class="line">  <span class="built_in">String</span> _type;</span><br><span class="line"></span><br><span class="line">  _Result(result) &#123;</span><br><span class="line">    _id = result[<span class="string">'id'</span>];</span><br><span class="line">    _iso_639_1 = result[<span class="string">'iso_639_1'</span>];</span><br><span class="line">    _iso_3166_1 = result[<span class="string">'iso_3166_1'</span>];</span><br><span class="line">    _key = result[<span class="string">'key'</span>];</span><br><span class="line">    _name = result[<span class="string">'name'</span>];</span><br><span class="line">    _site = result[<span class="string">'site'</span>];</span><br><span class="line">    _size = result[<span class="string">'size'</span>];</span><br><span class="line">    _type = result[<span class="string">'type'</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> id =&gt; _id;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> iso_639_1 =&gt; _iso_639_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> iso_3166_1 =&gt; _iso_3166_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> key =&gt; _key;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name =&gt; _name;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> site =&gt; _site;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> size =&gt; _size;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> type =&gt; _type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们在movie_api_provider.dart实现网络请求。复制并粘贴一下内容到文件中。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:http/http.dart'</span> show Client;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../models/item_model.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../models/trailer_model.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieApiProvider</span> </span>&#123;</span><br><span class="line">  Client client = Client();</span><br><span class="line">  <span class="keyword">final</span> _apiKey = <span class="string">'802b2c4b88ea1183e50e6b285a27696e'</span>;</span><br><span class="line">  <span class="keyword">final</span> _baseUrl = <span class="string">"http://api.themoviedb.org/3/movie"</span>;</span><br><span class="line"></span><br><span class="line">  Future&lt;ItemModel&gt; fetchMovieList() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> response = <span class="keyword">await</span> client.<span class="keyword">get</span>(<span class="string">"<span class="subst">$_baseUrl</span>/popular?api_key=<span class="subst">$_apiKey</span>"</span>);</span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// If the call to the server was successful, parse the JSON</span></span><br><span class="line">      <span class="keyword">return</span> ItemModel.fromJson(json.decode(response.body));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// If that call was not successful, throw an error.</span></span><br><span class="line">      <span class="keyword">throw</span> Exception(<span class="string">'Failed to load post'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;TrailerModel&gt; fetchTrailer(<span class="built_in">int</span> movieId) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> response =</span><br><span class="line">        <span class="keyword">await</span> client.<span class="keyword">get</span>(<span class="string">"<span class="subst">$_baseUrl</span>/<span class="subst">$movieId</span>/videos?api_key=<span class="subst">$_apiKey</span>"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> TrailerModel.fromJson(json.decode(response.body));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> Exception(<span class="string">'Failed to load trailers'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fetchTrailer（movie_id）是我们请求API并将JSON响应转换为TrailerModel对象并返回Future<trailermodel>的方法。</trailermodel></p><p>现在让我们通过添加这个新的网络请求实现来更新repository.dart文件。复制并粘贴repository.dart文件中的代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'movie_api_provider.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../models/item_model.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../models/trailer_model.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Repository</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> moviesApiProvider = MovieApiProvider();</span><br><span class="line"></span><br><span class="line">  Future&lt;ItemModel&gt; fetchAllMovies() =&gt; moviesApiProvider.fetchMovieList();</span><br><span class="line"></span><br><span class="line">  Future&lt;TrailerModel&gt; fetchTrailers(<span class="built_in">int</span> movieId) =&gt; moviesApiProvider.fetchTrailer(movieId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在是实现Scoped Instance BLoC方法的时候了。在blocs包中创建一个新文件movie_detail_bloc.dart。在同一个blocs包中再创建一个文件movie_detail_bloc_provider.dart。</p><p>这是movie_detail_bloc_provider.dart文件的代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'movie_detail_bloc.dart'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="string">'movie_detail_bloc.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieDetailBlocProvider</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> MovieDetailBloc bloc;</span><br><span class="line"></span><br><span class="line">  MovieDetailBlocProvider(&#123;Key key, Widget child&#125;)</span><br><span class="line">      : bloc = MovieDetailBloc(),</span><br><span class="line">        <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> MovieDetailBloc of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> (context.inheritFromWidgetOfExactType(MovieDetailBlocProvider)</span><br><span class="line">            <span class="keyword">as</span> MovieDetailBlocProvider)</span><br><span class="line">        .bloc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类扩展了InheritedWidget，并通过of(context)方法提供对bloc的访问。正如你所见，of(context）期望将context作为参数。此context属于InheritedWidget包装了的页面。在我们的例子中，它是电影详情页。</p><p>让我们编写movie_detail_bloc.dart的代码。将以下代码复制粘贴到bloc文件中。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:rxdart/rxdart.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../models/trailer_model.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../resources/repository.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieDetailBloc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _repository = Repository();</span><br><span class="line">  <span class="keyword">final</span> _movieId = PublishSubject&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">  <span class="keyword">final</span> _trailers = BehaviorSubject&lt;Future&lt;TrailerModel&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Function</span>(<span class="built_in">int</span>) <span class="keyword">get</span> fetchTrailersById =&gt; _movieId.sink.add;</span><br><span class="line">  Observable&lt;Future&lt;TrailerModel&gt;&gt; <span class="keyword">get</span> movieTrailers =&gt; _trailers.stream;</span><br><span class="line"></span><br><span class="line">  MovieDetailBloc() &#123;</span><br><span class="line">    _movieId.stream.transform(_itemTransformer()).pipe(_trailers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dispose() <span class="keyword">async</span> &#123;</span><br><span class="line">    _movieId.close();</span><br><span class="line">    <span class="keyword">await</span> _trailers.drain();</span><br><span class="line">    _trailers.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _itemTransformer() &#123;</span><br><span class="line">    <span class="keyword">return</span> ScanStreamTransformer(</span><br><span class="line">      (Future&lt;TrailerModel&gt; trailer, <span class="built_in">int</span> id, <span class="built_in">int</span> index) &#123;</span><br><span class="line">        <span class="built_in">print</span>(index);</span><br><span class="line">        trailer = _repository.fetchTrailers(id);</span><br><span class="line">        <span class="keyword">return</span> trailer;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我解释一下上面的代码。从服务器获取预告片列表背后的思想是，我们必须将movieId传递给预告片API，它将返回给我们预告片列表。为了实现这个，我们将使用RxDart的一个重要特性，即<a href="https://pub.dartlang.org/documentation/rxdart/latest/rx_transformers/rx_transformers-library.html" target="_blank" rel="noopener">变形</a>。</p><h2 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h2><p>变形的主要作用是帮助链接两个或更多个<a href="https://pub.dartlang.org/documentation/rxdart/latest/rx_subjects/rx_subjects-library.html" target="_blank" rel="noopener">Subject</a>并获得最终的结果。思想是，如果你想在对数据执行某些操作后将数据从一个<a href="https://pub.dartlang.org/documentation/rxdart/latest/rx_subjects/rx_subjects-library.html" target="_blank" rel="noopener">Subject</a>传递到另一个<a href="https://pub.dartlang.org/documentation/rxdart/latest/rx_subjects/rx_subjects-library.html" target="_blank" rel="noopener">Subject</a>。我们将使用变换器对来自第一个<a href="https://pub.dartlang.org/documentation/rxdart/latest/rx_subjects/rx_subjects-library.html" target="_blank" rel="noopener">Subject</a>的输入数据执行操作，并将其传递给下一个<a href="https://pub.dartlang.org/documentation/rxdart/latest/rx_subjects/rx_subjects-library.html" target="_blank" rel="noopener">Subject</a>。</p><p>在我们的应用程序中，我们将movieId添加到_movieId，这是一个<a href="https://pub.dartlang.org/documentation/rxdart/latest/rx/PublishSubject-class.html" target="_blank" rel="noopener">PublishSubject</a>。我们将movieId传递给ScanStreamTransformer，然后ScanStreamTransformer将请求预告片API并获取结果并将其传递给_trailers，这是一个<a href="https://pub.dartlang.org/documentation/rxdart/latest/rx/BehaviorSubject-class.html" target="_blank" rel="noopener">BehaviorSubject</a>。这是一张阐释我的说明的小图。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*8EKpbLKC61gkS8jstJ_9kQ.png" alt></p><p>最后一步是，使MovieDetail页面可以访问movieDetailBloc。为此，我们需要更新openDetailPage()方法。这是movie_list.dart文件的更新代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../models/item_model.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../blocs/movies_bloc.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'movie_detail.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../blocs/movie_detail_bloc_provider.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieList</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> MovieListState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieListState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MovieList</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    bloc.fetchAllMovies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    bloc.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Popular Movies'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: StreamBuilder(</span><br><span class="line">        stream: bloc.allMovies,</span><br><span class="line">        builder: (context, AsyncSnapshot&lt;ItemModel&gt; snapshot) &#123;</span><br><span class="line">          <span class="keyword">if</span> (snapshot.hasData) &#123;</span><br><span class="line">            <span class="keyword">return</span> buildList(snapshot);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snapshot.hasError) &#123;</span><br><span class="line">            <span class="keyword">return</span> Text(snapshot.error.toString());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Center(child: CircularProgressIndicator());</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget buildList(AsyncSnapshot&lt;ItemModel&gt; snapshot) &#123;</span><br><span class="line">    <span class="keyword">return</span> GridView.builder(</span><br><span class="line">        itemCount: snapshot.data.results.length,</span><br><span class="line">        gridDelegate:</span><br><span class="line">        <span class="keyword">new</span> SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: <span class="number">2</span>),</span><br><span class="line">        itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">          <span class="keyword">return</span> GridTile(</span><br><span class="line">            child: InkResponse(</span><br><span class="line">              enableFeedback: <span class="keyword">true</span>,</span><br><span class="line">              child: Image.network(</span><br><span class="line">                <span class="string">'https://image.tmdb.org/t/p/w185<span class="subst">$&#123;snapshot.data</span></span></span><br><span class="line"><span class="string"><span class="subst">                    .results[index].poster_path&#125;</span>'</span>,</span><br><span class="line">                fit: BoxFit.cover,</span><br><span class="line">              ),</span><br><span class="line">              onTap: () =&gt; openDetailPage(snapshot.data, index),</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  openDetailPage(ItemModel data, <span class="built_in">int</span> index) &#123;</span><br><span class="line">    Navigator.push(</span><br><span class="line">      context,</span><br><span class="line">      MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">        <span class="keyword">return</span> MovieDetailBlocProvider(</span><br><span class="line">          child: MovieDetail(</span><br><span class="line">            title: data.results[index].title,</span><br><span class="line">            posterUrl: data.results[index].backdrop_path,</span><br><span class="line">            description: data.results[index].overview,</span><br><span class="line">            releaseDate: data.results[index].release_date,</span><br><span class="line">            voteAverage: data.results[index].vote_average.toString(),</span><br><span class="line">            movieId: data.results[index].id,</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您在MaterialPageRoute中看到的那样，我们将返回MovieDetailBlocProvider（InheritedWidget）并将MovieDetail页面包装到其中。这样MovieDetailBloc类就可以在详情页面以及它下面的所有widget中访问。</p><p>最后，这是movie_detail.dart文件的代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../blocs/movie_detail_bloc_provider.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../models/trailer_model.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieDetail</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> posterUrl;</span><br><span class="line">  <span class="keyword">final</span> description;</span><br><span class="line">  <span class="keyword">final</span> releaseDate;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> voteAverage;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> movieId;</span><br><span class="line"></span><br><span class="line">  MovieDetail(&#123;</span><br><span class="line">    <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="keyword">this</span>.posterUrl,</span><br><span class="line">    <span class="keyword">this</span>.description,</span><br><span class="line">    <span class="keyword">this</span>.releaseDate,</span><br><span class="line">    <span class="keyword">this</span>.voteAverage,</span><br><span class="line">    <span class="keyword">this</span>.movieId,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> MovieDetailState(</span><br><span class="line">      title: title,</span><br><span class="line">      posterUrl: posterUrl,</span><br><span class="line">      description: description,</span><br><span class="line">      releaseDate: releaseDate,</span><br><span class="line">      voteAverage: voteAverage,</span><br><span class="line">      movieId: movieId,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieDetailState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MovieDetail</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> posterUrl;</span><br><span class="line">  <span class="keyword">final</span> description;</span><br><span class="line">  <span class="keyword">final</span> releaseDate;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> voteAverage;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> movieId;</span><br><span class="line"></span><br><span class="line">  MovieDetailBloc bloc;</span><br><span class="line"></span><br><span class="line">  MovieDetailState(&#123;</span><br><span class="line">    <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="keyword">this</span>.posterUrl,</span><br><span class="line">    <span class="keyword">this</span>.description,</span><br><span class="line">    <span class="keyword">this</span>.releaseDate,</span><br><span class="line">    <span class="keyword">this</span>.voteAverage,</span><br><span class="line">    <span class="keyword">this</span>.movieId,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    bloc = MovieDetailBlocProvider.of(context);</span><br><span class="line">    bloc.fetchTrailersById(movieId);</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    bloc.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">        top: <span class="keyword">false</span>,</span><br><span class="line">        bottom: <span class="keyword">false</span>,</span><br><span class="line">        child: NestedScrollView(</span><br><span class="line">          headerSliverBuilder: (BuildContext context,</span><br><span class="line">              <span class="built_in">bool</span> innerBoxIsScrolled) &#123;</span><br><span class="line">            <span class="keyword">return</span> &lt;Widget&gt;[</span><br><span class="line">              SliverAppBar(</span><br><span class="line">                expandedHeight: <span class="number">200.0</span>,</span><br><span class="line">                floating: <span class="keyword">false</span>,</span><br><span class="line">                pinned: <span class="keyword">true</span>,</span><br><span class="line">                elevation: <span class="number">0.0</span>,</span><br><span class="line">                flexibleSpace: FlexibleSpaceBar(</span><br><span class="line">                    background: Image.network(</span><br><span class="line">                      <span class="string">"https://image.tmdb.org/t/p/w500<span class="subst">$posterUrl</span>"</span>,</span><br><span class="line">                      fit: BoxFit.cover,</span><br><span class="line">                    )),</span><br><span class="line">              ),</span><br><span class="line">            ];</span><br><span class="line">          &#125;,</span><br><span class="line">          body: Padding(</span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">            child: Column(</span><br><span class="line">              crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Container(margin: EdgeInsets.only(top: <span class="number">5.0</span>)),</span><br><span class="line">                Text(</span><br><span class="line">                  title,</span><br><span class="line">                  style: TextStyle(</span><br><span class="line">                    fontSize: <span class="number">25.0</span>,</span><br><span class="line">                    fontWeight: FontWeight.bold,</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">                Container(margin: EdgeInsets.only(top: <span class="number">8.0</span>,</span><br><span class="line">                    bottom: <span class="number">8.0</span>)),</span><br><span class="line">                Row(</span><br><span class="line">                  children: &lt;Widget&gt;[</span><br><span class="line">                    Icon(</span><br><span class="line">                      Icons.favorite,</span><br><span class="line">                      color: Colors.red,</span><br><span class="line">                    ),</span><br><span class="line">                    Container(</span><br><span class="line">                      margin: EdgeInsets.only(left: <span class="number">1.0</span>,</span><br><span class="line">                          right: <span class="number">1.0</span>),</span><br><span class="line">                    ),</span><br><span class="line">                    Text(</span><br><span class="line">                      voteAverage,</span><br><span class="line">                      style: TextStyle(</span><br><span class="line">                        fontSize: <span class="number">18.0</span>,</span><br><span class="line">                      ),</span><br><span class="line">                    ),</span><br><span class="line">                    Container(</span><br><span class="line">                      margin: EdgeInsets.only(left: <span class="number">10.0</span>,</span><br><span class="line">                          right: <span class="number">10.0</span>),</span><br><span class="line">                    ),</span><br><span class="line">                    Text(</span><br><span class="line">                      releaseDate,</span><br><span class="line">                      style: TextStyle(</span><br><span class="line">                        fontSize: <span class="number">18.0</span>,</span><br><span class="line">                      ),</span><br><span class="line">                    ),</span><br><span class="line">                  ],</span><br><span class="line">                ),</span><br><span class="line">                Container(margin: EdgeInsets.only(top: <span class="number">8.0</span>,</span><br><span class="line">                    bottom: <span class="number">8.0</span>)),</span><br><span class="line">                Text(description),</span><br><span class="line">                Container(margin: EdgeInsets.only(top: <span class="number">8.0</span>,</span><br><span class="line">                    bottom: <span class="number">8.0</span>)),</span><br><span class="line">                Text(</span><br><span class="line">                  <span class="string">"Trailer"</span>,</span><br><span class="line">                  style: TextStyle(</span><br><span class="line">                    fontSize: <span class="number">25.0</span>,</span><br><span class="line">                    fontWeight: FontWeight.bold,</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">                Container(margin: EdgeInsets.only(top: <span class="number">8.0</span>,</span><br><span class="line">                    bottom: <span class="number">8.0</span>)),</span><br><span class="line">                StreamBuilder(</span><br><span class="line">                  stream: bloc.movieTrailers,</span><br><span class="line">                  builder:</span><br><span class="line">                      (context, AsyncSnapshot&lt;Future&lt;TrailerModel&gt;&gt; snapshot) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (snapshot.hasData) &#123;</span><br><span class="line">                      <span class="keyword">return</span> FutureBuilder(</span><br><span class="line">                        future: snapshot.data,</span><br><span class="line">                        builder: (context,</span><br><span class="line">                            AsyncSnapshot&lt;TrailerModel&gt; itemSnapShot) &#123;</span><br><span class="line">                          <span class="keyword">if</span> (itemSnapShot.hasData) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (itemSnapShot.data.results.length &gt; <span class="number">0</span>)</span><br><span class="line">                              <span class="keyword">return</span> trailerLayout(itemSnapShot.data);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                              <span class="keyword">return</span> noTrailer(itemSnapShot.data);</span><br><span class="line">                          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> Center(child: CircularProgressIndicator());</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                      );</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">return</span> Center(child: CircularProgressIndicator());</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;,</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget noTrailer(TrailerModel data) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Container(</span><br><span class="line">        child: Text(<span class="string">"No trailer available"</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget trailerLayout(TrailerModel data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.results.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Row(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          trailerItem(data, <span class="number">0</span>),</span><br><span class="line">          trailerItem(data, <span class="number">1</span>),</span><br><span class="line">        ],</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Row(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          trailerItem(data, <span class="number">0</span>),</span><br><span class="line">        ],</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  trailerItem(TrailerModel data, <span class="built_in">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> Expanded(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Container(</span><br><span class="line">            margin: EdgeInsets.all(<span class="number">5.0</span>),</span><br><span class="line">            height: <span class="number">100.0</span>,</span><br><span class="line">            color: Colors.grey,</span><br><span class="line">            child: Center(child: Icon(Icons.play_circle_filled)),</span><br><span class="line">          ),</span><br><span class="line">          Text(</span><br><span class="line">            data.results[index].name,</span><br><span class="line">            maxLines: <span class="number">1</span>,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有很多事情需要注意。我们之所以在didChangeDependencies()中初始化MovieDetailBloc的原因是<a href="https://docs.flutter.io/flutter/widgets/SingleTickerProviderStateMixin/didChangeDependencies.html" target="_blank" rel="noopener">这个</a>。你还可以看到StreamBuilder的快照数据包含Future<trailermodel>，它只能由FutureBuilder使用。</trailermodel></p><p>我不会深入解释这些内容，因为这篇文章已经变得越来越大，我已经介绍了很多新东西。如果您需要任何帮助，请随时通过LinkedIn，Twitter与我联系或在下面发表您的评论。</p><p>我希望你喜欢这些内容并学到很多新东西。我只想告诉你，起初很难理解它。相信我，如果你进一步阅读我在这里触及的所有话题，你会发现它非常简单。请大声👏</p><p>如果你想要完整的代码。这是项目的<a href="https://github.com/SAGARSURI/MyMovies" target="_blank" rel="noopener">github地址</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
            <tag> BLoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)使用BloC模式来架构你的Flutter项目</title>
      <link href="/2019/04/15/Flutter/development/data-and-backend/state-mgmt/options/BloC/Architect%20your%20Flutter%20project%20using%20BLOC%20pattern/"/>
      <url>/2019/04/15/Flutter/development/data-and-backend/state-mgmt/options/BloC/Architect%20your%20Flutter%20project%20using%20BLOC%20pattern/</url>
      
        <content type="html"><![CDATA[<p><a href="https://medium.com/flutterpub/architecting-your-flutter-project-bd04e144a8f1" target="_blank" rel="noopener">原文链接</a></p><p>大家好。我带着一篇新的关于Flutter的文章回来了。这一次，我将向你展示“如何架构你的Flutter项目”。这样您就可以轻松维护，扩展和测试Flutter项目。在深入探讨实际话题之前。我想分享一个小故事，说明为什么我们应该专注于为我们的项目构建一个坚实的架构。</p><p>更新：本文的第2部分已发布，当前设计中有一些更改，以解决一些问题并展示一些惊人的实现。链接在<a href="Architect-your-Flutter-project-using-BLOC-pattern-(Part-2).html">这里</a>。</p><a id="more"></a><h2 id="为什么你需要对你的项目进行架构"><a href="#为什么你需要对你的项目进行架构" class="headerlink" title="为什么你需要对你的项目进行架构"></a>为什么你需要对你的项目进行架构</h2><p>多年前的2015年，我是还是一名求胜心切的新手程序员，当时我在学习Android应用程序开发。作为一个求胜心切的程序员，我只关心我编写的程序的输出和效率。我从未想过对我编写的程序或项目进行架构。这种趋势和风格也反映在我的android项目中。我是用求胜心切的程序员的心态编写Android应用程序。起初我一个写项目的时候，一切都很好，因为从来没有老板或经理可以给我添加新功能或更改应用程序中现有功能的需求。但是当我开始在创业公司工作并为他们构建Android应用程序时。我总是花很多时间来更改应用中的现有功能。不仅如此，我甚至在构建应用程序的过程中还附加了bug。所有这些问题的主要根源是“我从未遵循任何架构模式或从未架构过我的项目”。随着时间的推移，我开始了解软件世界，我将自己从求胜心切的程序员转变为软件工程师。今天，每当我开始一个新项目时，我的主要目标是建立一个坚固的项目结构或架构。这帮助我成为一个更好，更没有压力的软件工程师😄。</p><p>结束我无聊的故事😅。让我们开始研究本文的主要目标。 “使用BLOC模式构建您的Flutter项目”</p><h2 id="我们的目标"><a href="#我们的目标" class="headerlink" title="我们的目标"></a>我们的目标</h2><p>我将构建一个非常简单的应用程序。它将有一个页面，您可以在这个页面中看到条目的网格列表。这些条目将从服务器获取。条目列表将是从The Movies DB网站获取的热门电影。</p><p>注意：在进一步之前，我假定您了解<a href="https://docs.flutter.io/flutter/widgets/Widget-class.html" target="_blank" rel="noopener">Widgets</a>，<a href="https://medium.com/flutterpub/making-a-network-call-in-flutter-f712f2137109" target="_blank" rel="noopener">如何在Flutter中进行网络调用</a>以及在Dart中具有中级了解。本文将有点冗长，并且链向了大量的其他资源，从而你能够更多地了解具体的话题。</p><p>开始我们的表演。 😍</p><p>在直接深入代码之前。让我给你看下架构图，我们会遵照这个图来架构这个应用。<br><img src="https://cdn-images-1.medium.com/max/800/1*MqYPYKdNBiID0mZ-zyE-mA.png" alt></p><p>Bloc 模式</p><p>上图展示了数据是如何从UI流向数据层，以及如何从UI层流向数据层。 BLOC永远不会持有UI页面中的任何widget。UI页面只会观察来自BLOC类的变化。让我们通过问答的形式来理解这个图：</p><h3 id="1-什么是BLOC模式？"><a href="#1-什么是BLOC模式？" class="headerlink" title="1.什么是BLOC模式？"></a>1.什么是BLOC模式？</h3><p>它是Google开发人员推荐的Flutter状态管理系统。它有助于管理状态并从项目的中心位置访问数据。</p><h3 id="2-我可以将此架构与其他任何架构联系起来吗？"><a href="#2-我可以将此架构与其他任何架构联系起来吗？" class="headerlink" title="2.我可以将此架构与其他任何架构联系起来吗？"></a>2.我可以将此架构与其他任何架构联系起来吗？</h3><p>当然可以。MVP和MVVM就是一个很好的例子。唯一变化的是：BLOC取代了MVVM中的ViewModel。</p><h3 id="3-BLOC的底层是什么？或者在一处管理状态的核心是什么？"><a href="#3-BLOC的底层是什么？或者在一处管理状态的核心是什么？" class="headerlink" title="3. BLOC的底层是什么？或者在一处管理状态的核心是什么？"></a>3. BLOC的底层是什么？或者在一处管理状态的核心是什么？</h3><p>以STREAMS或REACTIVE的方法。一般而言，数据将以流的形式从BLOC流向UI或从UI流向BLOC。如果你从未听说过流。阅读此<a href="https://stackoverflow.com/a/1216397/8327394" target="_blank" rel="noopener">Stack Overflow上的回答</a>。</p><p>希望这个简短的问答环节消除了你的一些疑虑。</p><p>让我们开始用BLOC模式构建项目</p><p>1.首先创建一个新项目并清除main.dart文件中的所有代码。在终端中输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create myProjectName</span><br></pre></td></tr></table></figure><p>2.在你的main.dart的文件中写下以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'src/app.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  runApp(App());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二行会有错误。我们将在下一步中解决它。</p><p>3.在lib包下创建一个src包。在src包中创建一个文件并将其命名为app.dart。将以下代码复制到app.dart文件中。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'ui/movie_list.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">        theme: ThemeData.dark(),</span><br><span class="line">        home: Scaffold(</span><br><span class="line">          body: MovieList(),</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.在src包下创建一个新的包并将其命名为resources。</p><p>现在创建一些新的包，即blocs，models，resources和ui，如下图所示，然后我们就设置好项目的框架：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*ptxnhV5gsEyKAj6wliRMaw.png" alt></p><p>blocs包将保存我们的BLOC实现相关文件。 models包将保存POJO类或我们将从服务器获取的JSON响应体的模型类。 resources包将保存存储库类和网络调用实现类。 ui包将保存我们的屏幕，用户可以看到它们。</p><p>5.我们要补充的最后一件事就是RxDart第三方库。打开pubspec.yaml文件并添加rxdart：^ 0.18.0，如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  flutter:</span></span><br><span class="line"><span class="attr">    sdk:</span> <span class="string">flutter</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># The following adds the Cupertino Icons font to your application.</span></span><br><span class="line">  <span class="comment"># Use with the CupertinoIcons class for iOS style icons.</span></span><br><span class="line"><span class="attr">  cupertino_icons:</span> <span class="string">^0.1.2</span></span><br><span class="line"><span class="attr">  rxdart:</span> <span class="string">^0.18.0</span></span><br><span class="line"><span class="attr">  http:</span> <span class="string">^0.12.0+1</span></span><br></pre></td></tr></table></figure><p>同步你的项目或在终端输入以下命令。确保在项目目录中执行此命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages get</span><br></pre></td></tr></table></figure><p>6.现在我们完成了项目的骨架。是时候处理项目的最底层，即网络层。让我们熟悉下我们将要使用的API端点。点击<a href="https://www.themoviedb.org/account/signup" target="_blank" rel="noopener">此链接</a>，您将进入电影数据库API站点。注册并从“设置”页面获取API密钥。我们将点击以下网址获取回复：</p><p>ttp://api.themoviedb.org/3/movie/popular?api_key=”your_api_key”</p><p>将您的API密钥放在上面的链接中并点击（删除双引号）。你可以看到这样的JSON响应体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"page"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"total_results"</span>: <span class="number">19772</span>,</span><br><span class="line">  <span class="attr">"total_pages"</span>: <span class="number">989</span>,</span><br><span class="line">  <span class="attr">"results"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"vote_count"</span>: <span class="number">6503</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">299536</span>,</span><br><span class="line">      <span class="attr">"video"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"vote_average"</span>: <span class="number">8.3</span>,</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"Avengers: Infinity War"</span>,</span><br><span class="line">      <span class="attr">"popularity"</span>: <span class="number">350.154</span>,</span><br><span class="line">      <span class="attr">"poster_path"</span>: <span class="string">"\/7WsyChQLEftFiDOVTGkv3hFpyyt.jpg"</span>,</span><br><span class="line">      <span class="attr">"original_language"</span>: <span class="string">"en"</span>,</span><br><span class="line">      <span class="attr">"original_title"</span>: <span class="string">"Avengers: Infinity War"</span>,</span><br><span class="line">      <span class="attr">"genre_ids"</span>: [</span><br><span class="line">        <span class="number">12</span>,</span><br><span class="line">        <span class="number">878</span>,</span><br><span class="line">        <span class="number">14</span>,</span><br><span class="line">        <span class="number">28</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"backdrop_path"</span>: <span class="string">"\/bOGkgRGdhrBYJSLpXaxhXVstddV.jpg"</span>,</span><br><span class="line">      <span class="attr">"adult"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"overview"</span>: <span class="string">"As the Avengers and their allies have continued to protect the world from threats too large for any one hero to handle, a new danger has emerged from the cosmic shadows: Thanos. A despot of intergalactic infamy, his goal is to collect all six Infinity Stones, artifacts of unimaginable power, and use them to inflict his twisted will on all of reality. Everything the Avengers have fought for has led up to this moment - the fate of Earth and existence itself has never been more uncertain."</span>,</span><br><span class="line">      <span class="attr">"release_date"</span>: <span class="string">"2018-04-25"</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>7.让我们为这种类型的响应构建一个模型或POJO类。在模型包中创建一个新文件，并将其命名为item_model.dart。将以下代码复制并粘贴到item_model.dart文件中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemModel</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _page;</span><br><span class="line">  <span class="built_in">int</span> _total_results;</span><br><span class="line">  <span class="built_in">int</span> _total_pages;</span><br><span class="line">  <span class="built_in">List</span>&lt;_Result&gt; _results = [];</span><br><span class="line"></span><br><span class="line">  ItemModel.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; parsedJson) &#123;</span><br><span class="line">    <span class="built_in">print</span>(parsedJson[<span class="string">'results'</span>].length);</span><br><span class="line">    _page = parsedJson[<span class="string">'page'</span>];</span><br><span class="line">    _total_results = parsedJson[<span class="string">'total_results'</span>];</span><br><span class="line">    _total_pages = parsedJson[<span class="string">'total_pages'</span>];</span><br><span class="line">    <span class="built_in">List</span>&lt;_Result&gt; temp = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; parsedJson[<span class="string">'results'</span>].length; i++) &#123;</span><br><span class="line">      _Result result = _Result(parsedJson[<span class="string">'results'</span>][i]);</span><br><span class="line">      temp.add(result);</span><br><span class="line">    &#125;</span><br><span class="line">    _results = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;_Result&gt; <span class="keyword">get</span> results =&gt; _results;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> total_pages =&gt; _total_pages;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> total_results =&gt; _total_results;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> page =&gt; _page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Result</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _vote_count;</span><br><span class="line">  <span class="built_in">int</span> _id;</span><br><span class="line">  <span class="built_in">bool</span> _video;</span><br><span class="line">  <span class="keyword">var</span> _vote_average;</span><br><span class="line">  <span class="built_in">String</span> _title;</span><br><span class="line">  <span class="built_in">double</span> _popularity;</span><br><span class="line">  <span class="built_in">String</span> _poster_path;</span><br><span class="line">  <span class="built_in">String</span> _original_language;</span><br><span class="line">  <span class="built_in">String</span> _original_title;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; _genre_ids = [];</span><br><span class="line">  <span class="built_in">String</span> _backdrop_path;</span><br><span class="line">  <span class="built_in">bool</span> _adult;</span><br><span class="line">  <span class="built_in">String</span> _overview;</span><br><span class="line">  <span class="built_in">String</span> _release_date;</span><br><span class="line"></span><br><span class="line">  _Result(result) &#123;</span><br><span class="line">    _vote_count = result[<span class="string">'vote_count'</span>];</span><br><span class="line">    _id = result[<span class="string">'id'</span>];</span><br><span class="line">    _video = result[<span class="string">'video'</span>];</span><br><span class="line">    _vote_average = result[<span class="string">'vote_average'</span>];</span><br><span class="line">    _title = result[<span class="string">'title'</span>];</span><br><span class="line">    _popularity = result[<span class="string">'popularity'</span>];</span><br><span class="line">    _poster_path = result[<span class="string">'poster_path'</span>];</span><br><span class="line">    _original_language = result[<span class="string">'original_language'</span>];</span><br><span class="line">    _original_title = result[<span class="string">'original_title'</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; result[<span class="string">'genre_ids'</span>].length; i++) &#123;</span><br><span class="line">      _genre_ids.add(result[<span class="string">'genre_ids'</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    _backdrop_path = result[<span class="string">'backdrop_path'</span>];</span><br><span class="line">    _adult = result[<span class="string">'adult'</span>];</span><br><span class="line">    _overview = result[<span class="string">'overview'</span>];</span><br><span class="line">    _release_date = result[<span class="string">'release_date'</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> release_date =&gt; _release_date;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> overview =&gt; _overview;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> adult =&gt; _adult;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> backdrop_path =&gt; _backdrop_path;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> genre_ids =&gt; _genre_ids;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> original_title =&gt; _original_title;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> original_language =&gt; _original_language;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> poster_path =&gt; _poster_path;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> popularity =&gt; _popularity;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> title =&gt; _title;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> <span class="keyword">get</span> vote_average =&gt; _vote_average;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> video =&gt; _video;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> id =&gt; _id;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> vote_count =&gt; _vote_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我希望你可以吧这个文件和JSON响应体一一对应。如果不能一一对应的话，我们最感兴趣的是Results类中的poster_path，这是你需要进一步知道的。我们将在主UI中显示所有热门电影的海报。 fromJson()方法仅仅是获取解码后的json并将值放入正确的变量。</p><p>8.是时候开始网络实现方面的工作了。在资源包中创建一个文件，并将其命名为movie_api_provider.dart。将以下代码复制并粘贴到文件中，我将向你解释：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:http/http.dart'</span> show Client;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../models/item_model.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieApiProvider</span> </span>&#123;</span><br><span class="line">  Client client = Client();</span><br><span class="line">  <span class="keyword">final</span> _apiKey = <span class="string">'your_api_key'</span>;</span><br><span class="line"></span><br><span class="line">  Future&lt;ItemModel&gt; fetchMovieList() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"entered"</span>);</span><br><span class="line">    <span class="keyword">final</span> response = <span class="keyword">await</span> client</span><br><span class="line">        .<span class="keyword">get</span>(<span class="string">"http://api.themoviedb.org/3/movie/popular?api_key=<span class="subst">$_apiKey</span>"</span>);</span><br><span class="line">    <span class="built_in">print</span>(response.body.toString());</span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// If the call to the server was successful, parse the JSON</span></span><br><span class="line">      <span class="keyword">return</span> ItemModel.fromJson(json.decode(response.body));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// If that call was not successful, throw an error.</span></span><br><span class="line">      <span class="keyword">throw</span> Exception(<span class="string">'Failed to load post'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：请将您的API密钥放在movie_api_provider.dart文件中的变量_apiKey中，否则它是不能工作的。</p><p>fetchMovieList()方法对API作出了网络请求。网络请求完成后，如果网络请求成功，它将返回Future ItemModel对象，否则将抛出异常。</p><p>9.接下来，我们将在资源包中创建一个新文件，并将其命名为repository.dart。将以下代码复制并粘贴到文件中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'movie_api_provider.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../models/item_model.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Repository</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> moviesApiProvider = MovieApiProvider();</span><br><span class="line"></span><br><span class="line">  Future&lt;ItemModel&gt; fetchAllMovies() =&gt; moviesApiProvider.fetchMovieList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们正在导入movie_api_provider.dart文件并调用其fetchMovieList()方法。此Repository类是数据流向BLOC的中心点。</p><p>10.现在有点复杂。实现bloc逻辑。让我们在blocs包中创建一个新文件，并将其命名为movies_bloc.dart。复制下面的代码粘贴，我将向您详细解释代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'../resources/repository.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:rxdart/rxdart.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../models/item_model.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoviesBloc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _repository = Repository();</span><br><span class="line">  <span class="keyword">final</span> _moviesFetcher = PublishSubject&lt;ItemModel&gt;();</span><br><span class="line"></span><br><span class="line">  Observable&lt;ItemModel&gt; <span class="keyword">get</span> allMovies =&gt; _moviesFetcher.stream;</span><br><span class="line"></span><br><span class="line">  fetchAllMovies() <span class="keyword">async</span> &#123;</span><br><span class="line">    ItemModel itemModel = <span class="keyword">await</span> _repository.fetchAllMovies();</span><br><span class="line">    _moviesFetcher.sink.add(itemModel);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dispose() &#123;</span><br><span class="line">    _moviesFetcher.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> bloc = MoviesBloc();</span><br></pre></td></tr></table></figure><p>我们正在导入一个包导入’包：rxdart/rxdart.dart’;最终将导入此文件中所有与RxDart相关的方法和类。在MoviesBloc类中，我们创建了Repository类对象，该对象将用于访问fetchAllMovies()。我们创建一个PublishSubject对象，该对象的职责是以ItemModel对象的形式添加从服务器获取的数据，并将其作为流传递给UI页面。要将ItemModel对象作为流传递，我们创建了另一个方法allMovies()，其返回类型为<a href="https://youtu.be/XbOuCBuQepI" target="_blank" rel="noopener">Observable</a>（如果您不理解Observable，请观看此视频）。如果你看到最后一行,我们创建了bloc对象。这样我们就可以将一个MoviesBloc类的实例访问能力给到到UI页面。</p><p>如果你不知道什么是响应式编程。请看下这个简单的解释。简而言之，只要有来自服务器的新数据，我们就必须更新UI屏幕。为了使这个更新任务变得简单，我们告诉UI页面继续观察来自MoviesBloc类的任何变更并相应地更新你的内容。这种“观察”新数据的工作可以使用RxDart完成。</p><p>11.现在是最后一节。在ui包中创建一个新文件，并将其命名为movie_list.dart。复制粘贴以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../models/item_model.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'../blocs/movies_bloc.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieList</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    bloc.fetchAllMovies();</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Popular Movies'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: StreamBuilder(</span><br><span class="line">        stream: bloc.allMovies,</span><br><span class="line">        builder: (context, AsyncSnapshot&lt;ItemModel&gt; snapshot) &#123;</span><br><span class="line">          <span class="keyword">if</span> (snapshot.hasData) &#123;</span><br><span class="line">            <span class="keyword">return</span> buildList(snapshot);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snapshot.hasError) &#123;</span><br><span class="line">            <span class="keyword">return</span> Text(snapshot.error.toString());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Center(child: CircularProgressIndicator());</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget buildList(AsyncSnapshot&lt;ItemModel&gt; snapshot) &#123;</span><br><span class="line">    <span class="keyword">return</span> GridView.builder(</span><br><span class="line">        itemCount: snapshot.data.results.length,</span><br><span class="line">        gridDelegate:</span><br><span class="line">            <span class="keyword">new</span> SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: <span class="number">2</span>),</span><br><span class="line">        itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">          <span class="keyword">return</span> Image.network(</span><br><span class="line">            <span class="string">'https://image.tmdb.org/t/p/w185<span class="subst">$&#123;snapshot.data</span></span></span><br><span class="line"><span class="string"><span class="subst">                .results[index].poster_path&#125;</span>'</span>,</span><br><span class="line">            fit: BoxFit.cover,</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的最好以及有趣的部分是，我没有使用StatefulWidget。但我使用的是StreamBuilder，它将执行StatefulWidget所做的更新UI的工作。</p><p>有一点需要指出，我在构建方法中进行网络请求，这是不应该像build(context)方法那样多次调用。文章更新中会有更好的方法。但是现在，随着文章变得越来越复杂，我保持简单，即在build(Context)方法中进行网络请求。</p><p>正如我告诉你的，我们的MoviesBloc类将新数据作为流传递。因此，为了处理流，我们有一个很好的内置类，即StreamBuilder，它将监听传入的流并相应地更新UI。 StreamBuilder期待一个流参数，我们在它返回流时传递MovieBloc的allMovies()方法。因此，当有数据流出现时，StreamBuilder将使用最新数据重新渲染widget。这里快照数据持有着ItemModel对象。现在你可以使用任意Widget来呈现对象中的内容了（这里就靠你的想象力了）。我使用GridView呈现了ItemModel列表中的所有海报。<br>如果你想要完整的代码。这是项目的<a href="https://github.com/SAGARSURI/MyMovies" target="_blank" rel="noopener">github地址</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
            <tag> BLoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Dart中适用于序列化的built_value</title>
      <link href="/2019/04/15/Flutter/development/data-and-backend/json%20serialization/built_value%20for%20%20Serialization/"/>
      <url>/2019/04/15/Flutter/development/data-and-backend/json%20serialization/built_value%20for%20%20Serialization/</url>
      
        <content type="html"><![CDATA[<p><a href="https://medium.com/dartlang/darts-built-value-for-serialization-f5db9d0f4159" target="_blank" rel="noopener">原文链接</a></p><p>上周，我介绍了<a href="built_value-for-Immutable-Object-Models.html">适用于不可修改对象模型的built_value</a>。我们看到了如何在built_value中定义对象模型;它们是不变的，易于使用，如果你喜欢那种东西，那就很有趣了。</p><p>本文介绍了built_value包的其余部分。最重要的是，正如你可能从标题中猜到的那样，它们也是可序列化的。</p><a id="more"></a><p>以下是built_value序列化的用法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Value type defined using built_value.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">implements</span> <span class="title">Built</span>&lt;<span class="title">Login</span>, <span class="title">LoginBuilder</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Add serialization support by defining this static getter.</span></span><br><span class="line">  <span class="keyword">static</span> Serializer&lt;Login&gt; <span class="keyword">get</span> serializer =&gt; _$loginSerializer;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Once per app, define a top level "Serializer" to gather together</span></span><br><span class="line"><span class="comment">// all the generated serializers.</span></span><br><span class="line">Serializers serializers = _$serializers;</span><br><span class="line"><span class="comment">// Use it!</span></span><br><span class="line"><span class="keyword">var</span> login = <span class="keyword">new</span> Login((b) =&gt; b</span><br><span class="line">  ..username = <span class="string">'johnsmith'</span></span><br><span class="line">  ..password = <span class="string">'123456'</span>);</span><br><span class="line"><span class="built_in">print</span>(JSON.encode(serializers.serialize(login)));</span><br><span class="line">--&gt;</span><br><span class="line">[<span class="string">"Login"</span>, <span class="string">"username"</span>, <span class="string">"johnsmith"</span>, <span class="string">"password"</span>, <span class="string">"123456"</span>]</span><br></pre></td></tr></table></figure><p>注意到“JSON.encode”了吗？序列化程序实际上并不像序列化到String那样;而是它转换为Dart的内置JSON序列化知道如何处理的基础类型。因此，如果您愿意，可以使用JSON之外的其他东西。</p><p>您可能认为序列化是很简单的东西，但是这里涉及一些微妙的权衡。让我们深入研究built_value的序列化。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>built_value序列化的最重要的一个方面是它支持多态。具体来说，您可以拥有抽象类型的字段，以及</p><ul><li>该抽象类型的任何可序列化实现都可以序列化;</li><li>将在线上写入足够的信息以反序列化为正确的类型。</li></ul><p>最简单的例子是它可以序列化Object列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serializers.serialize(new BuiltList&lt;Object&gt;([1, &apos;two&apos;, 3]));</span><br><span class="line">--&gt;</span><br><span class="line">[&apos;list&apos;, [&apos;int&apos;, 1, &apos;string&apos;, &apos;two&apos;, &apos;int&apos;, 3]]</span><br></pre></td></tr></table></figure><p>仅在需要消除反序列化时消除歧义时，才会在线路上添加额外信息。因此，如果你有一个类型为“BuiltList <int>”的字段，它将被序列化为“[1,2,3]”，而不是像“[‘int’，1，’int’，2，’int’， 3]”。</int></p><p>最重要的是，您可以根据需要定义对象模型，而built_value将序列化它。如果您想更详细地看到这一点，<a href="https://github.com/google/built_value.dart/blob/master/built_value/test/built_map_serializer_test.dart" target="_blank" rel="noopener">map_serializer_test</a>探索所有可能性。</p><h2 id="多个实现"><a href="#多个实现" class="headerlink" title="多个实现"></a>多个实现</h2><p>所有序列化机制必须面对的另一个问题是以某种方式定义可序列化类型的范围。在这里，通过允许一个“类型”的多个实现，built_json做了一些不寻常的事情。</p><p>这是有效的，因为类型仅通过其类名在线上定义。例如，没有尝试消除称为“登录”的不同类之间的歧义;假设发送方和接收方都有一个兼容的序列化程序，可用于名为“Login”的类。</p><p>这增加了有用的灵活性例如，如果您在服务器和客户端上使用Dart，则可以选择对象模型中的每个类：</p><ul><li>您可以在客户端和服务器上使用相同的类。</li><li>或者，您可以使用不同的类。实现必须具有相同的名称和兼容的字段。</li></ul><p>例如，您可以为客户端提供一个“登录”类来处理渲染和解析;以及处理身份验证和数据库的服务器的单独“登录”类。当然，仅服务器实现可以自由使用像“dart：io”这样的包，仅客户端可以使用的像“”dart:html”这样的包。</p><h2 id="多种语言"><a href="#多种语言" class="headerlink" title="多种语言"></a>多种语言</h2><p>因为built_value序列化仅通过类名识别类型，所以序列化数据很好地映射到任何面向对象的语言。计划通过<a href="https://github.com/google/auto/tree/master/value" target="_blank" rel="noopener">AutoValue</a>支持Java。</p><h2 id="多种版本"><a href="#多种版本" class="headerlink" title="多种版本"></a>多种版本</h2><p>序列化的built_value数据以非常简单的方式向后/向前兼容：它依赖于类名和字段名。类名更改和必填字段名称更改正在中断。</p><p>可空字段更灵活：在序列化时，只有非空时才会写入;在反序列化时，如果找不到它们，它们将默认为null。因此，可以添加，删除或重命名可空字段，这不是一个重大变化。</p><p>无法识别的字段将被忽略。</p><h2 id="没有反射"><a href="#没有反射" class="headerlink" title="没有反射"></a>没有反射</h2><p>最后，对性能至关重要的是，built_value不使用任何形式的反射。所有分析都在代码生成时完成，为你提供最小化的，高性能的序列化代码。</p><p>那是使用built_value完成的序列化。你可以坐下来编写一个对象模型，它可以直接序列化以用于RPC或长期存储。</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>最后，built_value还有一个功能：EnumClass。 Dart枚举不是类，但强大的对象模型需要行为类似于类的枚举。显而易见的模式是创建一个带有“static const”字段的类，而EnumClass使这更容易做到。它提供了：</p><ul><li>适用于“values”和“valueOf”的生成代码。</li><li>通过built_value序列化程序进行序列化。</li><li>Angular或Angular2用户的额外奖励：codegen可以选择生成mixin来帮助您使用模板中的枚举。<br>在<a href="https://github.com/google/built_value.dart/blob/master/example/lib/enums.dart" target="_blank" rel="noopener">示例</a>中可以看到所有这些特性。</li></ul><p>这就是本周的内容！已经涵盖了built_value的基础知识，我准备在下周详细介绍聊天示例。敬请关注！</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON序列化 </tag>
            
            <tag> built_value </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Dart中适用于不可修改对象模型的 built_value</title>
      <link href="/2019/04/15/Flutter/development/data-and-backend/json%20serialization/built_value%20for%20Immutable%20Object%20Models/"/>
      <url>/2019/04/15/Flutter/development/data-and-backend/json%20serialization/built_value%20for%20Immutable%20Object%20Models/</url>
      
        <content type="html"><![CDATA[<p><a href="https://medium.com/dartlang/darts-built-value-for-immutable-object-models-83e2497922d4" target="_blank" rel="noopener">原文链接</a></p><p>上周我写了关于<a href="https://github.com/google/built_collection.dart" target="_blank" rel="noopener">built_collection</a>的<a href="built_collection-for-Immutable-Collections.html">文章</a>。我最后指出要真正使用不可变集合，你需要不可变的值。所以这里我们是要介绍的是:built_value。这是我在<a href="https://www.youtube.com/watch?v=TMeJxWltoVo" target="_blank" rel="noopener">Dart开发者峰会上</a>的第二个主要内容。</p><a id="more"></a><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>built_value包是用来定义你自己的值类型的。这个术语有着<a href="https://en.wikipedia.org/wiki/Value_type" target="_blank" rel="noopener">确切的含义</a>,但是我们是按照非正式的方式使用它，就意味着相等是基于值的相等。举个例子，数字上来说，我的3是与你的3相等的。</p><p>不仅如此：我的3将永远等于你的3;它不能改为4，或空，或完全不同的类型。值类型是生而不可变的。这使得和它们之间的交互和推断变得简单。</p><p>这听起来非常抽象。值类型的优点是什么？事实证明：很多。一大堆。虽然有一定争论，但我还是坚称任何用于模拟现实世界的类都应该是值类型。看下面的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user1 = <span class="keyword">new</span> User(name: <span class="string">"John Smith"</span>);</span><br><span class="line"><span class="keyword">var</span> user2 = <span class="keyword">new</span> User(name: <span class="string">"John Smith"</span>);</span><br><span class="line"><span class="built_in">print</span>(user1 == user2);</span><br></pre></td></tr></table></figure><p>它应该打印什么？至关重要的是，这两个实例都应该指的是现实世界中的某个人。因为他们的值相同，所以他们肯定指的是同一个人。所以他们一定是相等。</p><p>那么关于不变性呢？思考下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user1.nickname = <span class="string">'Joe'</span>;</span><br></pre></td></tr></table></figure><p>更新用户的昵称意味着什么？它可能意味着许多变化;假定我网页上的欢迎文本使用了昵称，这个文本就应该被更新。我可能在某处存储了用户信息，因此也需要对其进行更新。我现在有两个主要问题：</p><ul><li>我不知道谁有着“user1”的引用。值刚刚发生变化，根据使用情况的不同，可能会产生大量不可预测的影响。</li><li>任何持有“user2”或类似内容的人现在都持有一个过时的值。</li></ul><p>不变性对第二个问题无能为力，但它确实消除了第一个问题。这意味着没有不可预测的更新，只有明确的更新：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> updatedUser = <span class="keyword">new</span> User(name: <span class="string">"John Smith"</span>, nickname: <span class="string">"Joe"</span>);</span><br><span class="line">saveToDatabase(updatedUser); <span class="comment">// Database will notify frontend.</span></span><br></pre></td></tr></table></figure><p>至关重要的是，这意味着在明确发布之前，变更是本地的。这导致代码变得简单且易于推断 - 并且同时做到正确和快速。</p><h2 id="值类型的问题"><a href="#值类型的问题" class="headerlink" title="值类型的问题"></a>值类型的问题</h2><p>所以，显而易见的问题是：如果价值类型如此有用，为什么不是随处可见的呢？</p><p>不幸的是，他们实施起来非常费力。在Dart和大多数其他面向对象语言中，需要大量的样板代码。在我在Dart开发者峰会上的演讲中，我展示了一个简单的双字段类需要如此多的样板，它填满整个幻灯片。</p><h2 id="引入built-value"><a href="#引入built-value" class="headerlink" title="引入built_value"></a>引入built_value</h2><p>我们需要一种语言特性,讨论这个令人兴奋，但是短期内不太可能。或某种形式的<a href="https://en.wikipedia.org/wiki/Metaprogramming" target="_blank" rel="noopener">元编程</a>。而我们发现Dart已经有一种非常好的方法来进行元编程：<a href="https://github.com/dart-lang/source_gen" target="_blank" rel="noopener">source_gen</a>。</p><p>目标很明确：使得定义和使用值类型变得非常容易，无论在什么地方，只要值类型的使用有存在意思，我们就可以使用它们。</p><hr><p>首先，我们需要快速迂回地看看如何使用source_gen来解决这个问题。 source_gen工具在你手动维护的源代码旁边，创建新文件并在其中生成源代码，因此我们需要为生成的实现留出空间。这就意味着一个抽象类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@nullable</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> nickname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要足够的信息来生成实现。按照惯例，生成的代码以“_ $”开头，将其标记为私有并生成。因此生成的实现将被称为“_ $ User”。为了允许它扩展“User”，要有一个名为“_”的私有构造函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">=== user.dart ===</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name;</span><br><span class="line">  <span class="meta">@nullable</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> nickname;</span><br><span class="line">  User._();</span><br><span class="line">  <span class="keyword">factory</span> User() = UserImpl;</span><br><span class="line">&#125;</span><br><span class="line">=== user.g.dart <span class="keyword">is</span> generated by source_gen ===</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_</span>$<span class="title">User</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">String</span> nickname;</span><br><span class="line">  _$User() : <span class="keyword">super</span>._();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要使用Dart的“part”声明来引入生成的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">=== user.dart ===</span><br><span class="line"><span class="keyword">library</span> user;</span><br><span class="line"><span class="keyword">part</span> <span class="string">'user.g.dart'</span>;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name;</span><br><span class="line">  <span class="meta">@nullable</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> nickname;</span><br><span class="line">  User._();</span><br><span class="line">  <span class="keyword">factory</span> User() = _$User;</span><br><span class="line">&#125;</span><br><span class="line">=== user.g.dart <span class="keyword">is</span> generated by source_gen ===</span><br><span class="line"><span class="keyword">part</span> of user;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_</span>$<span class="title">User</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">String</span> nickname;</span><br><span class="line">  _$User() : <span class="keyword">super</span>._();</span><br><span class="line">  <span class="comment">// Generated implementation goes here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有了一定进展！我们有办法生成代码并将其插入我们手工编写的代码中。现在回到有趣的部分：你实际需要手工编写什么以及built_value应该生成什么。</p><hr><p>我们缺少一种方式来真正指定这些域的值。我们可以考虑使用命名的可选参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">factory</span> User(&#123;<span class="built_in">String</span> name, <span class="built_in">String</span> nickname&#125;) = _$User;</span><br></pre></td></tr></table></figure><p>但是这有一些缺点：它会强制你重复构造函数中的所有字段名称，它只提供了一次设置所有字段的方法;如果你想逐件建立一个价值怎么办？</p><p>幸运的是，builder模式让其得到了拯救。我们已经看到它在Dart中的集合中，得益于级联运算符的良好使用效果。假定我们有一个builder类型，我们可以将它用于构造函数 - 通过请求一个以builder作为参数的方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name;</span><br><span class="line">  <span class="meta">@nullable</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> nickname;</span><br><span class="line">  User._();</span><br><span class="line">  <span class="keyword">factory</span> User([updates(UserBuilder b)]) = _$User;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这有点令人惊讶，但结果是一个非常简单的实例化语法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user1 = <span class="keyword">new</span> User((b) =&gt; b</span><br><span class="line">    ..name = <span class="string">'John Smith'</span></span><br><span class="line">    ..nickname = <span class="string">'Joe'</span>);</span><br></pre></td></tr></table></figure><p>如何根据旧值创建新值？传统的builder模式提供了一个“toBuilder”方法来转换为构建器;然后，你应用你的更新并调用“构建”。但对于大多数用例来说，更好的模式是使用“重建”方法。与构造函数一样，它需要一个带有builder的方法，并提供简单的内联更新：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user2 = user.rebuild((b) =&gt; b</span><br><span class="line">    ..nickname = <span class="string">'Jojo'</span>);</span><br></pre></td></tr></table></figure><p>尽管如此，针对你希望将builder保持一段时间的情况，我们确实仍旧需要“toBuilder”。所以我们想要我们所有的值类型都有着两种方式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Built</span>&lt;<span class="title">V</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Creates a new instance: this one with [updates] applied.</span></span><br><span class="line">  V rebuild(updates(B builder));</span><br><span class="line">  <span class="comment">// Converts to a builder.</span></span><br><span class="line">  B toBuilder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您不需要为这些编写实现，built_value将为您生成它。所以你仅需要声明你要“实现Built”：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span> user;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:built_value/built_value.dart'</span>;</span><br><span class="line"><span class="keyword">part</span> <span class="string">'user.g.dart'</span>;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Built</span>&lt;<span class="title">User</span>, <span class="title">UserBuilder</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name;</span><br><span class="line">  <span class="meta">@nullable</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> nickname;</span><br><span class="line">  User._();</span><br><span class="line">  <span class="keyword">factory</span> User([updates(UserBuilder b)]) = _$User;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅此而已！值类型定义好了，生成的实现并且易于使用。当然，生成的实现不仅仅是字段：它还提供“operator ==”，“hashCode”，“toString”以及对必填字段的空检查。</p><hr><p>不过我已经跳过了一个重要细节：我说“假定我们有一个builder类型”。当然，我们在生成代码，所以答案很简单：我们将为您生成代码。 “User”引用的“UserBuilder”在“user.g.dart”中创建。</p><p>…除非你想在builder中编写一些代码，这是一件非常合理的事情。如果这就是你想要的，那么你对builder遵循相同的模式。它被声明为抽象的，具有私有构造函数和委托给生成的实现的工厂：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span>&lt;<span class="title">V</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@virtual</span></span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="meta">@virtual</span></span><br><span class="line">  <span class="built_in">String</span> nickname;</span><br><span class="line">  <span class="comment">// Parses e.g. John "Joe" Smith into username+nickname.</span></span><br><span class="line">  <span class="keyword">void</span> parseUser(<span class="built_in">String</span> user) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  UserBuilder._();</span><br><span class="line">  <span class="keyword">factory</span> UserBuilder() =&gt; _$UserBuilder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“@virtual”注释来自“package：meta”，需要允许生成的实现覆盖字段。现在您已经将实用程序方法添加到构建器中，您可以将它们内联使用，就像您可以分配给字段一样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User((b) =&gt; b..parseUser(<span class="string">'John "Joe" Smith'</span>));</span><br></pre></td></tr></table></figure><p>定制的builder的用例相对较少，但它们可以非常强大。例如，您可能希望builder实现用于设置共享字段的公共接口，从而它们能互换使用。</p><h2 id="嵌套Builders"><a href="#嵌套Builders" class="headerlink" title="嵌套Builders"></a>嵌套Builders</h2><p>你还没有看到build_value的一个主要特性：嵌套builder。当built_value字段包含built_collection或另一个built_value时，默认情况下它在构建器中可用作嵌套构建器。这意味着你可以比整个结构是可变的情况，更容易地更新深层嵌套的字段：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> structuredData = <span class="keyword">new</span> Account((b) =&gt; b</span><br><span class="line">    ..user.name = <span class="string">'John Smith'</span></span><br><span class="line">    ..user.nickname = <span class="string">'Joe'</span></span><br><span class="line">    ..credentials.email = <span class="string">'john.smith@example.com'</span></span><br><span class="line">    ..credentials.phone.country = Country.us</span><br><span class="line">    ..credentials.phone.number = <span class="string">'555 01234 567'</span>);</span><br><span class="line"><span class="keyword">var</span> updatedStructuredData = structuredData.rebuild((b) =&gt; b</span><br><span class="line">    ..credentials.phone.country = Country.switzerland</span><br><span class="line">    ..credentials.phone.number = <span class="string">'555 01234 555'</span>);</span><br></pre></td></tr></table></figure><p>为什么说比结构是可变的时候会简单些？</p><p>首先，所有构建器提供的“更新”方法意味着您可以随时进入新的作用域，重启级联运算符并进行简洁和内联的任何更新：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> updatedStructuredData = structuredData.rebuild((b) =&gt; b</span><br><span class="line">    ..user.update((b) =&gt; b</span><br><span class="line">        ..name = <span class="string">'Johnathan Smith'</span>)</span><br><span class="line">    ..credentials.phone.update((b) =&gt; b</span><br><span class="line">        ..country = Country.switzerland</span><br><span class="line">        ..number = <span class="string">'555 01234 555'</span>));</span><br></pre></td></tr></table></figure><p>其次，嵌套builder是根据需要自动创建。例如，在built_value的基准代码中，我们定义了一个名为Node的类型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Built</span>&lt;<span class="title">Node</span>, <span class="title">NodeBuilder</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@nullable</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> label;</span><br><span class="line">  <span class="meta">@nullable</span></span><br><span class="line">  Node <span class="keyword">get</span> left; </span><br><span class="line">  <span class="meta">@nullable</span></span><br><span class="line">  Node <span class="keyword">get</span> right;</span><br><span class="line">  Node._();</span><br><span class="line">  <span class="keyword">factory</span> Node([updates(NodeBuilder b)]) = _$Node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且构建器的自动创建允许我们创建我们想要内联的任何树结构：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="keyword">new</span> Node((b) =&gt; b</span><br><span class="line">  ..left.left.left.right.left.right.label = <span class="string">'I’m a leaf!'</span></span><br><span class="line">  ..left.left.right.right.label = <span class="string">'I’m also a leaf!'</span>);</span><br><span class="line"><span class="keyword">var</span> updatedNode = node.rebuild((b) =&gt; b</span><br><span class="line">  ..left.left.right.right.label = <span class="string">'I’m not a leaf any more!'</span></span><br><span class="line">  ..left.left.right.right.right.label = <span class="string">'I’m the leaf now!'</span>);</span><br></pre></td></tr></table></figure><hr><p>我提到了基准吗？更新时，built_value仅复制需要更新的结构部分，重用其余部分。所以它很快 - 并且内存效率很高。</p><p>但你不仅需要建造树。使用built_value，您可以使用完全类型化的不可变对象模型……它与高效的不可变树一样快速而强大。您可以混合和匹配类型化数据，自定义结构（如“节点”示例）和来自built_collection的集合：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> structuredData = <span class="keyword">new</span> Account((b) =&gt; b</span><br><span class="line">    ..user.update((b) =&gt; b</span><br><span class="line">        ..name = <span class="string">'John Smith'</span>)</span><br><span class="line">    ..credentials.phone.update((b) =&gt; b</span><br><span class="line">        ..country = Country.us</span><br><span class="line">        ..number = <span class="string">'555 01234 567'</span>)</span><br><span class="line">    ..node.left.left.left.account.update((b) =&gt; b</span><br><span class="line">        ..user.name = <span class="string">'John Smith II'</span></span><br><span class="line">        ..user.nickname = <span class="string">'Is lost in a tree'</span>)</span><br><span class="line">    ..node.left.right.right.account.update((b) =&gt; b</span><br><span class="line">        ..user.name = <span class="string">'John Smith III'</span>));</span><br></pre></td></tr></table></figure><p>这就是我所谈论的值类型，并且我认为大部分的数据都应该是值类型。</p><h2 id="更多关于built-value的事情"><a href="#更多关于built-value的事情" class="headerlink" title="更多关于built_value的事情"></a>更多关于built_value的事情</h2><p>我已经介绍了为什么需要使用built_value以及它使用的时候是什么样子。接下来还会介绍：built_value也提供了类似枚举的类提供EnumClass，为服务器/客户端通信和数据存储提供JSON序列化。我将在以后的文章中谈论这些。</p><p>之后，我将深入研究使用built_value和端到端系统与服务器和客户端的聊天示例。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON序列化 </tag>
            
            <tag> built_value </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Dart中适用于不可修改集合的built_collection</title>
      <link href="/2019/04/15/Flutter/development/data-and-backend/json%20serialization/built_collection%20for%20Immutable%20Collections/"/>
      <url>/2019/04/15/Flutter/development/data-and-backend/json%20serialization/built_collection%20for%20Immutable%20Collections/</url>
      
        <content type="html"><![CDATA[<p><a href="https://medium.com/dartlang/darts-built-collection-for-immutable-collections-db662f705eff" target="_blank" rel="noopener">原文链接</a></p><p>在2016年的Dart开发者大会上，我谈论了关于<a href="https://www.youtube.com/watch?v=TMeJxWltoVo" target="_blank" rel="noopener">使用source_gen来生成对象模型的内容</a>。我提到了一些非常值得仔细研究的软件包和技术，所以在这里我要讲完整个故事。</p><a id="more"></a><p>首先:<a href="https://github.com/google/built_collection.dart" target="_blank" rel="noopener">built_collection</a></p><p>built_collection包提供类似SDK的具有不可变性的集合。不可变性的优点在于:</p><ul><li>简单，方便。可以传递一个不可变的集合，而不必担心谁可能会修改它。</li><li>性能。可变性导致昂贵的模式，如防御性复制和变化检测。</li></ul><p>build_collection应该很方便的这个事实对API提出了一些挑战。让我们来看看。首先，一个不可变的列表：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> BuiltList&lt;<span class="built_in">int</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>现在我想为它添加一个值。当然，它是不可改变的，所以我不能把值添加上去;我真正想要的是创建一个在最后添加一个额外的值的新的列表。</p><p>这里我们使用到了builder模式，也是此包命名的由来。通过转换为builder，在builder上进行修改，然后构建从而获得新列表：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder = list.toBuilder();</span><br><span class="line">builder.add(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> newList = builder.build();</span><br></pre></td></tr></table></figure><p>Buidlers通常是内联使用的，让我们这么做：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newList = (list.toBuilder()..add(<span class="number">4</span>)).build()</span><br></pre></td></tr></table></figure><p>这就是构建器模式通常所做的，但是Dart有lambdas，所以我们可以做得更好：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newList = list.rebuild((b) =&gt; b.add(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>我们发现在Dart中级联的方法使得构建器模式非常强大。你几乎总能做你想要的内联：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newList = list.rebuild((b) =&gt; b</span><br><span class="line">    ..add(<span class="number">4</span>)</span><br><span class="line">    ..addAll([<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>])</span><br><span class="line">    ..sort()</span><br><span class="line">    ..remove(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>所以，正如所希望的，built_collection的使用时很方便的。</p><hr><p>让我们谈论下性能。</p><p>Built Collections目前针对具有更新/发布周期的代码进行了优化。这意味着：集合将转换为构建器，更新，构建，然后发布 - 传递引用 - 以供其他代码使用。</p><p>这在Web应用程序是很典型的，例如Angular应用程序。在应用中，用户交互或RPC响应会触发更新。数据模型在发布以进行渲染之前会重建。</p><p>Built Collections尚未针对非常频繁的重建进行优化，这需要在精心选择的数据结构之上实现。如果你有对此有使用实例，请联系我 - 这是Built Collections设计的一部分，这将在需要时实现。</p><hr><p>除了不变性之外，built_collection还可以帮助您编写正确的代码。有着一整套的帮助属性在这里：</p><ul><li>必须使用显式类型参数创建Built Collections;没有BuiltList <dynamic>这样的东西。</dynamic></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BuiltList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);     <span class="comment">// Throws an exception!</span></span><br><span class="line"><span class="keyword">new</span> BuiltList&lt;<span class="built_in">int</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// Better.</span></span><br></pre></td></tr></table></figure><ul><li>值必须为非空; 空无法添加到Built Collection。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BuiltList([<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">null</span>]);  <span class="comment">// Throws an exception!</span></span><br></pre></td></tr></table></figure><ul><li>Built Collections是可比的和可哈希的。这意味着您可以将它们放在maps，sets和multimaps中，创建与你的数据匹配的集合。</li></ul><p>这些属性特别适合于业务对象的集合：例如，在购物Web应用程序中，用于保存用户购物车的当前内容。</p><hr><p>这是对build_collection提供的内容和原因的快速概述; <a href="https://github.com/google/built_collection.dart" target="_blank" rel="noopener">github页面</a>上提供了更多信息。但是，为了充分利用不可变集合，您需要不可变类。接下来：<a href="http://github.com/google/built_value.dart" target="_blank" rel="noopener">built_value</a>！</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON序列化 </tag>
            
            <tag> built_value </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Flutter 中的 JSON 序列化</title>
      <link href="/2019/04/15/Flutter/development/data-and-backend/json%20serialization/json%20and%20serialization/"/>
      <url>/2019/04/15/Flutter/development/data-and-backend/json%20serialization/json%20and%20serialization/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/development/data-and-backend/json" target="_blank" rel="noopener">原文链接</a></p><p>很难想象，一个移动应用程序不需要与Web服务器通信，或者只是简单地在某一个位置存储结构化数据。制作与网络连接的应用程序的时候，迟早会需要使用一些美好的JSON。</p><p>本指南介绍了如何在Flutter中使用JSON。它涵盖了在不同场景中使用哪种JSON解决方案，以及原因。</p><a id="more"></a><blockquote><p>术语：编码和序列化是一回事 - 将数据结构转换为字符串。解码和反序列化是相反的过程 - 将字符串转换为数据结构。但是，序列化通常也指将数据结构转换为更易于阅读的格式的整个过程。</p></blockquote><p>为避免混淆，本文档在引用整个过程时使用“序列化”，在专门引用这些过程时使用“编码”和“解码”。</p><h2 id="哪种JSON序列化方法适合我？"><a href="#哪种JSON序列化方法适合我？" class="headerlink" title="哪种JSON序列化方法适合我？"></a>哪种JSON序列化方法适合我？</h2><p>本文介绍了使用JSON的两种常规策略：</p><ul><li>手动序列化</li><li>使用代码生成进行自动序列化<br>不同的项目具有不同的复杂性和用例。对于较小的概念验证项目或快速原型，使用代码生成器可能有点杀鸡用牛刀。对于具有更多复杂性的多个JSON模型的应用程序，手动编码很快就会变得乏味，重复，并且会带来许多小错误。</li></ul><h2 id="对较小的项目使用手动序列化"><a href="#对较小的项目使用手动序列化" class="headerlink" title="对较小的项目使用手动序列化"></a>对较小的项目使用手动序列化</h2><p>手动JSON解码使用dart：convert中内置的JSON解码器。它涉及将原始JSON字符串传递给jsonDecode（）方法，然后在生成的Map &lt;String，dynamic&gt;中查找所需的值。它没有外部依赖或特别的设置过程，它有利于快速验证概念。</p><p>当项目变大时，手动解码的效果就变得不佳。手动编写解码逻辑可能变得难以管理且容易出错。如果在访问不存在的JSON字段时出现拼写错误，则代码会在运行时抛出错误。</p><p>如果您的项目中没有很多JSON模型，并且希望快速测试概念，那么手动序列化可能就是您想要的方式。有关手动编码的示例，请参阅使用dart：convert手动序列化JSON。</p><h2 id="在大中型项目中使用代码生成"><a href="#在大中型项目中使用代码生成" class="headerlink" title="在大中型项目中使用代码生成"></a>在大中型项目中使用代码生成</h2><p>使用代码生成的JSON序列化意味着有一个外部库为您生成编码样板。进行一些初始设置后，您将运行一个文件观察者，它会依据您的模型类生成代码。例如，<a href="https://pub.dartlang.org/packages/json_serializable" target="_blank" rel="noopener">json_serializable</a>和<a href="https://pub.dartlang.org/packages/built_value" target="_blank" rel="noopener">built_value</a>就是这种类型的库。</p><p>这种方法适用于较大的项目。不需要手写的样板文件，并且在编译时捕获访问JSON字段时的拼写错误。代码生成的缺点是它需要一些初始设置。此外，生成的源文件可能会在项目导航器中产生视觉混乱。</p><p>当您拥有中型或大型项目时，您可能希望使用生成的代码进行JSON序列化。要查看基于JSON编码的代码生成示例，请参阅<a href="https://flutter.dev/docs/development/data-and-backend/json#code-generation" target="_blank" rel="noopener">使用代码生成库序列化JSON</a>。</p><h2 id="Flutter中是否有GSON-Jackson-Moshi等价物？"><a href="#Flutter中是否有GSON-Jackson-Moshi等价物？" class="headerlink" title="Flutter中是否有GSON / Jackson / Moshi等价物？"></a>Flutter中是否有GSON / Jackson / Moshi等价物？</h2><p>答案很简单，就是没有。</p><p>这样的库需要使用运行时反射，这在Flutter中被禁用。运行时反射会干扰<a href="https://en.wikipedia.org/wiki/Tree_shaking" target="_blank" rel="noopener">tree sharking</a>机制，Dart支持了这个机制已经很长时间。有了tree sharking](<a href="https://en.wikipedia.org/wiki/Tree_shaking)机制，您可以从发布版本中“摇掉”未使用的代码。这对应用大小的优化是显著的。" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Tree_shaking)机制，您可以从发布版本中“摇掉”未使用的代码。这对应用大小的优化是显著的。</a></p><p>由于反射使得代码所有代码在默认情况下是隐式使用的，因此使<a href="https://en.wikipedia.org/wiki/Tree_shaking" target="_blank" rel="noopener">tree sharking</a>机制变得困难。这些工具无法知道运行时哪些部分未使用，因此冗余代码很难被删除。使用反射时，无法轻松优化应用程序大小。</p><p>dartson怎么样？ dartson库使用运行时反射，这使它与Flutter不兼容。</p><p>虽然您不能在Flutter中使用运行时反射，但是某些库基于代码为你提供了类似的易用API，<a href="https://flutter.dev/docs/development/data-and-backend/json#code-generation" target="_blank" rel="noopener">代码生成库部分</a>更详细地介绍了此方法。</p><h2 id="使用dart：convert手动序列化JSON"><a href="#使用dart：convert手动序列化JSON" class="headerlink" title="使用dart：convert手动序列化JSON"></a>使用dart：convert手动序列化JSON</h2><p>Flutter中的基本JSON编码非常简单。 Flutter有一个内置的dart：转换库，包括一个简单的JSON编码器和解码器。</p><p>以下是简单用户模型的示例JSON。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Smith"</span>,</span><br><span class="line">  <span class="attr">"email"</span>: <span class="string">"john@example.com"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用dart：convert，您可以通过两种方式对此JSON模型进行编码。</p><h3 id="以内联的方式序列化JSON"><a href="#以内联的方式序列化JSON" class="headerlink" title="以内联的方式序列化JSON"></a>以内联的方式序列化JSON</h3><p>通过查看dart：convert文档，您将看到可以通过调用jsonDecode()方法来解码JSON，并使用JSON字符串作为方法参数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; user = jsonDecode(jsonString);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Howdy, <span class="subst">$&#123;user[<span class="string">'name'</span>]&#125;</span>!'</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'We sent the verification link to <span class="subst">$&#123;user[<span class="string">'email'</span>]&#125;</span>.'</span>);</span><br></pre></td></tr></table></figure><p>不幸的是，jsonDecode（）返回一个Map &lt;String，dynamic&gt;，这意味着在运行时之前你不知道值的类型。使用这种方法，您将丧失大部分静态类型语言特性：类型安全，自动补全以及最重要的编译时异常。您的代码将立即变得更容易出错。</p><p>例如，当年使用名称或电子邮件字段的时候，都可能会很快引入拼写错误。由于JSON存在于map结构中，编译器对于拼写错误是不知道。</p><h3 id="在模型类中序列化JSON"><a href="#在模型类中序列化JSON" class="headerlink" title="在模型类中序列化JSON"></a>在模型类中序列化JSON</h3><p>为了解决以上提及到的问题，我们引入了一个普通的模型类，在本例中叫做User。在User类中，您将找到：</p><ul><li>User.fromJson（）构造函数，用于从map结构构造新的User实例。</li><li>一个toJson（）方法，它将User实例转换为map。<br>使用这种方法，调用代码可以具有类型安全性，名称和电子邮件字段的自动补全以及编译时异常。如果您输入拼写错误或将字段视为int而不是字符串，则应用程序将无法编译，而不是在运行时崩溃。</li></ul><p>user.dart</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> email;</span><br><span class="line"></span><br><span class="line">  User(<span class="keyword">this</span>.name, <span class="keyword">this</span>.email);</span><br><span class="line"></span><br><span class="line">  User.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; json)</span><br><span class="line">      : name = json[<span class="string">'name'</span>],</span><br><span class="line">        email = json[<span class="string">'email'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; toJson() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">'name'</span>: name,</span><br><span class="line">      <span class="string">'email'</span>: email,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解码逻辑的责任现在在模型本身内部移动。使用这种新方法，您可以轻松解码User。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span> userMap = jsonDecode(jsonString);</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User.fromJson(userMap);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Howdy, <span class="subst">$&#123;user.name&#125;</span>!'</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'We sent the verification link to <span class="subst">$&#123;user.email&#125;</span>.'</span>);</span><br></pre></td></tr></table></figure><p>要对用户进行编码，请将User对象传递给jsonEncode（）函数。你不需要调用toJson（）方法，因为jsonEncode（）已经为你做了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> json = jsonEncode(user);</span><br></pre></td></tr></table></figure><p>使用这种方法，调用代码根本不必担心JSON序列化。但是，模型类仍然是必须。在生产应用程序中，您需要确保序列化正常工作。实际上，User.fromJson()和User.toJson()方法都需要进行单元测试以验证其行为的正确性。</p><p>但是，现实世界的场景通常不会那么简单。您不太可能使用如此小的JSON响应体。嵌套的JSON对象也是常有的。</p><p>如果有一些东西可以为你处理JSON编码和解码，那就太好了。幸运的是，有！</p><h2 id="使用代码生成库序列化JSON"><a href="#使用代码生成库序列化JSON" class="headerlink" title="使用代码生成库序列化JSON"></a>使用代码生成库序列化JSON</h2><p>json_serializable包，这是一个自动生成的源代码生成器，可为您生成JSON序列化样板。</p><p>由于序列化代码不再是手动或手动维护的，因此可以最大限度地降低在运行时出现JSON序列化异常的风险。</p><h2 id="在项目中设置json-serializable"><a href="#在项目中设置json-serializable" class="headerlink" title="在项目中设置json_serializable"></a>在项目中设置json_serializable</h2><p>要在项目中包含json_serializable，您需要一个常规依赖项和两个dev依赖项。简而言之，dev依赖项是我们的应用程序源代码中未包含的依赖项 - 它们仅在开发环境中使用。</p><p>可以通过以下JSON可序列化示例中的pubspec文件来查看这些必需依赖项的最新版本。</p><p>pubspec.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="comment"># Your other regular dependencies here</span></span><br><span class="line"><span class="attr">  json_annotation:</span> <span class="string">^2.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line">  <span class="comment"># Your other dev_dependencies here</span></span><br><span class="line"><span class="attr">  build_runner:</span> <span class="string">^1.0.0</span></span><br><span class="line"><span class="attr">  json_serializable:</span> <span class="string">^2.0.0</span></span><br></pre></td></tr></table></figure><p>进入项目根文件夹运行flutter包，（或单击编辑器中的Packages Get）以在项目中使用这些新的依赖项。</p><h2 id="以json-serializable方式创建模型类"><a href="#以json-serializable方式创建模型类" class="headerlink" title="以json_serializable方式创建模型类"></a>以json_serializable方式创建模型类</h2><p>下面显示了如何将User类转换为json_serializable类。为简单起见，此代码使用先前示例中的简化JSON模型。</p><p>user.dart</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:json_annotation/json_annotation.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// This allows the `User` class to access private members in</span></span><br><span class="line"><span class="comment">/// the generated file. The value for this is *.g.dart, where</span></span><br><span class="line"><span class="comment">/// the star denotes the source file name.</span></span><br><span class="line"><span class="keyword">part</span> <span class="string">'user.g.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An annotation for the code generator to know that this class needs the</span></span><br><span class="line"><span class="comment">/// JSON serialization logic to be generated.</span></span><br><span class="line"><span class="meta">@JsonSerializable</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  User(<span class="keyword">this</span>.name, <span class="keyword">this</span>.email);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">String</span> email;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// A necessary factory constructor for creating a new User instance</span></span><br><span class="line">  <span class="comment">/// from a map. Pass the map to the generated `_$UserFromJson()` constructor.</span></span><br><span class="line">  <span class="comment">/// The constructor is named after the source class, in this case User.</span></span><br><span class="line">  <span class="keyword">factory</span> User.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; json) =&gt; _$UserFromJson(json);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// `toJson` is the convention for a class to declare support for serialization</span></span><br><span class="line">  <span class="comment">/// to JSON. The implementation simply calls the private, generated</span></span><br><span class="line">  <span class="comment">/// helper method `_$UserToJson`.</span></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; toJson() =&gt; _$UserToJson(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过此设置，源代码生成器生成用于编码和解码来自JSON的名称和电子邮件字段的代码。</p><p>如果需要，还可以轻松自定义命名策略。例如，如果API返回带有snake_case的对象，并且您希望在模型中使用lowerCamelCase，则可以将@JsonKey批注与name参数一起使用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Tell json_serializable that "registration_date_millis" should be</span></span><br><span class="line"><span class="comment">/// mapped to this property.</span></span><br><span class="line"><span class="meta">@JsonKey</span>(name: <span class="string">'registration_date_millis'</span>)</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> registrationDateMillis;</span><br></pre></td></tr></table></figure><h2 id="运行代码生成实用程序"><a href="#运行代码生成实用程序" class="headerlink" title="运行代码生成实用程序"></a>运行代码生成实用程序</h2><p>在第一次创建json_serializable类时，您将得到类似于下图所示的错误。</p><p><img src="https://flutter.dev/images/json/ide_warning.png" alt="img"></p><p>这些错误完全正常，仅仅是因为模型类的生成代码尚不存在。要解决此问题，请运行生成序列化样板的代码生成器。</p><p>有两种运行代码生成器的方法。</p><h3 id="一次性代码生成"><a href="#一次性代码生成" class="headerlink" title="一次性代码生成"></a>一次性代码生成</h3><p>通过运行flutter包，在项目根目录中运行build_runner build，可以在需要时为模型生成JSON序列化代码。这会触发一次性构建，该构建遍历源文件，选择相关文件，并为它们生成必要的序列化代码。</p><p>尽管这是很方便的，每次当你对你的模型类做了修改的时候，你没必要每次都去手动运行一次。</p><h3 id="持续性地生成代码"><a href="#持续性地生成代码" class="headerlink" title="持续性地生成代码"></a>持续性地生成代码</h3><p>观察者使我们的源代码生成过程更加方便。它会监听项目文件中的更改，并在需要时自动构建必要的文件。通过在项目根目录中运行flutter packages pub run build_runner watch来启动观察程序。</p><p>启动观察器一次，然后把它扔在后台运行是安全的。</p><h3 id="使用json-serializable模型"><a href="#使用json-serializable模型" class="headerlink" title="使用json_serializable模型"></a>使用json_serializable模型</h3><p>要以json_serializable方式解码JSON字符串，您实际上没有对我们以前的代码进行任何更改。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span> userMap = jsonDecode(jsonString);</span><br><span class="line"><span class="keyword">var</span> user = User.fromJson(userMap);</span><br></pre></td></tr></table></figure><p>编码也是如此。调用的API与以前相同。</p><p>使用json_serializable，您可以忘记User类中的任何手动JSON序列化。源代码生成器创建一个名为user.g.dart的文件，该文件具有所有必需的序列化逻辑。您不再需要编写自动化测试来确保序列化工作 - 现在确保序列化正常工作的职责落到了库上。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Flutter中的响应式编程(Reactive Programming)、流(Streams)、业务逻辑组件(BloC)以及实际使用案例</title>
      <link href="/2019/04/13/Flutter/development/data-and-backend/state-mgmt/options/BloC/ReactiveProgramming-Streams-BLoC-PracticalUseCases/"/>
      <url>/2019/04/13/Flutter/development/data-and-backend/state-mgmt/options/BloC/ReactiveProgramming-Streams-BLoC-PracticalUseCases/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.didierboelens.com/2018/12/reactive-programming---streams---bloc---practical-use-cases/" target="_blank" rel="noopener">原文链接</a></p><p>Flutter中的响应式编程(Reactive Programming)、流(Streams)、业务逻辑组件(BloC)以及实际使用案例</p><p>难度：中级</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在前一段时间介绍了业务逻辑组件(BloC)，响应式编程(Reactive Programming)和流(Streams)这些概念之后，我想与你分享一些我经常使用的并且个人觉得十分有用的模式，应该会是很有趣的。在我的开发过程中，这些模式使我节省了大量时间，并使我的代码更易于阅读和调试。</p><p>我要讨论的话题有：</p><ul><li><p><code>BLoC Provider</code> 以及 <code>InheritedWidget</code></p></li><li><p>在哪初始化 <code>BLoC</code></p></li><li><p>事件-状态</p><p>允许基于事件对状态转换作出响应</p></li><li><p>表单验证<br>允许依据条目和验证控制表单的行为。(我解释的解决方案还包括密码和重新输入密码的比较)。</p></li><li><p><code>Part of</code></p><p>允许Widget根据其在列表中的是否存在来调整其行为。</p><p>完整的源代码可以在 <a href="https://github.com/boeledi/blocs" target="_blank" rel="noopener">GitHub</a> 上下载。</p><hr></li></ul><h2 id="BlocProvider-和-InheritedWidget"><a href="#BlocProvider-和-InheritedWidget" class="headerlink" title="BlocProvider 和 InheritedWidget"></a><code>BlocProvider</code> 和 <code>InheritedWidget</code></h2><p>我借此文章的机会介绍我的另一个版本的<code>BlocProvider</code>，它现在依赖于一个<code>InheritedWidget</code>。</p><p>使用<code>InheritedWidget</code>的优点是我们获得了性能上的提升。</p><p>让我来解释下。</p><h3 id="之前的实现"><a href="#之前的实现" class="headerlink" title="之前的实现"></a>之前的实现</h3><p>我之前版本的BlocProvider是按常规的StatefulWidget实现的，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> dispose();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型Bloc Provider</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BlocBase</span>&gt; <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  BlocProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.bloc,</span><br><span class="line">  &#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> T bloc;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> T of&lt;T <span class="keyword">extends</span> BlocBase&gt;(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;();</span><br><span class="line">    BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type);</span><br><span class="line">    <span class="keyword">return</span> provider.bloc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocProviderState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BlocProvider</span>&lt;<span class="title">BlocBase</span>&gt;&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    widget.bloc.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> widget.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我使用了 StatefulWidget 从而从它的 dispose() 方法中受益，以确保在不再需要时释放BLoC 分配的资源。</p><p>这很好用但从性能角度来看并不是最佳的。</p><p>context.ancestorWidgetOfExactType() 是一个 O(n) 方法。为了获取要求的祖先widget，而这个祖先对应某种乐行，它从<code>context</code>开始向上遍历树，每向上移动一个都要递归一遍，直到遍历完成。如果<code>context</code>到祖先的距离很小，则这个方法调用是可以接受的，否则应该避免对其进行调用。这是这个方法的代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget ancestorWidgetOfExactType(<span class="built_in">Type</span> targetType) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</span><br><span class="line">    <span class="built_in">Element</span> ancestor = _parent;</span><br><span class="line">    <span class="keyword">while</span> (ancestor != <span class="keyword">null</span> &amp;&amp; ancestor.widget.runtimeType != targetType)</span><br><span class="line">        ancestor = ancestor._parent;</span><br><span class="line">    <span class="keyword">return</span> ancestor?.widget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新的实现"><a href="#新的实现" class="headerlink" title="新的实现"></a>新的实现</h3><p>新的实现依赖于一个与 InheritedWidget 结合 StatefulWidget：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BlocBase</span>&gt; <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  BlocProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.bloc,</span><br><span class="line">  &#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">  <span class="keyword">final</span> T bloc;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> T of&lt;T <span class="keyword">extends</span> BlocBase&gt;(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> type = _typeOf&lt;_BlocProviderInherited&lt;T&gt;&gt;();</span><br><span class="line">    _BlocProviderInherited&lt;T&gt; provider = </span><br><span class="line">            context.ancestorInheritedElementForWidgetOfExactType(type)?.widget;</span><br><span class="line">    <span class="keyword">return</span> provider?.bloc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocProviderState</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BlocBase</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BlocProvider</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    widget.bloc?.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _BlocProviderInherited&lt;T&gt;(</span><br><span class="line">      bloc: widget.bloc,</span><br><span class="line">      child: widget.child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocProviderInherited</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  _BlocProviderInherited(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.bloc,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> T bloc;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(_BlocProviderInherited oldWidget) =&gt; <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解决方案的优点是性能。</p><p>由于使用了 <code>InheritedWidget</code>，它现在可以调用context.ancestorInheritedElementForWidgetOfExactType() 方法，它是一个O(1)方法。这意味祖先是立即获取的，如其源代码所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">InheritedElement ancestorInheritedElementForWidgetOfExactType(<span class="built_in">Type</span> targetType) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</span><br><span class="line">    <span class="keyword">final</span> InheritedElement ancestor = _inheritedWidgets == <span class="keyword">null</span> </span><br><span class="line">                                    ? <span class="keyword">null</span> </span><br><span class="line">                                    : _inheritedWidgets[targetType];</span><br><span class="line">    <span class="keyword">return</span> ancestor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为事实上，所有<code>InheritedWidgets</code>都由框架记住了。</p><p>为什么使用 <code>ancestorInheritedElementForWidgetOfExactType</code>？</p><p>你可能已经注意到我使用 ancestorInheritedElementForWidgetOfExactType 方法,而不是通常的 inheritFromWidgetOfExactType。</p><p>原因是我不希望调用 <code>BlocProvider</code> 的 <code>context</code> 被注册为 <code>InheritedWidget</code>的依赖项，因为我不需要它。</p><h3 id="如何使用新的-BlocProvider"><a href="#如何使用新的-BlocProvider" class="headerlink" title="如何使用新的 BlocProvider?"></a>如何使用新的 BlocProvider?</h3><h4 id="Bloc的注入"><a href="#Bloc的注入" class="headerlink" title="Bloc的注入"></a>Bloc的注入</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> BlocProvider&lt;MyBloc&gt;&#123;</span><br><span class="line">        bloc: myBloc,</span><br><span class="line">        child: ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bloc的获取"><a href="#Bloc的获取" class="headerlink" title="Bloc的获取"></a>Bloc的获取</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context)&#123;</span><br><span class="line">    MyBloc myBloc = BlocProvider.of&lt;MyBloc&gt;(context);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从哪初始化-BLoc"><a href="#从哪初始化-BLoc" class="headerlink" title="从哪初始化 BLoc"></a>从哪初始化 BLoc</h2><p>要回答这个问题，你需要确认它的使用范围。</p><h3 id="应用中随处可用"><a href="#应用中随处可用" class="headerlink" title="应用中随处可用"></a>应用中随处可用</h3><p>假设你必须处理与用户身份验证/配置文件，用户设置，购物篮相关的一些机制……任何需要从应用程序的任何可能部分（例如，从不同页面）获得BLoC的任何机制，存在两种方式使这个BLoC可访问。</p><h4 id="全局单例的使用"><a href="#全局单例的使用" class="headerlink" title="全局单例的使用"></a>全局单例的使用</h4><p>此解决方案依赖于使用 Global 对象，对所有对象实例化，而不是任何 Widget 树的一部分。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:rxdart/rxdart.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalBloc</span> </span>&#123;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Streams related to this BLoC</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">String</span>&gt; _controller = BehaviorSubject&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">  <span class="built_in">Function</span>(<span class="built_in">String</span>) <span class="keyword">get</span> push =&gt; _controller.sink.add;</span><br><span class="line">  Stream&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> stream =&gt; _controller;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Singleton factory</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> GlobalBloc _bloc = <span class="keyword">new</span> GlobalBloc._internal();</span><br><span class="line">  <span class="keyword">factory</span> GlobalBloc()&#123;</span><br><span class="line">    <span class="keyword">return</span> _bloc;</span><br><span class="line">  &#125;</span><br><span class="line">  GlobalBloc._internal();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Resource disposal</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _controller?.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GlobalBloc globalBloc = GlobalBloc();</span><br></pre></td></tr></table></figure><p>要使用此 <code>BLoC</code>，你只需导入该类并直接调用其方法，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'global_bloc.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context)&#123;</span><br><span class="line">        globalBloc.push(<span class="string">'building MyWidget'</span>);</span><br><span class="line">        <span class="keyword">return</span> Container();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你需要一个独特的 BLoC 并且需要从应用程序内部的任何位置访问，这是一个可接受的解决方案。</p><ul><li>这是非常容易使用;</li><li>它不依赖于任何 <code>BuildContext</code>;</li><li>无需通过任何 <code>BlocProvider</code> 来查找 <code>BLoC</code>，</li><li>为了释放它的资源，只需确保将应用程序实现为 StatefulWidget，并在应用程序Widget的重载 dispose() 方法中调用 globalBloc.dispose()。</li></ul><p>许多纯粹主义者反对这种解决方案。我不知道为什么，但是…所以让我们看看另一个……</p><h4 id="把它放在所有东西的顶部"><a href="#把它放在所有东西的顶部" class="headerlink" title="把它放在所有东西的顶部"></a>把它放在所有东西的顶部</h4><p>在 Flutter 中，所有页面的祖先本身必须是 MaterialApp 的父级。这是因为页面（或路径）被包装在 OverlayEntry 中，这是所有页面的公共堆栈的子项。</p><p>换句话说，每个页面都有一个 Buildcontext，它独立于任何其他页面。这就解释了为什么在不使用任何技巧的情况下，两个页面(路由)不可能有任何共同点。</p><p>因此，如果你需要在应用程序中的任何位置使用 <code>BLoC</code>，则必须将其作为 MaterialApp 的父级，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(Application());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> BlocProvider&lt;AuthenticationBloc&gt;(</span><br><span class="line">      bloc: AuthenticationBloc(),</span><br><span class="line">      child: MaterialApp(</span><br><span class="line">        title: <span class="string">'BLoC Samples'</span>,</span><br><span class="line">        theme: ThemeData(</span><br><span class="line">          primarySwatch: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        home: InitializationPage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在子树上能访问"><a href="#在子树上能访问" class="headerlink" title="在子树上能访问"></a>在子树上能访问</h3><p>大多数情况下，您可能需要在应用程序的某些特定部分使用<code>BLoC</code>。</p><p>作为一个例子，我们可以考虑将<code>BLoC</code>用于一个讨论线程</p><ul><li>与服务器交互以获取，添加，更新帖子</li><li>列出要在某一页面中显示的线程</li><li>…</li></ul><p>对于此示例，您不需要此 <code>BLoC</code> 可用于整个应用程序，而是需要某些 <code>Widget</code> (树的一部分)。</p><p>第一种解决方案可能是将 <code>BLoC</code> 注入 <code>Widget</code> 树的根目录，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTree</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> BlocProvider&lt;MyBloc&gt;(</span><br><span class="line">      bloc: MyBloc(),</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          MyChildWidget(),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChildWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span> </span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    MyBloc = BlocProvider.of&lt;MyBloc&gt;(context);</span><br><span class="line">    <span class="keyword">return</span> Container();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，所有 widget 都将通过调用 <code>BlocProvider.of</code> 方法访问<code>BLoC</code>。</p><p>边注</p><p>如上所示的解决方案并不是最佳的，因为它将在每次重建时实例化BLoC。</p><p>后果：</p><ul><li>你将丢失现有<code>BLoC</code>所有内容</li><li>它会耗费CPU时间，因为它需要在每次构建时实例化它。</li></ul><p>在这种情况下，更好的方法是使用 <code>StatefulWidget</code> 从其持久状态中受益，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTree</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line">  _MyTreeState createState() =&gt; _MyTreeState();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyTreeState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyTree</span>&gt;</span>&#123;</span><br><span class="line">  MyBloc bloc;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState()&#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    bloc = MyBloc();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    bloc?.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> BlocProvider&lt;MyBloc&gt;(</span><br><span class="line">      bloc: bloc,</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          MyChildWidget(),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方法，如果 “MyTree” widget 需要重建，则不必重新实例化 BLoC 并直接重用现有实例。</p><h3 id="只对一个widget可访问"><a href="#只对一个widget可访问" class="headerlink" title="只对一个widget可访问"></a>只对一个widget可访问</h3><p>这涉及 <code>BLoC</code>仅由一个 Widget 使用的情况。</p><p>在这种情况下，可以在 Widget 中实例化 BLoC。</p><h2 id="事件状态"><a href="#事件状态" class="headerlink" title="事件状态"></a>事件状态</h2><p>有时，处理一系列可能是顺序或并行，长或短，同步或异步以及可能导致各种结果的活动可能变得非常难以编程。你可能要随着进度或根据状态更新显示的内容。</p><p>第一个实例的目的是使这种情况更容易处理。</p><p>该解决方案是基于以下原则的：</p><ul><li>一个事件被发送出来</li><li>此事件触发一些导致一个或多个状态的动作;</li><li>这些状态中的每一个都可以反过来发出其他事件或导致另一个状态;</li><li>然后，这些事件将根据有效的状态触发其它动作;</li><li>等等…</li></ul><p>为了阐明这个概念，我们来看两个常见的例子：</p><ul><li>应用初始化</li></ul><p>假设你需要运行一系列动作来初始化应用程序。动作可能与服务器的交互相关联(例如，加载一些数据)。在此初始化过程中，您可能需要显示进度条和一系列图像来让用户等待。</p><ul><li>认证</li></ul><p>在启动时，应用程序可能需要用户进行身份验证或注册。用户通过身份验证后，将重定向到应用程序的主页面。然后，如果用户注销，则将其重定向到认证页面。</p><p>为了能够处理所有可能的情况以及事件序列，但是如果我们考虑到事件可以在应用程序中的任何地方被触发，这可能变得非常难以管理。</p><p>这正是<code>BlocEventState</code>与<code>BlocEventStateBuilder</code>相结合可以帮助很多的地方。</p><h3 id="BlocEventState"><a href="#BlocEventState" class="headerlink" title="BlocEventState"></a>BlocEventState</h3><p><code>BlocEventState</code>背后的思想是定义一个<code>BLoC</code>：</p><ul><li>接受事件(<code>Event</code>)作为输入;</li><li>在新事件(<code>event</code>)被发送的时候调用事件处理器(<code>eventHandler</code>);</li><li>事件处理器(<code>eventHandler</code>)负责根据事件(<code>event</code>)采取适当的行动(<code>action</code>)并发出状态(<code>State</code>)作为响应。</li></ul><p>下图展示了这个思想：</p><p><img src="https://www.didierboelens.com/images/bloc_event_state.png" alt></p><p>这是这个类的源代码。解释如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:blocs/bloc_helpers/bloc_provider.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:meta/meta.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:rxdart/rxdart.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocEvent</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocState</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocEventStateBase</span>&lt;<span class="title">BlocEvent</span>, <span class="title">BlocState</span>&gt; <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  PublishSubject&lt;BlocEvent&gt; _eventController = PublishSubject&lt;BlocEvent&gt;();</span><br><span class="line">  BehaviorSubject&lt;BlocState&gt; _stateController = BehaviorSubject&lt;BlocState&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// To be invoked to emit an event</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="built_in">Function</span>(BlocEvent) <span class="keyword">get</span> emitEvent =&gt; _eventController.sink.add;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Current/New state</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  Stream&lt;BlocState&gt; <span class="keyword">get</span> state =&gt; _stateController.stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// External processing of the event</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  Stream&lt;BlocState&gt; eventHandler(BlocEvent event, BlocState currentState);</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// initialState</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="keyword">final</span> BlocState initialState;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  BlocEventStateBase(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.initialState,</span><br><span class="line">  &#125;)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For each received event, we invoke the [eventHandler] and</span></span><br><span class="line">    <span class="comment">// emit any resulting newState</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _eventController.listen((BlocEvent event)&#123;</span><br><span class="line">      BlocState currentState = _stateController.value ?? initialState;</span><br><span class="line">      eventHandler(event, currentState).forEach((BlocState newState)&#123;</span><br><span class="line">        _stateController.sink.add(newState);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _eventController.close();</span><br><span class="line">    _stateController.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，这是一个需要扩展的抽象类，要在扩展类中定义<code>eventHandler</code>方法的行为。</p><p>它暴露了：</p><ul><li>一个<code>Sink</code>(<code>emitEvent</code>)来推送一个事件;</li><li>一个<code>Stream</code>(<code>state</code>)来监听发出的状态。</li></ul><p>在初始化时（请参阅构造函数）：</p><ul><li>需要提供<code>initialState</code>;</li><li>它创建一个<code>StreamSubscription</code>来监听传入的事件<ul><li>将它们发送到<code>eventHandler</code></li><li>发出作为结果的状态。</li></ul></li></ul><h3 id="专门的-BlocEventState"><a href="#专门的-BlocEventState" class="headerlink" title="专门的 BlocEventState"></a>专门的 <code>BlocEventState</code></h3><p>用于实现此类 BlocEventState 的模板在下面给出。之后，我们将实现一个真正的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemplateEventStateBloc</span> <span class="keyword">extends</span> <span class="title">BlocEventStateBase</span>&lt;<span class="title">BlocEvent</span>, <span class="title">BlocState</span>&gt; </span>&#123;</span><br><span class="line">  TemplateEventStateBloc()</span><br><span class="line">      : <span class="keyword">super</span>(</span><br><span class="line">          initialState: BlocState.notInitialized(),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;BlocState&gt; eventHandler( BlocEvent event, BlocState currentState) <span class="keyword">async</span>* &#123;</span><br><span class="line">     <span class="keyword">yield</span> BlocState.notInitialized();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">如果这个模板没有编译通过，请不要担心......这是正常的，因为我们还没有定义`BlocState.notInitialized()`......过一会就有了。</span><br><span class="line"></span><br><span class="line">此模板仅在初始化时提供 `initialState` 并覆盖了 `eventHandler`。</span><br><span class="line"></span><br><span class="line">这里有一些非常有趣的事情需要注意。我们使用异步生成器：<span class="keyword">async</span>* 和 <span class="keyword">yield</span> 声明。</span><br><span class="line"></span><br><span class="line">使用 <span class="keyword">async</span>* 修饰符标记方法，将方法标识为异步生成器：</span><br><span class="line"></span><br><span class="line">每次 <span class="keyword">yield</span> 语句被调用的时候，它都会将 <span class="keyword">yield</span> 后面的表达式结果添加到输出流。</span><br><span class="line"></span><br><span class="line">如果我们需要发送作为一系列动作结果的一系列状态，这是特别有用的。</span><br><span class="line"></span><br><span class="line">有关异步生成器的其它详细信息，请单击此[链接](/dart/<span class="keyword">async</span>/<span class="number">2019</span>/<span class="number">05</span>/<span class="number">04</span>/Dart-Language-Asynchrony-SupportPhase2/)。</span><br><span class="line"></span><br><span class="line">### BlocEvent 和 BlocState</span><br><span class="line"></span><br><span class="line">正如你已经注意到的，我们已经定义了一个 `BlocEvent` 和 `BlocState` 抽象类。</span><br><span class="line"></span><br><span class="line">这些类需要被你想要发出的专门的事件和状态进行扩展。</span><br><span class="line"></span><br><span class="line">### `BlocEventStateBuilder` widget</span><br><span class="line"></span><br><span class="line">这个模式的最后一部分是 `BlocEventStateBuilder` Widget，它允许对`BlocEventState` 发出的`State`作出响应。</span><br><span class="line"></span><br><span class="line">这里是源代码</span><br><span class="line"></span><br><span class="line">```dart</span><br><span class="line"><span class="keyword">typedef</span> Widget AsyncBlocEventStateBuilder&lt;BlocState&gt;(BuildContext context, BlocState state);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocEventStateBuilder</span>&lt;<span class="title">BlocEvent</span>,<span class="title">BlocState</span>&gt; <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> BlocEventStateBuilder(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.bloc,</span><br><span class="line">  &#125;): <span class="keyword">assert</span>(builder != <span class="keyword">null</span>),</span><br><span class="line">      <span class="keyword">assert</span>(bloc != <span class="keyword">null</span>),</span><br><span class="line">      <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> BlocEventStateBase&lt;BlocEvent,BlocState&gt; bloc;</span><br><span class="line">  <span class="keyword">final</span> AsyncBlocEventStateBuilder&lt;BlocState&gt; builder;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamBuilder&lt;BlocState&gt;(</span><br><span class="line">      stream: bloc.state,</span><br><span class="line">      initialData: bloc.initialState,</span><br><span class="line">      builder: (BuildContext context, AsyncSnapshot&lt;BlocState&gt; snapshot)&#123;</span><br><span class="line">        <span class="keyword">return</span> builder(context, snapshot.data);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Widget 不是别的，就是一个专门的 <code>StreamBuilder</code>，它会在每次新的 BlocState被发出之后调用<code>builder</code>输入参数。</p><hr><p>好的。现在我们什么都有了，现在是时候展示我们可以用它们做些什么了……</p><h3 id="例1-应用程序初始化"><a href="#例1-应用程序初始化" class="headerlink" title="例1: 应用程序初始化"></a>例1: 应用程序初始化</h3><p>第一个例子举例说明了你需要应用程序在启动时执行某些任务的情况。</p><p>常见的用途是游戏最初显示启动页(不一定有动画)，同时从服务器获取一些文件，检查是否有更新，尝试连接到所有的游戏中心……在显示真正的主页面之前。为了不给应用程序什么都不做的感觉，它可能会显示一个进度条并间隔地显示一些图片，同时它会完成所有初始化过程。</p><p>我要向你展示的实现非常简单。它只会在屏幕上显示一些完成百分比，但这可以很容易地扩展从而以满足你的需求。</p><p>首先要做的是定义事件和状态……</p><h4 id="应用初始化事件"><a href="#应用初始化事件" class="headerlink" title="应用初始化事件"></a>应用初始化事件</h4><p>在这个例子中，我只会考虑2个事件：</p><ul><li>start：此事件将触发初始化过程;</li><li>stop：该事件可用于强制初始化进程停止</li></ul><p>这里是定义：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationInitializationEvent</span> <span class="keyword">extends</span> <span class="title">BlocEvent</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> ApplicationInitializationEventType type;</span><br><span class="line"></span><br><span class="line">  ApplicationInitializationEvent(&#123;</span><br><span class="line">    <span class="keyword">this</span>.type: ApplicationInitializationEventType.start,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(type != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ApplicationInitializationEventType &#123;</span><br><span class="line">  start,</span><br><span class="line">  stop,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用初始化件状态"><a href="#应用初始化件状态" class="headerlink" title="应用初始化件状态"></a>应用初始化件状态</h4><p>该类将提供与初始化过程相关的信息。</p><p>对于这个例子，我会考虑：</p><ul><li><p>2个标记：</p><ul><li>isInitialized指示初始化是否完成</li><li>isInitializing以了解我们是否处于初始化过程的中间</li></ul></li><li><p>进度完成率</p></li></ul><p>这里是源代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationInitializationState</span> <span class="keyword">extends</span> <span class="title">BlocState</span> </span>&#123;</span><br><span class="line">  ApplicationInitializationState(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.isInitialized,</span><br><span class="line">    <span class="keyword">this</span>.isInitializing: <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.progress: <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isInitialized;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isInitializing;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> progress;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> ApplicationInitializationState.notInitialized() &#123;</span><br><span class="line">    <span class="keyword">return</span> ApplicationInitializationState(</span><br><span class="line">      isInitialized: <span class="keyword">false</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> ApplicationInitializationState.progressing(<span class="built_in">int</span> progress) &#123;</span><br><span class="line">    <span class="keyword">return</span> ApplicationInitializationState(</span><br><span class="line">      isInitialized: progress == <span class="number">100</span>,</span><br><span class="line">      isInitializing: <span class="keyword">true</span>,</span><br><span class="line">      progress: progress,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> ApplicationInitializationState.initialized() &#123;</span><br><span class="line">    <span class="keyword">return</span> ApplicationInitializationState(</span><br><span class="line">      isInitialized: <span class="keyword">true</span>,</span><br><span class="line">      progress: <span class="number">100</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用初始化-Bloc"><a href="#应用初始化-Bloc" class="headerlink" title="应用初始化 Bloc"></a>应用初始化 Bloc</h4><p>该 BLoC 负责基于事件处理初始化过程。</p><p>这里是代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationInitializationBloc</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">BlocEventStateBase</span>&lt;<span class="title">ApplicationInitializationEvent</span>, <span class="title">ApplicationInitializationState</span>&gt; </span>&#123;</span><br><span class="line">  ApplicationInitializationBloc()</span><br><span class="line">      : <span class="keyword">super</span>(</span><br><span class="line">          initialState: ApplicationInitializationState.notInitialized(),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;ApplicationInitializationState&gt; eventHandler(</span><br><span class="line">      ApplicationInitializationEvent event, ApplicationInitializationState currentState) <span class="keyword">async</span>* &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!currentState.isInitialized)&#123;</span><br><span class="line">      <span class="keyword">yield</span> ApplicationInitializationState.notInitialized();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.type == ApplicationInitializationEventType.start) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> progress = <span class="number">0</span>; progress &lt; <span class="number">101</span>; progress += <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">await</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">300</span>));</span><br><span class="line">        <span class="keyword">yield</span> ApplicationInitializationState.progressing(progress);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.type == ApplicationInitializationEventType.stop)&#123;</span><br><span class="line">      <span class="keyword">yield</span> ApplicationInitializationState.initialized();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些解释：</p><ul><li>当收到事件“ApplicationInitializationEventType.start”时，它从0到100开始计数（步骤10），并且对于每个值（0,10,20，……），它发出（通过yield）一个告诉的新状态初始化正在运行（isInitializing = true）及其进度值。</li><li>当收到事件“ApplicationInitializationEventType.stop”时，它认为初始化已完成。</li><li>正如你所看到的，我在计数器循环中放了一些延迟。这将向您展示如何使用任何Future（例如，您需要联系服务器的情况</li></ul><h4 id="将它们全部包装在一起"><a href="#将它们全部包装在一起" class="headerlink" title="将它们全部包装在一起"></a>将它们全部包装在一起</h4><p>现在，剩下的部分是显示显示计数器的伪 Splash 页面……</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitializationPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _InitializationPageState createState() =&gt; _InitializationPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InitializationPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">InitializationPage</span>&gt; </span>&#123;</span><br><span class="line">  ApplicationInitializationBloc bloc;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState()&#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    bloc = ApplicationInitializationBloc();</span><br><span class="line">    bloc.emitEvent(ApplicationInitializationEvent());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    bloc?.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext pageContext) &#123;</span><br><span class="line">    <span class="keyword">return</span> SafeArea(</span><br><span class="line">      child: Scaffold(</span><br><span class="line">        body: Container(</span><br><span class="line">          child: Center(</span><br><span class="line">            child: BlocEventStateBuilder&lt;ApplicationInitializationEvent, ApplicationInitializationState&gt;(</span><br><span class="line">              bloc: bloc,</span><br><span class="line">              builder: (BuildContext context, ApplicationInitializationState state)&#123;</span><br><span class="line">                <span class="keyword">if</span> (state.isInitialized)&#123;</span><br><span class="line">                  <span class="comment">//</span></span><br><span class="line">                  <span class="comment">// Once the initialization is complete, let's move to another page</span></span><br><span class="line">                  <span class="comment">//</span></span><br><span class="line">                  WidgetsBinding.instance.addPostFrameCallback((_)&#123;</span><br><span class="line">                    Navigator.of(context).pushReplacementNamed(<span class="string">'/home'</span>);</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Text(<span class="string">'Initialization in progress... <span class="subst">$&#123;state.progress&#125;</span>%'</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>由于<code>ApplicationInitializationBloc</code>不需要在应用程序的任何地方使用，我们可以在<code>StatefulWidget</code>中初始化它;</li><li>我们直接发出<code>ApplicationInitializationEventType.start</code>事件来触发<code>eventHandler</code></li><li>每次发出<code>ApplicationInitializationState</code>时，我们都会更新文本</li><li>初始化完成后，我们将用户重定向到主页。</li></ul><p>技巧</p><p>由于我们无法在build内部直接重定向到主页,我们使用<code>WidgetsBinding.instance.addPostFrameCallback()</code>方法请求Flutter在渲染完成后立即执行方法。</p><h3 id="例2：应用程序身份验证和注销"><a href="#例2：应用程序身份验证和注销" class="headerlink" title="例2：应用程序身份验证和注销"></a>例2：应用程序身份验证和注销</h3><p>对于此示例，我将考虑以下用例：</p><ul><li>在启动时，如果用户未经过身份验证，则会自动显示“身份验证/注册”页面;</li><li>在用户认证期间，显示一个圆形进度条;</li><li>经过身份验证后，用户将被重定向到主页面;</li><li>在应用程序的任何地方，用户都可以注销;</li><li>当用户注销时，用户将自动重定向到“身份验证”页面。</li></ul><p>当然，很有可能以编程方式处理所有这些，但将所有这些委托给<code>BLoC</code>要容易得多。</p><p>下图解释了我要解释的解决方案</p><p><img src="https://www.didierboelens.com/images/bloc_authentication.png" alt></p><p>名为“DecisionPage”的中间页面将负责将用户自动重定向到“身份验证”页面或主页面，具体取决于用户身份验证的状态。当然，此DecisionPage从不显示，也不应被视为页面。</p><p>首先要做的是定义事件和状态……</p><h4 id="AuthenticationEvent"><a href="#AuthenticationEvent" class="headerlink" title="AuthenticationEvent"></a>AuthenticationEvent</h4><p>在这个例子中，我只考虑2个事件：</p><ul><li>login：当用户正确验证时发出此事件;</li><li>logout：用户注销时发出的事件。</li></ul><p>这里是定义：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bstract <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationEvent</span> <span class="keyword">extends</span> <span class="title">BlocEvent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  AuthenticationEvent(&#123;</span><br><span class="line">    <span class="keyword">this</span>.name: <span class="string">''</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationEventLogin</span> <span class="keyword">extends</span> <span class="title">AuthenticationEvent</span> </span>&#123;</span><br><span class="line">  AuthenticationEventLogin(&#123;</span><br><span class="line">    <span class="built_in">String</span> name,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(</span><br><span class="line">          name: name,</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationEventLogout</span> <span class="keyword">extends</span> <span class="title">AuthenticationEvent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="AuthenticationState"><a href="#AuthenticationState" class="headerlink" title="AuthenticationState"></a>AuthenticationState</h4><p>该类将提供与身份验证过程相关的信息。</p><p>对于这个例子，我会考虑：</p><ul><li>3个标记：<ul><li>isAuthenticated指示身份验证是否完整</li><li>isAuthenticating以了解我们是否处于身份验证过程的中间</li><li>hasFailed表示身份验证失败</li></ul></li><li>经过身份验证的用户名</li></ul><p>这里是源代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationState</span> <span class="keyword">extends</span> <span class="title">BlocState</span> </span>&#123;</span><br><span class="line">  AuthenticationState(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.isAuthenticated,</span><br><span class="line">    <span class="keyword">this</span>.isAuthenticating: <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.hasFailed: <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.name: <span class="string">''</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isAuthenticated;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isAuthenticating;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> hasFailed;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">factory</span> AuthenticationState.notAuthenticated() &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthenticationState(</span><br><span class="line">      isAuthenticated: <span class="keyword">false</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> AuthenticationState.authenticated(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthenticationState(</span><br><span class="line">      isAuthenticated: <span class="keyword">true</span>,</span><br><span class="line">      name: name,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> AuthenticationState.authenticating() &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthenticationState(</span><br><span class="line">      isAuthenticated: <span class="keyword">false</span>,</span><br><span class="line">      isAuthenticating: <span class="keyword">true</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> AuthenticationState.failure() &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthenticationState(</span><br><span class="line">      isAuthenticated: <span class="keyword">false</span>,</span><br><span class="line">      hasFailed: <span class="keyword">true</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AuthenticationBloc"><a href="#AuthenticationBloc" class="headerlink" title="AuthenticationBloc"></a>AuthenticationBloc</h4><p>此<code>BLoC</code>负责根据事件处理身份验证过程。</p><p>这是代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationBloc</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">BlocEventStateBase</span>&lt;<span class="title">AuthenticationEvent</span>, <span class="title">AuthenticationState</span>&gt; </span>&#123;</span><br><span class="line">  AuthenticationBloc()</span><br><span class="line">      : <span class="keyword">super</span>(</span><br><span class="line">          initialState: AuthenticationState.notAuthenticated(),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;AuthenticationState&gt; eventHandler(</span><br><span class="line">      AuthenticationEvent event, AuthenticationState currentState) <span class="keyword">async</span>* &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">is</span> AuthenticationEventLogin) &#123;</span><br><span class="line">      <span class="comment">// Inform that we are proceeding with the authentication</span></span><br><span class="line">      <span class="keyword">yield</span> AuthenticationState.authenticating();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Simulate a call to the authentication server</span></span><br><span class="line">      <span class="keyword">await</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Inform that we have successfuly authenticated, or not</span></span><br><span class="line">      <span class="keyword">if</span> (event.name == <span class="string">"failure"</span>)&#123;</span><br><span class="line">        <span class="keyword">yield</span> AuthenticationState.failure();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> AuthenticationState.authenticated(event.name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">is</span> AuthenticationEventLogout)&#123;</span><br><span class="line">      <span class="keyword">yield</span> AuthenticationState.notAuthenticated();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些解释：</p><ul><li>当收到事件“AuthenticationEventLogin”时，它会（通过yield）发出一个新状态，告知身份验证正在运行（isAuthenticating = true）。</li><li>然后它运行身份验证，一旦完成，就会发出另一个状态，告知身份验证已完成。</li><li>当收到事件“AuthenticationEventLogout”时，它将发出一个新状态，告诉用户不再进行身份验证。</li></ul><h4 id="AuthenticationPage"><a href="#AuthenticationPage" class="headerlink" title="AuthenticationPage"></a>AuthenticationPage</h4><p>正如你将要看到的那样，为了便于解释，此页面非常基本且不会做太多的事情。</p><p>这是代码。解释如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Prevents the use of the "back" button</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; _onWillPopScope() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    AuthenticationBloc bloc = BlocProvider.of&lt;AuthenticationBloc&gt;(context);</span><br><span class="line">    <span class="keyword">return</span> WillPopScope(</span><br><span class="line">      onWillPop: _onWillPopScope,</span><br><span class="line">      child: SafeArea(</span><br><span class="line">        child: Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'Authentication Page'</span>),</span><br><span class="line">            leading: Container(),</span><br><span class="line">          ),</span><br><span class="line">          body: Container(</span><br><span class="line">            child:</span><br><span class="line">                BlocEventStateBuilder&lt;AuthenticationEvent, AuthenticationState&gt;(</span><br><span class="line">              bloc: bloc,</span><br><span class="line">              builder: (BuildContext context, AuthenticationState state) &#123;</span><br><span class="line">                <span class="keyword">if</span> (state.isAuthenticating) &#123;</span><br><span class="line">                  <span class="keyword">return</span> PendingAction();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (state.isAuthenticated)&#123;</span><br><span class="line">                  <span class="keyword">return</span> Container();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">List</span>&lt;Widget&gt; children = &lt;Widget&gt;[];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Button to fake the authentication (success)</span></span><br><span class="line">                children.add(</span><br><span class="line">                  ListTile(</span><br><span class="line">                      title: RaisedButton(</span><br><span class="line">                        child: Text(<span class="string">'Log in (success)'</span>),</span><br><span class="line">                        onPressed: () &#123;</span><br><span class="line">                            bloc.emitEvent(AuthenticationEventLogin(name: <span class="string">'Didier'</span>));</span><br><span class="line">                        &#125;,</span><br><span class="line">                      ),</span><br><span class="line">                    ),</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Button to fake the authentication (failure)</span></span><br><span class="line">                children.add(</span><br><span class="line">                  ListTile(</span><br><span class="line">                      title: RaisedButton(</span><br><span class="line">                        child: Text(<span class="string">'Log in (failure)'</span>),</span><br><span class="line">                        onPressed: () &#123;</span><br><span class="line">                            bloc.emitEvent(AuthenticationEventLogin(name: <span class="string">'failure'</span>));</span><br><span class="line">                        &#125;,</span><br><span class="line">                      ),</span><br><span class="line">                    ),</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Display a text if the authentication failed</span></span><br><span class="line">                <span class="keyword">if</span> (state.hasFailed)&#123;</span><br><span class="line">                  children.add(</span><br><span class="line">                    Text(<span class="string">'Authentication failure!'</span>),</span><br><span class="line">                  );</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Column(</span><br><span class="line">                  children: children,</span><br><span class="line">                );    </span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>第11行：页面获取指向<code>AuthenticationBloc</code>的引用</li><li>第24-70行：它监听发出的<code>AuthenticationState</code>：</li><li>如果身份验证正在进行中，它会显示一个CircularProgressIndicator，告诉用户正在进行某些操作并阻止用户访问该页面（第25-27行）</li><li>如果验证成功，我们不需要显示任何内容（第29-31行）。</li><li>如果用户未经过身份验证，则会显示2个按钮以模拟成功的身份验证和失败。</li><li>当我们点击其中一个按钮时，我们发出一个<code>AuthenticationEventLogin</code>事件，以及一些参数（通常由认证过程使用）</li><li>如果验证失败，我们会显示错误消息（第60-64行）</li></ul><p>仅此而已！没有别的事情需要做……是不是很容易？</p><p>小贴士</p><p>您可能已经注意到，我将页面包装在WillPopScope中。</p><p>理由是我不希望用户能够使用Android’后退’按钮，如此示例中所示，身份验证是一个必须的步骤，它阻止用户访问任何其他部分，除非经过正确的身份验证。</p><h4 id="DecisionPage"><a href="#DecisionPage" class="headerlink" title="DecisionPage"></a>DecisionPage</h4><p>如前所述，我希望应用程序根据身份验证状态自动重定向到<code>AuthenticationPage</code>或<code>HomePage</code>。</p><p>以下是此DecisionPage的代码，说明如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecisionPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  DecisionPageState createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecisionPageState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecisionPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">DecisionPage</span>&gt; </span>&#123;</span><br><span class="line">  AuthenticationState oldAuthenticationState;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    AuthenticationBloc bloc = BlocProvider.of&lt;AuthenticationBloc&gt;(context);</span><br><span class="line">    <span class="keyword">return</span> BlocEventStateBuilder&lt;AuthenticationEvent, AuthenticationState&gt;(</span><br><span class="line">      bloc: bloc,</span><br><span class="line">      builder: (BuildContext context, AuthenticationState state) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != oldAuthenticationState)&#123;</span><br><span class="line">          oldAuthenticationState = state;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (state.isAuthenticated)&#123;</span><br><span class="line">            _redirectToPage(context, HomePage());</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.isAuthenticating || state.hasFailed)&#123;</span><br><span class="line">  <span class="comment">//do nothing</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _redirectToPage(context, AuthenticationPage());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This page does not need to display anything since it will</span></span><br><span class="line">        <span class="comment">// always remind behind any active page (and thus 'hidden').</span></span><br><span class="line">        <span class="keyword">return</span> Container();</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _redirectToPage(BuildContext context, Widget page)&#123;</span><br><span class="line">    WidgetsBinding.instance.addPostFrameCallback((_)&#123;</span><br><span class="line">      MaterialPageRoute newRoute = MaterialPageRoute(</span><br><span class="line">          builder: (BuildContext context) =&gt; page</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">      Navigator.of(context).pushAndRemoveUntil(newRoute, ModalRoute.withName(<span class="string">'/decision'</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提醒</p><p>为了详细解释这一点，我们需要回到 Flutter处理Pages（= Route）的方式。要处理路由，我们使用导航器，它创建一个叠加层。</p><p>这个<code>Overlay</code>是一个OverlayEntry栈，每个都包含一个Page。</p><p>当我们通过Navigator.of(context) <code>pushing</code>,<code>poping</code>,替换页面时，后者就会更新它的<code>Overlay</code>(栈也被更新了)，也就是被重建了。</p><p>当栈被重建的时候，每个OverlayEntry(以及它的内容)也被重建了。</p><p>因此,当我们通过Navigator.of(context)进行操作时，所有剩余的页面都会重建！</p><ul><li>那么，为什么我将它实现为 StatefulWidget？</li></ul><p>为了能够响应AuthenticationState的任何更改，此“页面”需要在应用程序的整个生命周期中保持存在。</p><p>这意味着，根据上面的提醒，每次Navigator.of（context）完成操作时，都会重建此页面。</p><p>因此，它的<code>BlocEventStateBuilder</code>也将重建，调用自己的builder方法。</p><p>因为此builder负责将用户重定向到与<code>AuthenticationState</code>对应的页面，所以如果我们每次重建页面时重定向用户，它会由于持续的重建而不断地重定向。</p><p>为了防止这种情况发生，我们只需要记住我们采取行动的最后一个<code>AuthenticationState</code>，并且只在收到另一个<code>AuthenticationState</code>时采取另一个动作。</p><ul><li>这是如何运作的？</li></ul><p>如上所述，每次发出<code>AuthenticationState</code>时，BlocEventStateBuilder都会调用builder。</p><p>基于状态标志（isAuthenticated），我们知道我们需要向哪个页面重定向用户。</p><p>小技巧</p><p>由于我们无法直接从builder重定向到另一个页面，因此我们使用WidgetsBinding.instance.addPostFrameCallback()方法在渲染一完成后就请求Flutter执行方法。</p><p>此外，由于我们需要在重定向用户之前删除任何现有页面，除了需要保留在所有情况下的DecisionPage之外，我们使Navigator.of(context).pushAndRemoveUntil(…)来到达此目的。</p><h4 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h4><p>要让用户注销，您现在可以创建一个“LogOutButton”并将其放在应用程序的任何位置。</p><p>此按钮只需要发出<code>AuthenticationEventLogout()</code>事件，这将导致以下操作的自动链：</p><ol><li>它将由<code>AuthenticationBloc</code>处理</li><li>反过来会发出一个<code>AuthentiationState</code>（isAuthenticated = false）</li><li>这将由DecisionPage通过<code>BlocEventStateBuilder</code>处理</li><li>这会将用户重定向到<code>AuthenticationPage</code></li></ol><p>这是这个按钮的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogOutButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    AuthenticationBloc bloc = BlocProvider.of&lt;AuthenticationBloc&gt;(context);</span><br><span class="line">    <span class="keyword">return</span> IconButton(</span><br><span class="line">      icon: Icon(Icons.exit_to_app),</span><br><span class="line">      onPressed: () &#123;</span><br><span class="line">        bloc.emitEvent(AuthenticationEventLogout());</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AuthenticationBloc-1"><a href="#AuthenticationBloc-1" class="headerlink" title="AuthenticationBloc"></a>AuthenticationBloc</h4><p>由于 AuthenticationBloc 需要可用于此应用程序的任何页面，我们还会将其作为MaterialApp的 父级注入，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(Application());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> BlocProvider&lt;AuthenticationBloc&gt;(</span><br><span class="line">      bloc: AuthenticationBloc(),</span><br><span class="line">      child: MaterialApp(</span><br><span class="line">        title: <span class="string">'BLoC Samples'</span>,</span><br><span class="line">        theme: ThemeData(</span><br><span class="line">          primarySwatch: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        home: DecisionPage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p><code>BLoC</code>的另一个有趣用途是当您需要验证表单时：</p><ul><li>根据某些业务规则验证与TextField相关的条目;</li><li>根据规则显示验证错误消息;</li><li>根据业务规则自动化widget的可访问性。</li></ul><p>我现在要做的一个例子是RegistrationForm，它由3个TextField电子邮件，密码，确认密码）和1个RaisedButton组成，以启动注册过程。</p><p>我想要实现的业务规则是：</p><ul><li>电子邮件需要是有效的电子邮件地址。如果不是，则需要显示一条消息。</li><li>密码必须有效（必须包含至少8个字符，1个大写，1个小写，1个数字和1个特殊字符。如果无效，则需要显示一条消息。</li><li>重新输入密码需要符合相同的验证规则并且与密码相同。如果不相同，则需要显示消息。</li><li>注册按钮只有在所有规则有效时才有效。</li></ul><h3 id="RegistrationFormBloc"><a href="#RegistrationFormBloc" class="headerlink" title="RegistrationFormBloc"></a>RegistrationFormBloc</h3><p>该<code>BLoC</code>负责处理验证业务规则，如前所述。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegistrationFormBloc</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="title">with</span> <span class="title">EmailValidator</span>, <span class="title">PasswordValidator</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> BehaviorSubject&lt;<span class="built_in">String</span>&gt; _emailController = BehaviorSubject&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">  <span class="keyword">final</span> BehaviorSubject&lt;<span class="built_in">String</span>&gt; _passwordController = BehaviorSubject&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">  <span class="keyword">final</span> BehaviorSubject&lt;<span class="built_in">String</span>&gt; _passwordConfirmController = BehaviorSubject&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  Inputs</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="built_in">Function</span>(<span class="built_in">String</span>) <span class="keyword">get</span> onEmailChanged =&gt; _emailController.sink.add;</span><br><span class="line">  <span class="built_in">Function</span>(<span class="built_in">String</span>) <span class="keyword">get</span> onPasswordChanged =&gt; _passwordController.sink.add;</span><br><span class="line">  <span class="built_in">Function</span>(<span class="built_in">String</span>) <span class="keyword">get</span> onRetypePasswordChanged =&gt; _passwordConfirmController.sink.add;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Validators</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  Stream&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> email =&gt; _emailController.stream.transform(validateEmail);</span><br><span class="line">  Stream&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> password =&gt; _passwordController.stream.transform(validatePassword);</span><br><span class="line">  Stream&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> confirmPassword =&gt; _passwordConfirmController.stream.transform(validatePassword)</span><br><span class="line">    .doOnData((<span class="built_in">String</span> c)&#123;</span><br><span class="line">      <span class="comment">// If the password is accepted (after validation of the rules)</span></span><br><span class="line">      <span class="comment">// we need to ensure both password and retyped password match</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> != _passwordController.value.compareTo(c))&#123;</span><br><span class="line">        <span class="comment">// If they do not match, add an error</span></span><br><span class="line">        _passwordConfirmController.addError(<span class="string">"No Match"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Registration button</span></span><br><span class="line">  Stream&lt;<span class="built_in">bool</span>&gt; <span class="keyword">get</span> registerValid =&gt; Observable.combineLatest3(</span><br><span class="line">                                      email, </span><br><span class="line">                                      password, </span><br><span class="line">                                      confirmPassword, </span><br><span class="line">                                      (e, p, c) =&gt; <span class="keyword">true</span></span><br><span class="line">                                    );</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _emailController?.close();</span><br><span class="line">    _passwordController?.close();</span><br><span class="line">    _passwordConfirmController?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我详细解释一下……</p><ul><li>我们首先初始化3个<code>BehaviorSubjec</code>来处理表单的每个<code>TextField</code>的<code>Streams</code>。</li><li>我们暴露了3个Function(String），它将用于接受来自<code>TextField</code>的输入。</li><li>我们暴露了3个Stream<string>，<code>TextField</code>将使用它来显示由它们各自的验证产生的潜在错误消息</string></li><li>我们暴露了1个Stream<bool>，它将被RaisedButton使用，以根据整个验证结果启用/禁用它。</bool></li></ul><p>好的，现在是时候深入了解更多细节了……</p><ul><li>您可能已经注意到，此类的签名有点特殊。我们来回顾一下吧。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegistrationFormBloc</span> <span class="keyword">extends</span> <span class="title">Object</span> </span></span><br><span class="line"><span class="class">                           <span class="title">with</span> <span class="title">EmailValidator</span>, <span class="title">PasswordValidator</span> </span></span><br><span class="line"><span class="class">                           <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>with关键字表示此类正在使用MIXINS（=“在另一个类中重用某些类代码的方法”），并且为了能够使用with关键字，该类需要扩展Object类。这些mixin包含分别验证电子邮件和密码的代码。</p><p>有关Mixins的更多详细信息，我建议您阅读<a href="https://medium.com/flutter-community/dart-what-are-mixins-3a72344011f3" target="_blank" rel="noopener">Romain Rastel的这篇精彩文章</a>。</p><h4 id="Validator-Mixins"><a href="#Validator-Mixins" class="headerlink" title="Validator Mixins"></a>Validator Mixins</h4><p>我只会解释EmailValidator，因为PasswordValidator非常相似</p><p>首先，是代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">String</span> _kEmailRule = <span class="string">r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailValidator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> StreamTransformer&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; validateEmail = </span><br><span class="line">      StreamTransformer&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt;.fromHandlers(handleData: (email, sink)&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">RegExp</span> emailExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(_kEmailRule);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!emailExp.hasMatch(email) || email.isEmpty)&#123;</span><br><span class="line">          sink.addError(<span class="string">'Entre a valid email'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          sink.add(email);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类暴露了一个<code>final</code>方法（“validateEmail”），它是一个<code>StreamTransformer</code>。</p><p>提醒</p><p><code>StreamTransformer</code>的调用方式如下：stream.transform(StreamTransformer）。</p><p><code>StreamTransformer</code>通过transform方法从<code>Stream</code>引用它的输入。然后它处理此输入，并将转换后的输入重新注入初始<code>Stream</code>。</p><p>在此代码中，输入的处理包括根据正则表达式进行检查。如果输入与正则表达式匹配，我们只需将输入重新注入流中，否则，我们会向流中注入错误消息。</p><h4 id="为什么使用stream-tansform"><a href="#为什么使用stream-tansform" class="headerlink" title="为什么使用stream.tansform()?"></a>为什么使用stream.tansform()?</h4><p>如前所述，如果验证成功，StreamTransformer会将输入重新注入Stream。为什么有用？</p><p>以下是与Observable.combineLatest3()相关的解释…此方法在它引用的所有Streams之前不会发出任何值，至少发出一个值。</p><p>让我们看看下面的图片来说明我们想要实现的目标。</p><p><img src="https://www.didierboelens.com/images/bloc_combine.png" alt></p><ul><li>如果用户输入电子邮件并且后者经过验证，它将由电子邮件流发出，该电子邮件流将是Observable.combineLatest3()的一个输入;</li><li>如果电子邮件无效，则会向流中添加错误（并且流中没有值）;</li><li>这同样适用于密码和重新输入密码;</li><li>当所有这三个验证都成功时（意味着所有这三个流都会发出一个值），Observable.combineLatest3（）将依次发出一个真正的感谢“（e，p，c）=&gt; true”（见第35行）。</li></ul><h4 id="验证2个密码"><a href="#验证2个密码" class="headerlink" title="验证2个密码"></a>验证2个密码</h4><p>我在互联网上看到了很多与这种比较有关的问题。存在几种解决方案，让我解释其中的两种。</p><h5 id="基本解决方案-没有错误消息"><a href="#基本解决方案-没有错误消息" class="headerlink" title="基本解决方案 - 没有错误消息"></a>基本解决方案 - 没有错误消息</h5><p>第一个解决方案可能是以下一个：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">bool</span>&gt; <span class="keyword">get</span> registerValid =&gt; Observable.combineLatest3(</span><br><span class="line">                                      email, </span><br><span class="line">                                      password, </span><br><span class="line">                                      confirmPassword, </span><br><span class="line">                                      (e, p, c) =&gt; (<span class="number">0</span> == p.compareTo(c))</span><br><span class="line">                                    );</span><br></pre></td></tr></table></figure><p>这个解决方案只需验证两个密码，如果它们匹配，就会发出一个值（= true）。</p><p>我们很快就会看到，Register按钮的可访问性将取决于registerValid流。</p><p>如果两个密码不匹配，则该流不会发出任何值，并且“注册”按钮保持不活动状态，但用户不会收到任何错误消息以帮助他理解原因。</p><h5 id="带错误消息的解决方案"><a href="#带错误消息的解决方案" class="headerlink" title="带错误消息的解决方案"></a>带错误消息的解决方案</h5><p>另一种解决方案包括扩展confirmPassword流的处理，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">String</span>&gt; <span class="keyword">get</span> confirmPassword =&gt; _passwordConfirmController.stream.transform(validatePassword)</span><br><span class="line">    .doOnData((<span class="built_in">String</span> c)&#123;</span><br><span class="line">      <span class="comment">// If the password is accepted (after validation of the rules)</span></span><br><span class="line">      <span class="comment">// we need to ensure both password and retyped password match</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> != _passwordController.value.compareTo(c))&#123;</span><br><span class="line">        <span class="comment">// If they do not match, add an error</span></span><br><span class="line">        _passwordConfirmController.addError(<span class="string">"No Match"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>一旦验证了重新输入密码，它就会被Stream发出，并且使用doOnData，我们可以直接获取此发出的值并将其与密码流的值进行比较。如果两者不匹配，我们现在可以发送错误消息。</p><h3 id="注册表单"><a href="#注册表单" class="headerlink" title="注册表单"></a>注册表单</h3><p>现在让我们先解释一下RegistrationForm：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegistrationForm</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _RegistrationFormState createState() =&gt; _RegistrationFormState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_RegistrationFormState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RegistrationForm</span>&gt; </span>&#123;</span><br><span class="line">  RegistrationFormBloc _registrationFormBloc;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _registrationFormBloc = RegistrationFormBloc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _registrationFormBloc?.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Form(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          StreamBuilder&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">              stream: _registrationFormBloc.email,</span><br><span class="line">              builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">String</span>&gt; snapshot) &#123;</span><br><span class="line">                <span class="keyword">return</span> TextField(</span><br><span class="line">                  decoration: InputDecoration(</span><br><span class="line">                    labelText: <span class="string">'email'</span>,</span><br><span class="line">                    errorText: snapshot.error,</span><br><span class="line">                  ),</span><br><span class="line">                  onChanged: _registrationFormBloc.onEmailChanged,</span><br><span class="line">                  keyboardType: TextInputType.emailAddress,</span><br><span class="line">                );</span><br><span class="line">              &#125;),</span><br><span class="line">          StreamBuilder&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">              stream: _registrationFormBloc.password,</span><br><span class="line">              builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">String</span>&gt; snapshot) &#123;</span><br><span class="line">                <span class="keyword">return</span> TextField(</span><br><span class="line">                  decoration: InputDecoration(</span><br><span class="line">                    labelText: <span class="string">'password'</span>,</span><br><span class="line">                    errorText: snapshot.error,</span><br><span class="line">                  ),</span><br><span class="line">                  obscureText: <span class="keyword">false</span>,</span><br><span class="line">                  onChanged: _registrationFormBloc.onPasswordChanged,</span><br><span class="line">                );</span><br><span class="line">              &#125;),</span><br><span class="line">          StreamBuilder&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">              stream: _registrationFormBloc.confirmPassword,</span><br><span class="line">              builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">String</span>&gt; snapshot) &#123;</span><br><span class="line">                <span class="keyword">return</span> TextField(</span><br><span class="line">                  decoration: InputDecoration(</span><br><span class="line">                    labelText: <span class="string">'retype password'</span>,</span><br><span class="line">                    errorText: snapshot.error,</span><br><span class="line">                  ),</span><br><span class="line">                  obscureText: <span class="keyword">false</span>,</span><br><span class="line">                  onChanged: _registrationFormBloc.onRetypePasswordChanged,</span><br><span class="line">                );</span><br><span class="line">              &#125;),</span><br><span class="line">          StreamBuilder&lt;<span class="built_in">bool</span>&gt;(</span><br><span class="line">              stream: _registrationFormBloc.registerValid,</span><br><span class="line">              builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">bool</span>&gt; snapshot) &#123;</span><br><span class="line">                <span class="keyword">return</span> RaisedButton(</span><br><span class="line">                  child: Text(<span class="string">'Register'</span>),</span><br><span class="line">                  onPressed: (snapshot.hasData &amp;&amp; snapshot.data == <span class="keyword">true</span>)</span><br><span class="line">                      ? () &#123;</span><br><span class="line">                          <span class="comment">// launch the registration process</span></span><br><span class="line">                        &#125;</span><br><span class="line">                      : <span class="keyword">null</span>,</span><br><span class="line">                );</span><br><span class="line">              &#125;),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>由于RegisterFormBloc仅供此表单使用，因此适合在此处初始化它。</li><li>每个TextField都包装在StreamBuilder<string>中，以便能够响应验证过程的任何结果（请参阅errorText：snapshot.error）</string></li><li>每次对TextField的内容进行修改时，我们都会通过onChanged发送输入到BLoC进行验证：_registrationFormBloc.onEmailChanged（电子邮件输入的情况）</li><li>对于RegisterButton，后者也包含在StreamBuilder <bool>中。<ul><li>如果_registrationFormBloc.registerValid发出一个值，onPressed方法将执行某些操作</li><li>如果未发出任何值，则onPressed方法将被指定为null，这将取消激活该按钮。</li></ul></bool></li></ul><p>仅此而已！表单中没有任何业务规则，这意味着可以更改规则而无需对表单进行任何修改，这非常好！</p><h2 id="Part-of"><a href="#Part-of" class="headerlink" title="Part of"></a>Part of</h2><p>有时，Widget知道它是否是驱动其行为的集合的一部分是有趣的。</p><p>对于本文的最后一个实际例子，我将考虑以下场景：</p><ul><li>一个处理多个商品的应用程序</li><li>用户可以选择商品并将其放入购物篮篮中;</li><li>一件商品只能放入购物篮一次;</li><li>存放在购物篮中的物品可以从购物篮中取出;</li><li>一旦被移除，有可能把它放回来。</li></ul><p>对于此示例，每个商品将显示为一个按钮，该按钮将取决于购物篮篮物品的存在与否。如果不是购物篮的一部分，该按钮将允许用户将其添加到购物篮中。如果是购物篮的一部分，该按钮将允许用户将其从购物篮中取出。</p><p>为了更好地说明“Part of”模式，我将考虑以下架构：</p><ul><li>购物页面将显示所有可能的条目列表;</li><li>购物页面中的每个商品都会显示一个按钮，用于将商品添加到购物篮或将其移除，具体取决于其在购物篮中是否存在;</li><li>如果购物页面中的商品被添加到购物篮中，其按钮将自动更新以允许用户将其从购物篮中移除（反之亦然），而无需重建购物页面</li><li>另一个页面，购物篮，将列出篮子里的所有物品;</li><li>可以从此页面中删除购物篮中的任何商品。</li></ul><p>边注</p><p>Part Of这个名字是我给的个人名字。这不是官方名称。</p><h3 id="ShoppingBloc"><a href="#ShoppingBloc" class="headerlink" title="ShoppingBloc"></a>ShoppingBloc</h3><p>正如您现在可以想象的那样，我们需要考虑一个专门用于处理所有可能商品列表的<code>BLoC</code>，以及购物篮的一部分。</p><p>这个BLoC可能如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingBloc</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="comment">// List of all items, part of the shopping basket</span></span><br><span class="line">  <span class="built_in">Set</span>&lt;ShoppingItem&gt; _shoppingBasket = <span class="built_in">Set</span>&lt;ShoppingItem&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stream to list of all possible items</span></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt; _itemsController = BehaviorSubject&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt;();</span><br><span class="line">  Stream&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt; <span class="keyword">get</span> items =&gt; _itemsController;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stream to list the items part of the shopping basket</span></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt; _shoppingBasketController = BehaviorSubject&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt;(seedValue: &lt;ShoppingItem&gt;[]);</span><br><span class="line">  Stream&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt; <span class="keyword">get</span> shoppingBasket =&gt; _shoppingBasketController;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _itemsController?.close();</span><br><span class="line">    _shoppingBasketController?.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  ShoppingBloc() &#123;</span><br><span class="line">    _loadShoppingItems();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> addToShoppingBasket(ShoppingItem item)&#123;</span><br><span class="line">    _shoppingBasket.add(item);</span><br><span class="line">    _postActionOnBasket();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> removeFromShoppingBasket(ShoppingItem item)&#123;</span><br><span class="line">    _shoppingBasket.remove(item);</span><br><span class="line">    _postActionOnBasket();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _postActionOnBasket()&#123;</span><br><span class="line">    <span class="comment">// Feed the shopping basket stream with the new content</span></span><br><span class="line">    _shoppingBasketController.sink.add(_shoppingBasket.toList());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// any additional processing such as</span></span><br><span class="line">    <span class="comment">// computation of the total price of the basket</span></span><br><span class="line">    <span class="comment">// number of items, part of the basket...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Generates a series of Shopping Items</span></span><br><span class="line">  <span class="comment">// Normally this should come from a call to the server</span></span><br><span class="line">  <span class="comment">// but for this sample, we simply simulate</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">void</span> _loadShoppingItems() &#123;</span><br><span class="line">    _itemsController.sink.add(<span class="built_in">List</span>&lt;ShoppingItem&gt;.generate(<span class="number">50</span>, (<span class="built_in">int</span> index) &#123;</span><br><span class="line">      <span class="keyword">return</span> ShoppingItem(</span><br><span class="line">        id: index,</span><br><span class="line">        title: <span class="string">"Item <span class="subst">$index</span>"</span>,</span><br><span class="line">        price: ((Random().nextDouble() * <span class="number">40.0</span> + <span class="number">10.0</span>) * <span class="number">100.0</span>).roundToDouble() /</span><br><span class="line">            <span class="number">100.0</span>,</span><br><span class="line">        color: Color((Random().nextDouble() * <span class="number">0xFFFFFF</span>).toInt() &lt;&lt; <span class="number">0</span>)</span><br><span class="line">            .withOpacity(<span class="number">1.0</span>),</span><br><span class="line">      );</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一可能需要解释的方法是_postActionOnBasket（）方法。每次在篮子中添加或删除商品时，我们都需要“刷新”_shoppingBasketController Stream的内容，以便通知所有正在监听此Stream更改的Widgets并能够刷新/重建。</p><h3 id="ShoppingPage"><a href="#ShoppingPage" class="headerlink" title="ShoppingPage"></a>ShoppingPage</h3><p>此页面非常简单，只显示所有项目。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    ShoppingBloc bloc = BlocProvider.of&lt;ShoppingBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SafeArea(</span><br><span class="line">        child: Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'Shopping Page'</span>),</span><br><span class="line">        actions: &lt;Widget&gt;[</span><br><span class="line">          ShoppingBasket(),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">      body: Container(</span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt;(</span><br><span class="line">          stream: bloc.items,</span><br><span class="line">          builder: (BuildContext context,</span><br><span class="line">              AsyncSnapshot&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt; snapshot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!snapshot.hasData) &#123;</span><br><span class="line">              <span class="keyword">return</span> Container();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> GridView.builder(</span><br><span class="line">              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">                crossAxisCount: <span class="number">3</span>,</span><br><span class="line">                childAspectRatio: <span class="number">1.0</span>,</span><br><span class="line">              ),</span><br><span class="line">              itemCount: snapshot.data.length,</span><br><span class="line">              itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">                <span class="keyword">return</span> ShoppingItemWidget(</span><br><span class="line">                  shoppingItem: snapshot.data[index],</span><br><span class="line">                );</span><br><span class="line">              &#125;,</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>AppBar显示一个按钮：<ul><li>显示出现在购物篮中的商品数量</li><li>单击时将用户重定向到ShoppingBasket页面</li></ul></li><li>项目列表使用GridView构建，包含在StreamBuilder&lt;List<shoppingitem>&gt;中</shoppingitem></li><li>每个商品对应一个<code>ShoppingItemWidget</code></li></ul><h3 id="ShoppingBasketPage"><a href="#ShoppingBasketPage" class="headerlink" title="ShoppingBasketPage"></a>ShoppingBasketPage</h3><p>此页面与ShoppingPage非常相似，只是StreamBuilder现在正在监听由ShoppingBloc暴露的_shoppingBasket流的变体。</p><h3 id="ShoppingItemWidget和ShoppingItemBloc"><a href="#ShoppingItemWidget和ShoppingItemBloc" class="headerlink" title="ShoppingItemWidget和ShoppingItemBloc"></a>ShoppingItemWidget和ShoppingItemBloc</h3><p>Part of 模式的依赖于这两个元素的组合：</p><ul><li>ShoppingItemWidget负责：<ul><li>显示商品和</li><li>用于在购物篮中添加商品或从中取出商品的按钮</li></ul></li><li>ShoppingItemBloc负责告诉ShoppingItemWidget后者是否属于购物篮的一部分。</li></ul><p>让我们看看它们如何一起工作……</p><h4 id="ShoppingItemBloc"><a href="#ShoppingItemBloc" class="headerlink" title="ShoppingItemBloc"></a>ShoppingItemBloc</h4><p>ShoppingItemBloc由每个ShoppingItemWidget实例化，赋予它“身份”。</p><p>此BLoC监听<code>ShoppingBasket</code>流的所有变体，并检查特定商品标识是否是购物篮的一部分。</p><p>如果是，它会发出一个布尔值（= true），它将被<code>ShoppingItemWidget</code>捕获，以确定它是否是购物篮的一部分。</p><p>这里是BLoc的代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingItemBloc</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Stream to notify if the ShoppingItemWidget is part of the shopping basket</span></span><br><span class="line">  BehaviorSubject&lt;<span class="built_in">bool</span>&gt; _isInShoppingBasketController = BehaviorSubject&lt;<span class="built_in">bool</span>&gt;();</span><br><span class="line">  Stream&lt;<span class="built_in">bool</span>&gt; <span class="keyword">get</span> isInShoppingBasket =&gt; _isInShoppingBasketController;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stream that receives the list of all items, part of the shopping basket</span></span><br><span class="line">  PublishSubject&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt; _shoppingBasketController = PublishSubject&lt;<span class="built_in">List</span>&lt;ShoppingItem&gt;&gt;();</span><br><span class="line">  <span class="built_in">Function</span>(<span class="built_in">List</span>&lt;ShoppingItem&gt;) <span class="keyword">get</span> shoppingBasket =&gt; _shoppingBasketController.sink.add;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constructor with the 'identity' of the shoppingItem</span></span><br><span class="line">  ShoppingItemBloc(ShoppingItem shoppingItem)&#123;</span><br><span class="line">    <span class="comment">// Each time a variation of the content of the shopping basket</span></span><br><span class="line">    _shoppingBasketController.stream</span><br><span class="line">                          <span class="comment">// we check if this shoppingItem is part of the shopping basket</span></span><br><span class="line">                         .map((list) =&gt; list.any((ShoppingItem item) =&gt; item.id == shoppingItem.id))</span><br><span class="line">                          <span class="comment">// if it is part</span></span><br><span class="line">                         .listen((isInShoppingBasket)</span><br><span class="line">                              <span class="comment">// we notify the ShoppingItemWidget </span></span><br><span class="line">                            =&gt; _isInShoppingBasketController.add(isInShoppingBasket));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _isInShoppingBasketController?.close();</span><br><span class="line">    _shoppingBasketController?.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">#### ShoppingItemWidget</span><br><span class="line"></span><br><span class="line">此Widget负责：</span><br><span class="line"></span><br><span class="line">* 创建ShoppingItemBloc的实例并将其自己的标识传递给BLoC</span><br><span class="line">* 监听ShoppingBasket内容的任何变化并将其转移到BLoC</span><br><span class="line">* 监听ShoppingItemBloc从而知道它是否是篮子的一部分</span><br><span class="line">* 显示相应的按钮（添加/删除），具体取决于它在购物篮中是否存在</span><br><span class="line">* 响应按钮的用户操作</span><br><span class="line">  * 当用户点击添加按钮时，将自己添加到购物篮中</span><br><span class="line">  * 当用户点击删除按钮时，将自己从购物篮中移除。</span><br><span class="line"></span><br><span class="line">让我们看看它是如何工作的（解释在代码中给出）。</span><br><span class="line"></span><br><span class="line">```dart</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingItemWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  ShoppingItemWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.shoppingItem,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ShoppingItem shoppingItem;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ShoppingItemWidgetState createState() =&gt; _ShoppingItemWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ShoppingItemWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ShoppingItemWidget</span>&gt; </span>&#123;</span><br><span class="line">  StreamSubscription _subscription;</span><br><span class="line">  ShoppingItemBloc _bloc;</span><br><span class="line">  ShoppingBloc _shoppingBloc;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// As the context should not be used in the "initState()" method,</span></span><br><span class="line">    <span class="comment">// prefer using the "didChangeDependencies()" when you need</span></span><br><span class="line">    <span class="comment">// to refer to the context at initialization time</span></span><br><span class="line">    _initBloc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(ShoppingItemWidget oldWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.didUpdateWidget(oldWidget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as Flutter might decide to reorganize the Widgets tree</span></span><br><span class="line">    <span class="comment">// it is preferable to recreate the links</span></span><br><span class="line">    _disposeBloc();</span><br><span class="line">    _initBloc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _disposeBloc();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This routine is reponsible for creating the links</span></span><br><span class="line">  <span class="keyword">void</span> _initBloc() &#123;</span><br><span class="line">    <span class="comment">// Create an instance of the ShoppingItemBloc</span></span><br><span class="line">    _bloc = ShoppingItemBloc(widget.shoppingItem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve the BLoC that handles the Shopping Basket content </span></span><br><span class="line">    _shoppingBloc = BlocProvider.of&lt;ShoppingBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Simple pipe that transfers the content of the shopping</span></span><br><span class="line">    <span class="comment">// basket to the ShoppingItemBloc</span></span><br><span class="line">    _subscription = _shoppingBloc.shoppingBasket.listen(_bloc.shoppingBasket);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _disposeBloc() &#123;</span><br><span class="line">    _subscription?.cancel();</span><br><span class="line">    _bloc?.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildButton() &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamBuilder&lt;<span class="built_in">bool</span>&gt;(</span><br><span class="line">      stream: _bloc.isInShoppingBasket,</span><br><span class="line">      initialData: <span class="keyword">false</span>,</span><br><span class="line">      builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">bool</span>&gt; snapshot) &#123;</span><br><span class="line">        <span class="keyword">return</span> snapshot.data</span><br><span class="line">            ? _buildRemoveFromShoppingBasket()</span><br><span class="line">            : _buildAddToShoppingBasket();</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildAddToShoppingBasket()&#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      child: Text(<span class="string">'Add...'</span>),</span><br><span class="line">      onPressed: ()&#123;</span><br><span class="line">        _shoppingBloc.addToShoppingBasket(widget.shoppingItem);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildRemoveFromShoppingBasket()&#123;</span><br><span class="line">    <span class="keyword">return</span> RaisedButton(</span><br><span class="line">      child: Text(<span class="string">'Remove...'</span>),</span><br><span class="line">      onPressed: ()&#123;</span><br><span class="line">        _shoppingBloc.removeFromShoppingBasket(widget.shoppingItem);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Card(</span><br><span class="line">      child: GridTile(</span><br><span class="line">        header: Center(</span><br><span class="line">          child: Text(widget.shoppingItem.title),</span><br><span class="line">        ),</span><br><span class="line">        footer: Center(</span><br><span class="line">          child: Text(<span class="string">'<span class="subst">$&#123;widget.shoppingItem.price&#125;</span> €'</span>),</span><br><span class="line">        ),</span><br><span class="line">        child: Container(</span><br><span class="line">          color: widget.shoppingItem.color,</span><br><span class="line">          child: Center(</span><br><span class="line">            child: _buildButton(),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="它是如何工作的？"><a href="#它是如何工作的？" class="headerlink" title="它是如何工作的？"></a>它是如何工作的？</h3><p>下图显示了所有部分是如何协同工作。</p><p><img src="https://www.didierboelens.com/images/bloc_part_of.png" alt></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>又是一篇长章，我希望我将其变得简略一点，但我一些解释是必要的。</p><p>正如我在介绍中所说，我个人在我的开发中经常使用这些“模式”。这让我节省了大量的时间和精力;我的代码更易读，更容易调试。</p><p>此外，它有助于将业务与视图分离。</p><p>大概率肯定有其他方法可以做到这一点，甚至做得更好。但它对我有用的，这就是我想与你分享的一切。</p><p>请继续关注新文章，同时祝你编程愉快。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
            <tag> BLoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译) Flutter中的响应式编程(Reactive Programming)、流(Streams)以及业务逻辑组件(BloC)</title>
      <link href="/2019/04/13/Flutter/development/data-and-backend/state-mgmt/options/BloC/ReactiveProgramming-Streams-BLoC/"/>
      <url>/2019/04/13/Flutter/development/data-and-backend/state-mgmt/options/BloC/ReactiveProgramming-Streams-BLoC/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/" target="_blank" rel="noopener">原文链接</a></p><p>本文以理论结合实例的方式介绍了流(Streams)，业务逻辑组件(BloC)以及响应式编程(Reactive Programming)这些概念的介绍。</p><p>难度：中级</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我花费很长时间才找到介绍响应式编程(Reactive Programming)，业务逻辑组件(BloC)和流(Streams)这些概念的方法。</p><p>因为这些概念是能使得应用架构的方法产生巨大改变的，所以我想要用一个实例来展示这一点：</p><ul><li>不是一定要使用它们，但有时不使用的代价可能是代码编写难度更大和性能更低，</li><li>使用它们的好处，以及</li><li>使用它们造成的影响(正面的以及负面的)</li></ul><p>我写的这个实用性的例子是一个伪应用，简而言之，它允许用户从一个在线目录查看电影列表，对电影按类型和发布日期进行过滤，对电影进行收藏和取消收藏。当然，一切都是交互式的，用户动作可以在不同的页面中或在同一个页面内发生，并对界面进行实时刷新。</p><p>这是一个显示此应用程序的动画。</p><p><img src="https://www.didierboelens.com/images/streams_app_1.gif" alt></p><p>既然你来看这篇文章，想要获取有关响应式编程(Reactive Programming)，业务逻辑组件(BloC)和流(Streams)的信息，我将先对它们进行一一介绍。随后，再向你展示如何在实践中实现和使用它们。</p><p>本文的补充文章中给出一些实例，可以点击<a href="/2019/04/13/Flutter/development/data-and-backend/state-mgmt/options/BloC/ReactiveProgramming-Streams-BLoC-PracticalUseCases/">此链接</a>找到。</p><hr><h2 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>为了轻松可视化流(Stream)的概念，可以简单地把它当成两头都通的水管，只允许从一头插入一些东西。当你将一些东西插入水管中时，它会在水管内流动，并从另一头流出。</p><p>在 Flutter 中，</p><ul><li>管道被称为 <a href="https://api.dartlang.org/stable/2.0.0/dart-async/Stream-class.html" target="_blank" rel="noopener">Stream</a></li><li>为了控制 Stream，我们通常(*)使用 <a href="https://api.dartlang.org/stable/2.0.0/dart-async/StreamController-class.html" target="_blank" rel="noopener">StreamController</a></li><li>为了插入一些东西到 Stream 中去，StreamController 暴露了一个叫做 StreamSink的入口，可以通过 <strong>sink</strong> 属性访问</li><li>StreamController 通过 <strong>stream</strong> 属性暴露了从 Stream 中出来的方式</li></ul><p>（*）：我特意使用“通常”这个词，是因为很可能不使用任何 StreamController。但是，在本文中我将只使用 StreamController。</p><h3 id="什么能被流运送？"><a href="#什么能被流运送？" class="headerlink" title="什么能被流运送？"></a>什么能被流运送？</h3><p>一切都能被运送。从值，事件，对象，集合，映射，错误或甚至另一个流，任何类型的数据都能被流运送。</p><h3 id="我怎么知道东西是被流运送的？"><a href="#我怎么知道东西是被流运送的？" class="headerlink" title="我怎么知道东西是被流运送的？"></a>我怎么知道东西是被流运送的？</h3><p>当你需要在东西被运送的时候接收到通知，你只需要<strong>监听</strong> StreamController 的stream 属性。</p><p>每当你定义一个监听器，你就会收到一个 <a href="https://api.dartlang.org/stable/2.0.0/dart-async/StreamSubscription-class.html" target="_blank" rel="noopener">StreamSubscription</a> 对象。正是通过 StreamSubscription 对象，你才会在 Stream 级别收到某些事情发生的通知。</p><p>只要有一个监听器处于<strong>活跃</strong>状态，Stream 就会开始生成<strong>事件</strong>，以便在下列情况下每次都通知活跃的 StreamSubscription 对象们。</p><ul><li>一些数据从流中出来了</li><li>当一些错误被发送到流时，</li><li>当流关闭时。</li></ul><p>StreamSubscription 对象同样也允许你：</p><ul><li>停止监听</li><li>暂停，</li><li>恢复</li></ul><h3 id="流只是一条简单的水管吗？"><a href="#流只是一条简单的水管吗？" class="headerlink" title="流只是一条简单的水管吗？"></a>流只是一条简单的水管吗？</h3><p>不，Stream 还允许数据在流出之前，Stream 对其进行处理。</p><p>为了控制 Stream 内部数据的处理，我们使用 <a href="https://api.dartlang.org/stable/2.0.0/dart-async/StreamTransformer-class.html" target="_blank" rel="noopener">StreamTransformer</a>，它只是</p><ul><li>一个“捕获” Stream 内部流动数据的方法</li><li>对数据做了一些事情</li><li>这种转换的结果也是一个 Stream</li></ul><p>你能直接从该声明中了解到，可以按顺序使用多个 StreamTransformer`。</p><p><code>StreamTransformer</code>可被用于进行任何类型的处理，例如：</p><ul><li>过滤：根据任何类型的条件过滤数据，</li><li>重新组合：重新组合数据，</li><li>修改：对数据应用任何类型的修改，</li><li>将数据注入其他流，</li><li>缓冲，</li><li>处理：基于数据进行任意类型的操作</li><li>…</li></ul><h2 id="流的类型"><a href="#流的类型" class="headerlink" title="流的类型"></a>流的类型</h2><p>存在两种类型的流。</p><h3 id="单订阅流"><a href="#单订阅流" class="headerlink" title="单订阅流"></a>单订阅流</h3><p>这种类型的流只允许在该流的整个生命周期内使用单个监听器。</p><p>即使在第一个订阅被取消后，也无法在此类流上监听两次。</p><h3 id="广播流"><a href="#广播流" class="headerlink" title="广播流"></a>广播流</h3><p>第二种类型的流允许任意数量的监听器。</p><p>可以随时向广播流添加监听器。新的监听器将在它开始监听流时收到事件。</p><h2 id="基础的例子"><a href="#基础的例子" class="headerlink" title="基础的例子"></a>基础的例子</h2><h3 id="任何类型的数据"><a href="#任何类型的数据" class="headerlink" title="任何类型的数据"></a>任何类型的数据</h3><p>第一个示例展示了“单订阅”流，它只是打印输入的数据。正如你所见的，数据的类型是无关紧要的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Initialize a "Single-Subscription" Stream controller</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">final</span> StreamController ctrl = StreamController();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Initialize a single listener which simply prints the data</span></span><br><span class="line">  <span class="comment">// as soon as it receives it</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">final</span> StreamSubscription subscription = ctrl.stream.listen((data) =&gt; <span class="built_in">print</span>(<span class="string">'<span class="subst">$data</span>'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We here add the data that will flow inside the stream</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  ctrl.sink.add(<span class="string">'my name'</span>);</span><br><span class="line">  ctrl.sink.add(<span class="number">1234</span>);</span><br><span class="line">  ctrl.sink.add(&#123;<span class="string">'a'</span>: <span class="string">'element A'</span>, <span class="string">'b'</span>: <span class="string">'element B'</span>&#125;);</span><br><span class="line">  ctrl.sink.add(<span class="number">123.45</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We release the StreamController</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  ctrl.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StreamTransformer"><a href="#StreamTransformer" class="headerlink" title="StreamTransformer"></a>StreamTransformer</h3><p>第二个示例显示“广播”流，它传达整数值并仅打印偶数。为此，我们应用StreamTransformer来过滤（第14行）值，只让偶数通过。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Initialize a "Broadcast" Stream controller of integers</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">final</span> StreamController&lt;<span class="built_in">int</span>&gt; ctrl = StreamController&lt;<span class="built_in">int</span>&gt;.broadcast();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Initialize a single listener which filters out the odd numbers and</span></span><br><span class="line">  <span class="comment">// only prints the even numbers</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">final</span> StreamSubscription subscription = ctrl.stream</span><br><span class="line">      .where((value) =&gt; (value % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line">      .listen((value) =&gt; <span class="built_in">print</span>(<span class="string">'<span class="subst">$value</span>'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We here add the data that will flow inside the stream</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;<span class="number">11</span>; i++)&#123;</span><br><span class="line">  ctrl.sink.add(i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We release the StreamController</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  ctrl.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RxDart"><a href="#RxDart" class="headerlink" title="RxDart"></a>RxDart</h2><p>如今，如果我不提及 <a href="https://pub.dartlang.org/packages/rxdart" target="_blank" rel="noopener">RxDart包</a>，那么有关流的介绍就不会完整。</p><p><strong>RxDart</strong> 包是 <a href="http://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a> API的 Dart 实现，它扩展了原始的 Dart 流 API 以使其符合 ReactiveX 标准。</p><p>由于它最初并未由 Google 定义，因此它使用不同的词汇。下表给出了 Dart 和 RxDart 之间的相关性。</p><table><thead><tr><th>Dart</th><th>RxDart</th></tr></thead><tbody><tr><td>Stream</td><td>Observable</td></tr><tr><td>StreamController</td><td>Subject</td></tr></tbody></table><p>正如我刚才所说，RxDart 扩展了原始的 Dart Streams API 并提供了StreamController 的三个主要变体：</p><h3 id="PublishSubject"><a href="#PublishSubject" class="headerlink" title="PublishSubject"></a>PublishSubject</h3><p><a href="https://pub.dartlang.org/documentation/rxdart/latest/rx/PublishSubject-class.html" target="_blank" rel="noopener">PublishSubject</a>是一个标准的 <strong>广播</strong> StreamController,只有一点除外，流返回的是一个 <a href="https://pub.dartlang.org/documentation/rxdart/latest/rx/Observable-class.html" target="_blank" rel="noopener">Observable</a> 而不是一个 Stream。</p><p><img src="https://www.didierboelens.com/images/S.PublishSubject.png" alt></p><p>正如你所看到的，<code>PublishSubject</code>只向监听器发送在订阅之后被添加到流中的事件。</p><h3 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h3><p><a href="https://pub.dartlang.org/documentation/rxdart/latest/rx/BehaviorSubject-class.html" target="_blank" rel="noopener">BehaviorSubject</a> 也是一个<strong>广播</strong> <code>StreamController</code>，它返回一个 <strong>Observable</strong> 而不是一个 <strong>Stream</strong>。</p><p><img src="https://www.didierboelens.com/images/S.BehaviorSubject.png" alt></p><p>与 PublishSubject 的主要区别在于 BehaviorSubject 还将订阅前最后发送的事件发送给刚刚订阅的监听器。</p><h3 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h3><p><a href="https://pub.dartlang.org/documentation/rxdart/latest/rx/ReplaySubject-class.html" target="_blank" rel="noopener">ReplaySubject</a> 也是一个 <strong>广播</strong> StreamController，它返回一个 <strong>Observable</strong> 而不是一个 <strong>Stream</strong>。</p><p><img src="https://www.didierboelens.com/images/S.ReplaySubject.png" alt></p><p><strong>默认情况下</strong>，ReplaySubject 将 Stream 已经发出的所有事件作为最先的事件发送到所有新订阅的监听器。</p><hr><h3 id="关于资源的重要说明"><a href="#关于资源的重要说明" class="headerlink" title="关于资源的重要说明"></a>关于资源的重要说明</h3><blockquote><p>总是释放不再需要的资源是一种非常好的习惯。</p></blockquote><p>这句话适用于：</p><ul><li>StreamSubscription - 当你不再需要监听流的时候，取消订阅</li><li>StreamController - 当你不再需要一个 StreamController 的时候，关闭它。</li><li>同样也适用于 RxDart 这个主体，当你不再需要 BehaviourSubject，PublishSubject 的时候，关闭它。</li></ul><hr><h3 id="如何基于从-Stream-出来的数据构建一个-Widget？"><a href="#如何基于从-Stream-出来的数据构建一个-Widget？" class="headerlink" title="如何基于从 Stream 出来的数据构建一个 Widget？"></a>如何基于从 Stream 出来的数据构建一个 Widget？</h3><p>Flutter 提供了一个十分方便的 StatefulWidget，被称为 <a href="https://docs.flutter.io/flutter/widgets/StreamBuilder-class.html" target="_blank" rel="noopener">StreamBuilder</a>。</p><p>StreamBuilder 监听着一个 Stream ，每当一些数据流出 Stream 时，它会调用其builder 回调自动重建。</p><p>这是如何使用 StreamBuilder 的方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StreamBuilder&lt;T&gt;(</span><br><span class="line">    key: ...optional, the unique ID of <span class="keyword">this</span> Widget...</span><br><span class="line">    stream: ...the stream to listen to...</span><br><span class="line">    initialData: ...any initial data, <span class="keyword">in</span> <span class="keyword">case</span> the stream would initially be empty...</span><br><span class="line">    builder: (BuildContext context, AsyncSnapshot&lt;T&gt; snapshot)&#123;</span><br><span class="line">        <span class="keyword">if</span> (snapshot.hasData)&#123;</span><br><span class="line">            <span class="keyword">return</span> ...the Widget to be built based on snapshot.data</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ...the Widget to be built <span class="keyword">if</span> no data <span class="keyword">is</span> available</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>以下示例模仿默认的“计数器”应用程序，但使用的是 Stream 而不再使用任何 setState 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterPageState createState() =&gt; _CounterPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> StreamController&lt;<span class="built_in">int</span>&gt; _streamController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _streamController.close();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Stream version of the Counter App'</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">          stream: _streamController.stream,</span><br><span class="line">          initialData: _counter,</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot)&#123;</span><br><span class="line">            <span class="keyword">return</span> Text(<span class="string">'You hit me: <span class="subst">$&#123;snapshot.data&#125;</span> times'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">          _streamController.sink.add(++_counter);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释说明：</p><ul><li>第24-30行：我们正在监听流，每次有一个新值流出这个流时，我们用该值更新文本;</li><li>第35行：当我们点击 FloatingActionButton 时，我们递增计数器并通过接收器将其发送到 Stream ;在流中注入值的事实导致侦听它的 StreamBuilder 重建并“刷新”计数器;</li><li>我们不再需要状态的概念，所有东西都通过 Stream 接收;</li><li>这是一个很大的改进，因为调用 setState() 方法会强制整个 Widget（和任何子widget）重建。在这里，只重建 StreamBuilder (当然还有子widget);</li><li>我们仍然在为页面使用 StatefulWidget 的唯一原因，仅仅是因为我们需要通过 dispose 方法在第15行释放 StreamController;</li></ul><hr><h2 id="什么是响应式编程"><a href="#什么是响应式编程" class="headerlink" title="什么是响应式编程"></a>什么是响应式编程</h2><p><strong>响应式编程是使用异步数据流进行编程</strong>。换句话说，所有东西都来源于一个事件(例如点击事件)，变量、消息的变化，要求构建的请求，所有这些经由数据流触发，可能改变或发生的事情都会被传送。</p><p>很明显，所有这些意味着，通过响应式编程，应用程序：</p><ul><li>变得<strong>异步</strong>了</li><li>围绕<strong>流</strong>和<strong>监听者</strong>的概念进行架构，</li><li>当某事发生在某处(事件，变量的变化……)时，会向 Stream 发送通知，</li><li>如果“某人”监听该流，无论其在应用程序中的位置如何，它将被通知并将采取适当的行动。</li></ul><blockquote><p>组件之间不再存在紧密耦合</p></blockquote><p>简而言之，当 Widget 向 Stream 发送内容时，该 Widget <strong>不再需要知道</strong>：</p><ul><li>接下来会发生什么，</li><li>谁可能使用这些信息（没有一个，一个或几个widget…）</li><li>可能使用此信息的地方（没有地方，同一页面，另一个页面，几个页面…），</li><li>当这些信息可能被使用时（几乎是直接，几秒钟之后，永远不会……）。</li></ul><blockquote><p>…… Widget 只关心自己的业务，仅此而已。</p></blockquote><p>乍一看，这似乎会导致应用程序变得“无法控制”，但正如我们将看到的，情况正好相反。它给予你：</p><ul><li>构建仅负责特定活动的部分应用程序的机会，</li><li>轻松模拟一些组件的行为，以允许更完整的测试覆盖，</li><li>轻松重用组件（应用程序或其他应用程序中的其他位置），</li><li>重新设计应用程序，并能够在不进行太多重构的情况下将组件从一个地方移动到另一个地方，<br>…</li></ul><p>我们将很快看到优势……但在之前，我需要介绍最后一个主题：BLoC 模式。</p><hr><h2 id="BLoC模式"><a href="#BLoC模式" class="headerlink" title="BLoC模式"></a>BLoC模式</h2><p>BLoC 模式由来自谷歌的 Paolo Soares 和 Cong Hui 设计，并在 2018 年 DartConf 期间（2018年1月23日至24日）首次提出。<a href="https://www.youtube.com/watch?v=PLHln7wHgPE" target="_blank" rel="noopener">观看YouTube上的视频</a>。</p><p>简而言之，业务逻辑需要：</p><ul><li>需要迁移到一个或多个的BloC</li><li>尽可能从表示层中删除业务逻辑。换句话说，UI 组件应该只关心 UI 的东西而不关心业务，</li><li>依靠将输入(Sink)和输出(stream)作为唯一操作 Stream 的方式</li><li>保持平台独立性</li><li>保持环境独立性</li></ul><p>事实上，BLoC 模式最初构思是为了允许重用独立于平台（ Web 应用程序，移动应用程序，后端。<br>）的相同的代码。</p><h3 id="它究竟意味着什么？"><a href="#它究竟意味着什么？" class="headerlink" title="它究竟意味着什么？"></a>它究竟意味着什么？</h3><p>BLoC 模式利用了我们刚才讨论过的概念：Streams。</p><p><img src="https://www.didierboelens.com/images/streams_bloc.png" alt></p><ul><li>Widget通过 sinks 向 BloC 发送事件</li><li>Widget通过 stream 被 BloC 通知的,</li><li>由 BLoc 实现的业务逻辑，Widget 丝毫都不关心</li></ul><p>从这个声明中，我们可以直接看到一个巨大的好处。</p><p>正是因为业务逻辑跟 UI 解耦了</p><ul><li>我们可以随时更改业务逻辑，并且其对应用程序的影响最小，</li><li>我们可以更改 UI，同时不会对业务逻辑产生任何影响，</li><li>现在，测试业务逻辑变得更加容易</li></ul><hr><h2 id="如何把这个-Bloc-模式应用到计数器应用这个例子上？"><a href="#如何把这个-Bloc-模式应用到计数器应用这个例子上？" class="headerlink" title="如何把这个 Bloc 模式应用到计数器应用这个例子上？"></a>如何把这个 Bloc 模式应用到计数器应用这个例子上？</h2><p>将 BLoC 模式应用于此计数器应用程序似乎有点杀鸡用牛刀，但让我先展示给你看吧……</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">        title: <span class="string">'Streams Demo'</span>,</span><br><span class="line">        theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">          primarySwatch: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">          bloc: IncrementBloc(),</span><br><span class="line">          child: CounterPage(),</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Stream version of the Counter App'</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">          stream: bloc.outCounter,</span><br><span class="line">          initialData: <span class="number">0</span>,</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot)&#123;</span><br><span class="line">            <span class="keyword">return</span> Text(<span class="string">'You hit me: <span class="subst">$&#123;snapshot.data&#125;</span> times'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">          bloc.incrementCounter.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementBloc</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Stream to handle the counter</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; _counterController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">  StreamSink&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> _inAdd =&gt; _counterController.sink;</span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> outCounter =&gt; _counterController.stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Stream to handle the action on the counter</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController _actionController = StreamController();</span><br><span class="line">  StreamSink <span class="keyword">get</span> incrementCounter =&gt; _actionController.sink;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  IncrementBloc()&#123;</span><br><span class="line">    _counter = <span class="number">0</span>;</span><br><span class="line">    _actionController.stream</span><br><span class="line">                     .listen(_handleLogic);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _actionController.close();</span><br><span class="line">    _counterController.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleLogic(data)&#123;</span><br><span class="line">    _counter = _counter + <span class="number">1</span>;</span><br><span class="line">    _inAdd.add(_counter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我已经听到你说，“为什么这么做，有必要吗”？</p><h3 id="首先，职责分离"><a href="#首先，职责分离" class="headerlink" title="首先，职责分离"></a>首先，职责分离</h3><p>如果你检查 CounterPage（第21-45行），其中绝对没有任何业务逻辑。</p><p>此页面现在仅负责：</p><ul><li>显示计数器，现在只在必要的时候刷新（甚至没有页面需要知道它）</li><li>提供按钮，当按钮按下时，请求一个动作能在 couter 上执行。</li></ul><p>此外，整个业务逻辑集中在一个单个类 “IncrementBloc” 中。</p><p>如果现在，你需要更改业务逻辑，你只需更新方法 _handleLogic（第77-80行）。 也许新的业务逻辑将要求做非常复杂的事情…… Counter 页面永远不会知道，这是非常好的！</p><h3 id="第二，可测试性"><a href="#第二，可测试性" class="headerlink" title="第二，可测试性"></a>第二，可测试性</h3><p>现在，测试业务逻辑变得更加容易了。</p><p>无需再通过用户界面测试业务逻辑。 只需要测试 IncrementBloc 类。</p><h3 id="第三，自由组织布局"><a href="#第三，自由组织布局" class="headerlink" title="第三，自由组织布局"></a>第三，自由组织布局</h3><p>由于使用了 Streams，你现在可以独立于业务逻辑组织布局。</p><p>可以从应用程序中的任何位置启动任何操作：只需调用.incrementCounter sink 即可。</p><p>你可以在任何页面的任何位置显示计数器，只需监听 .outCounter stream 。</p><h3 id="第四，减少-“build”-的数量"><a href="#第四，减少-“build”-的数量" class="headerlink" title="第四，减少 “build” 的数量"></a>第四，减少 “build” 的数量</h3><p>不使用 setState() 而是使用 StreamBuilder ，大大减少了需要使用 “build” 的数量。</p><p>从性能角度来看，这是一个巨大的提升。</p><hr><h3 id="有一个约束…-BLoC-的访问性"><a href="#有一个约束…-BLoC-的访问性" class="headerlink" title="有一个约束… BLoC 的访问性"></a>有一个约束… BLoC 的访问性</h3><p>为了使所有这些能够工作，BLoC 需要能够被访问。</p><p>有几种方法可以访问它：</p><ul><li>通过全局单例</li></ul><p>这种方式十分可行，但不是特别推荐。 此外，由于 Dart 中没有类析构函数，因此你永远无法正确释放资源。</p><ul><li>作为局部实例</li></ul><p>您可以实例化 BLoC 的局部实例。 在某些情况下，此解决方案完全满足某些需求。 在这种情况下，你应该始终考虑在 StatefulWidget 中初始化，以便你可以利用 dispose() 方法来释放它。</p><ul><li>由祖先提供</li></ul><p>使其可访问的最常见方式是通过<strong>祖先</strong> Widget，以 StatefulWidget 的方式实现。</p><p>以下代码展示了泛型 BlocProvider 的示例。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generic Interface for all BLoCs</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic BLoC provider</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BlocBase</span>&gt; <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  BlocProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.bloc,</span><br><span class="line">  &#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> T bloc;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> T of&lt;T <span class="keyword">extends</span> BlocBase&gt;(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;();</span><br><span class="line">    BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type);</span><br><span class="line">    <span class="keyword">return</span> provider.bloc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocProviderState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BlocProvider</span>&lt;<span class="title">BlocBase</span>&gt;&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    widget.bloc.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> widget.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于这个泛型-BlocProvider-的一些解释"><a href="#关于这个泛型-BlocProvider-的一些解释" class="headerlink" title="关于这个泛型 BlocProvider 的一些解释"></a>关于这个泛型 BlocProvider 的一些解释</h3><p>首先，如何将其用作提供者？</p><p>如果你查看示例代码“streams_4.dart”，您将看到以下代码行（第12-15行）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">          bloc: IncrementBloc(),</span><br><span class="line">          child: CounterPage(),</span><br><span class="line">        ),</span><br></pre></td></tr></table></figure><p>有了这几行代码，我们很简单地实例化一个新的 BlocProvider，它将处理一个IncrementBloc，并将 CounterPage 作为子项渲染出来。</p><p>从那一刻开始，从 BlocProvider 开始的子树的任何小部件部分都将能够通过以下行访问IncrementBloc：</p><h3 id="我们能有多个BLoc吗？"><a href="#我们能有多个BLoc吗？" class="headerlink" title="我们能有多个BLoc吗？"></a>我们能有多个BLoc吗？</h3><p>当然，这是非常可取的。 建议是：</p><ul><li>(如果有任何业务逻辑)每页顶部有一个BLoC，</li><li>为什么不是 ApplicationBloc 来处理应用程序状态？</li><li>每个“足够复杂的组件”都有相应的BLoC。</li></ul><p>以下示例代码在整个应用程序的顶部显示 ApplicationBloc ，然后在CounterPage顶部显示 IncrementBloc。</p><p>该示例还展示了如何获取两个 BloC。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(</span><br><span class="line">  BlocProvider&lt;ApplicationBloc&gt;(</span><br><span class="line">    bloc: ApplicationBloc(),</span><br><span class="line">    child: MyApp(),</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Streams Demo'</span>,</span><br><span class="line">      home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">        bloc: IncrementBloc(),</span><br><span class="line">        child: CounterPage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> IncrementBloc counterBloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line">    <span class="keyword">final</span> ApplicationBloc appBloc = BlocProvider.of&lt;ApplicationBloc&gt;(context);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么不使用-InhertitedWidget"><a href="#为什么不使用-InhertitedWidget" class="headerlink" title="为什么不使用 InhertitedWidget"></a>为什么不使用 InhertitedWidget</h3><p>在大多数与 BLoC 相关的文章中，你将看到 Provider 作为 InheritedWidget 的实现。</p><p>当然，没有什么能阻止这种类型的实现。 然而，</p><ul><li>一个 InheritedWidget 没有提供任何 dispose 方法，记住，在不再需要资源时总是释放资源是一个很好的做法。</li><li>当然，没有什么能阻止你将 InheritedWidget 包装在另一个StatefulWidget中，但是，使用 InheritedWidget 增加了什么呢？</li><li>最后，如果不受控制，使用 InheritedWidget 经常会导致副作用（请参阅下面的InheritedWidget 上的提醒）。</li></ul><p>这三点解释了我为什么将泛型 BlocProvider 实现为 StatefulWidget 作为我的选择，这样我就可以在处理这个 widget 时释放资源。</p><blockquote><p><strong>Flutter 无法实例化泛型类型</strong></p></blockquote><blockquote><p>不幸的是，Flutter 无法实例化泛型类型，我们必须将 BLoC 的实例传递给BlocProvider。为了在每个 BLoC 中强制执行 dispose() 方法，所有 BLoC 都必须实现BlocBase 接口。</p></blockquote><h4 id="关于-InhertitedWidget-的提醒"><a href="#关于-InhertitedWidget-的提醒" class="headerlink" title="关于 InhertitedWidget 的提醒"></a>关于 InhertitedWidget 的提醒</h4><p>在使用 InheritedWidget 并通过 context.inheritFromWidgetOfExactType(…)获取指定类型最近的 Widget 时，每当 InheritedWidget 的父级或者子布局发生变化时，这个方法会自动将当前“context”（= BuildContext）注册到要重建的widget当中。</p><blockquote><p>请注意，为了完全正确，我刚才解释的与 InheritedWidget 相关的问题只发生在我们将InheritedWidget 与 StatefulWidget 结合使用时。 当你只使用没有 State 的InheritedWidget 时，问题就不会发生。 但是……我将在下一篇文章中回到这句话。</p></blockquote><blockquote><p>链接到 BuildContext 的 Widget 类型（Stateful或Stateless）是无关紧要的。</p></blockquote><h2 id="个人关于-BLoC-的看法"><a href="#个人关于-BLoC-的看法" class="headerlink" title="个人关于 BLoC 的看法"></a>个人关于 BLoC 的看法</h2><p>与 BLoC 相关的第三条规则是：“依靠输入(Sink)和输出(stream)作为唯一操作 Stream 的方式”。</p><p>我的个人经历与这句话有点相左……让我解释一下。</p><p>首先，BLoC 模式被设想成为跨平台共享相同的代码（AngularDart，…），并且从这个角度来看，该这句话非常有意义。</p><p>但是，如果您只打算开发一个 Flutter 应用程序，基于我粗浅的经验，这有用力过猛了。</p><p>如果我们坚持按这句话说的做，那么就没有 getter 或 setter方法了，只有 sinks 和streams。缺点就是，所有这些都是异步的。</p><p>让我们来举两个例子来说明缺点：</p><ul><li>你需要从 BLoC 中获取一些数据，然后作为一个页面的输入，就应该直接在页面上展示这些参数（例如，想象一个参数页面），如果我们必须依赖 Streams，这会使页面的构建变成异步的，这是复杂的。通过Streams使其工作的示例代码可能如下所示……是不是很丑。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiltersPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  FiltersPageState createState() =&gt; FiltersPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiltersPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FiltersPage</span>&gt; </span>&#123;</span><br><span class="line">  MovieCatalogBloc _movieBloc;</span><br><span class="line">  <span class="built_in">double</span> _minReleaseDate;</span><br><span class="line">  <span class="built_in">double</span> _maxReleaseDate;</span><br><span class="line">  MovieGenre _movieGenre;</span><br><span class="line">  <span class="built_in">bool</span> _isInit = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// As the context of not yet available at initState() level,</span></span><br><span class="line">    <span class="comment">// if not yet initialized, we get the list of the </span></span><br><span class="line">    <span class="comment">// filter parameters</span></span><br><span class="line">    <span class="keyword">if</span> (_isInit == <span class="keyword">false</span>)&#123;</span><br><span class="line">      _movieBloc = BlocProvider.of&lt;MovieCatalogBloc&gt;(context);</span><br><span class="line">      _getFilterParameters();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> _isInit == <span class="keyword">false</span></span><br><span class="line">      ? Container()</span><br><span class="line">      : Scaffold(</span><br><span class="line">    ...</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Very tricky.</span></span><br><span class="line">  <span class="comment">/// </span></span><br><span class="line">  <span class="comment">/// As we want to be 100% BLoC compliant, we need to retrieve</span></span><br><span class="line">  <span class="comment">/// everything from the BLoCs, using Streams...</span></span><br><span class="line">  <span class="comment">/// </span></span><br><span class="line">  <span class="comment">/// This is ugly but to be considered as a study case.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="keyword">void</span> _getFilterParameters() &#123;</span><br><span class="line">    StreamSubscription subscriptionFilters;</span><br><span class="line"></span><br><span class="line">    subscriptionFilters = _movieBloc.outFilters.listen((MovieFilters filters) &#123;</span><br><span class="line">        _minReleaseDate = filters.minReleaseDate.toDouble();</span><br><span class="line">        _maxReleaseDate = filters.maxReleaseDate.toDouble();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Simply to make sure the subscriptions are released</span></span><br><span class="line">        subscriptionFilters.cancel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Now that we have all parameters, we may build the actual page</span></span><br><span class="line">        <span class="keyword">if</span> (mounted)&#123;</span><br><span class="line">          setState(()&#123;</span><br><span class="line">            _isInit = <span class="keyword">true</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 BLoC 级别，你还需要转换某些数据的“假”注入，以触发提供你希望通过流接收的数据。 使这项工作的示例代码可以是：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationBloc</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Synchronous Stream to handle the provision of the movie genres</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  StreamController&lt;<span class="built_in">List</span>&lt;MovieGenre&gt;&gt; _syncController = StreamController&lt;<span class="built_in">List</span>&lt;MovieGenre&gt;&gt;.broadcast();</span><br><span class="line">  Stream&lt;<span class="built_in">List</span>&lt;MovieGenre&gt;&gt; <span class="keyword">get</span> outMovieGenres =&gt; _syncController.stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Stream to handle a fake command to trigger the provision of the list of MovieGenres via a Stream</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  StreamController&lt;<span class="built_in">List</span>&lt;MovieGenre&gt;&gt; _cmdController = StreamController&lt;<span class="built_in">List</span>&lt;MovieGenre&gt;&gt;.broadcast();</span><br><span class="line">  StreamSink <span class="keyword">get</span> getMovieGenres =&gt; _cmdController.sink;</span><br><span class="line"></span><br><span class="line">  ApplicationBloc() &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If we receive any data via this sink, we simply provide the list of MovieGenre to the output stream</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    _cmdController.stream.listen((_)&#123;</span><br><span class="line">      _syncController.sink.add(UnmodifiableListView&lt;MovieGenre&gt;(_genresList.genres));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _syncController.close();</span><br><span class="line">    _cmdController.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MovieGenresList _genresList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example of external call</span></span><br></pre></td></tr></table></figure><p>我不知道你的看法是怎么样的，但就个人而言，如果我没有任何与代码移植/共享相关的限制，我发现这太重了以至于我宁愿在需要时使用常规的 getter/setter并使用 Streams/Sinks来保持分离责任并在需要的地方广播信息。</p><h2 id="是时候在实战中来看所有这些了…"><a href="#是时候在实战中来看所有这些了…" class="headerlink" title="是时候在实战中来看所有这些了…"></a>是时候在实战中来看所有这些了…</h2><p>正如本文开头所提到的，我构建了一个伪应用程序来展示如何使用所有这些概念。 完整的源代码可以在 <a href="https://github.com/boeledi/Streams-Block-Reactive-Programming-in-Flutter" target="_blank" rel="noopener">Github</a> 上找到。</p><p>请宽容，因为这段代码距离完美有很大的距离，它有进步的空间又或是采用更好的架构，但在这里的唯一目的是，向你展示所有这些事如何工作的。</p><p>由于源代码注释已经很多，我只会解释主要原则。</p><h3 id="电影目录的来源"><a href="#电影目录的来源" class="headerlink" title="电影目录的来源"></a>电影目录的来源</h3><p>我正在使用免费的 TMDB API 来获取所有电影的列表，以及海报，评分和描述。</p><p>为了能够运行此示例应用程序，您需要注册并获取API密钥（完全免费），然后将您的API密钥放在文件“/api/tmdb_api.dart”第15行。</p><h3 id="应该程序的架构"><a href="#应该程序的架构" class="headerlink" title="应该程序的架构"></a>应该程序的架构</h3><p>该应用程序使用：</p><ul><li><p>3个主要的BLoC：</p><ul><li>ApplicationBloc（在所有顶部），负责提供所有电影类型的列表;</li><li>FavoriteBloc（就在ApplicationBloc下面），负责处理“收藏夹”的概念;</li><li>MovieCatalogBloc（在2个主要页面之上），负责基于过滤器提供电影列表;</li></ul></li><li><p>6个页面：</p><ul><li>主页面：登陆页面，允许导航到3个子页面;</li><li>ListPage：将电影列为GridView的页面，允许过滤，收藏夹选择，访问收藏夹以及在后续页面中显示电影详细信息;</li><li>ListOnePage：类似于ListPage，但电影列表显示为水平列表，下面是详细信息;</li><li>收藏页面：列出收藏夹的页面，允许取消选择任何收藏夹;</li><li>过滤器页面：允许定义过滤器的EndDrawer：流派和最小/最大发布日期。从ListPage或* ListOnePage调用此页面;</li><li>详细信息页面：页面仅由ListPage调用以显示电影的详细信息，但也允许选择/取消选择电影作为收藏;</li></ul></li><li><p>1个子BLoC：</p><ul><li>FavoriteMovieBloc，链接到MovieCardWidget或MovieDetailsWidget以处理作为收藏的电影的选择/取消选择</li></ul></li><li><p>5个主要小部件：</p><ul><li>FavoriteButton：负责显示收藏夹的数量wiget，实时，并在按下时重定向到FavoritesPage;</li><li>FavoriteWidget：负责显示一个喜欢的电影的细节的widget，并允许其取消选择;</li><li>FiltersSummary：负责显示当前定义的过滤器的widget;</li><li>MovieCardWidget: 负责将一部电影显示为卡片，电影海报，评级和名称，以及一个图标，表示选择该特定电影作为收藏的widget;</li><li>MovieDetailsWidget：负责显示与特定电影相关的详细信息，并允许其选择/取消选择作为收藏的widget。</li></ul></li></ul><h3 id="不同BLoc-流的和谐结合"><a href="#不同BLoc-流的和谐结合" class="headerlink" title="不同BLoc/流的和谐结合"></a>不同BLoc/流的和谐结合</h3><p>下图显示了如何使用主要的3个 BLoC：</p><ul><li>在 BLoC 的左侧，哪些组件调用 Sink</li><li>在右侧，哪些组件监听流</li></ul><p>例如，当 MovieDetailsWidget 调用 inAddFavorite Sink 时，会触发2个流：</p><ul><li>outTotalFavorites 流强制重建 FavoriteButton，和</li><li>outFavorites 流<ul><li>强制重建 MovieDetailsWidget（“最喜欢的”图标）</li><li>强制重建 _buildMovieCard（“最喜欢的”图标）</li><li>用于构建每个 MovieDetailsWidget<br><img src="https://www.didierboelens.com/images/streams_flows.png" alt> </li></ul></li></ul><h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>大多数小部件和页面都是 StatelessWidgets，这意味着：</p><ul><li>强制重建的 setState()几乎从未使用过。 例外情况是：<ul><li>当 ListOnePage 用户点击 MovieCard 时，刷新 MovieDetailsWidget。 这也可能是由一个流驱动的……</li><li>在 FiltersPage 中允许用户在接受过滤器之前通过 Sink 更改过滤器。<br>应用程序不使用任何 InheritedWidget</li><li>应用程序几乎是 100％ BLoC/Stream 驱动，这意味着大多数小部件彼此独立，并且它们在应用程序中的位置</li></ul></li></ul><p>一个实际的例子是 FavoriteButton，它显示徽章中所选收藏夹的数量。 该应用程序计算此FavoriteButton 的3个实例，每个实例显示在3个不同的页面中。</p><h3 id="显示电影列表（显示无限列表的技巧说明）"><a href="#显示电影列表（显示无限列表的技巧说明）" class="headerlink" title="显示电影列表（显示无限列表的技巧说明）"></a>显示电影列表（显示无限列表的技巧说明）</h3><p>要显示符合过滤条件的电影列表，我们使用 GridView.builder(ListPage)或ListView.builder(ListOnePage）作为无限滚动列表。</p><p>使用 TMDB API 一次以20个电影的页面提取电影。</p><p>提醒一下，GridView.builder 和 ListView.builder 都将 itemCount 作为输入，如果提供，则表示要显示的项目数。调用 itemBuilder，索引从 0 到 itemCount-1 不等。</p><p>正如你将在代码中看到的那样，我随意为 GridView.builder 添加了30多个。理由是，在这个例子中，我们正在操纵假定的无限数量的项目（这不是完全正确但是谁在乎这个例子）。这将强制 GridView.builder 请求显示“最多30个”项目。</p><p>此外，GridView.builder和ListView.builder只在认为必须在视口中呈现某个项目（索引）时才调用itemBuilder。</p><p>这个MovieCatalogBloc.outMoviesList返回一个List <moviecard>，它被迭代以构建每个Movie Card。第一次，这个List <moviecard>是空的但是由于itemCount：… + 30，我们欺骗系统，它将要求通过 _buildMovieCard（…）呈现30个不存在的项目。</moviecard></moviecard></p><p>正如你将在代码中看到的，此例程对 Sink 进行了一次奇怪的调用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通知MovieCatalogBloc我们正在渲染MovieCard [索引]</span></span><br><span class="line">movieBloc.inMovieIndex.add(index);</span><br></pre></td></tr></table></figure><p>此调用告诉 MovieCatalogBloc 我们要渲染 MovieCard[index]。</p><p>然后_buildMovieCard（…）继续验证与MovieCard [index]相关的数据是否存在。如果是，则渲染后者，否则显示CircularProgressIndicator。</p><p>对StreamCatalogBloc.inMovieIndex.add（index）的调用由StreamSubscription监听，该索引将索引转换为某个pageIndex数字（一页最多可计数20个电影）。如果尚未从TMDB API获取相应页面，则会调用API。获取页面后，所有已获取电影的新列表将发送到_moviesController。当GridView.builder监听该流（= movieBloc.outMoviesList）时，后者请求重建相应的MovieCard。由于我们现在有数据，我们可能会渲染它。</p><hr><h2 id="致谢与附加链接"><a href="#致谢与附加链接" class="headerlink" title="致谢与附加链接"></a>致谢与附加链接</h2><p>描述PublishSubject，BehaviorSubject和ReplaySubject的图像由ReactiveX发布。</p><p>其他一些值得阅读的有趣文章：</p><ul><li><a href="https://www.burkharts.net/apps/blog/" target="_blank" rel="noopener">Dart Streams的基础知识</a>[Thomas Burkhart]</li><li><a href="https://pub.dartlang.org/packages/rx_command" target="_blank" rel="noopener">rx_command包</a>[Thomas Burkhart]</li><li><a href="https://medium.com/flutter-io/build-reactive-mobile-apps-in-flutter-companion-article-13950959e381" target="_blank" rel="noopener">在Flutter中构建响应式移动应用程序 - 配套文章</a>[Filip Hracek]</li><li><a href="https://skillsmatter.com/skillscasts/12254-flutter-with-streams-and-rxdart" target="_blank" rel="noopener">使用Streams和RxDart写Flutter</a>[Brian Egan]</li></ul><hr><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>很长的文章，但是还有很多要说的话。就对我而言，显而易见的，这是推动Flutter应用程序开发的方法，它提供了很大的灵活性。</p><p>请继续关注新的文章。 快乐编程。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
            <tag> BLoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(译)Flutter中的widget、状态（state）、BuildContext、以及Inherited Widget</title>
      <link href="/2019/04/12/Flutter/development/data-and-backend/state-mgmt/options/InheritedWidget-Scopedmodel/Widget-State-BuildContext-InheritedWidget/"/>
      <url>/2019/04/12/Flutter/development/data-and-backend/state-mgmt/options/InheritedWidget-Scopedmodel/Widget-State-BuildContext-InheritedWidget/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.didierboelens.com/2018/06/widget---state---context---inheritedwidget/" target="_blank" rel="noopener">原文链接</a></p><p>这篇文档涵盖了Flutter应用中的重要概念Widget,状态（state）,BuildContext以及InheritedWidget。特别要引起注意的是InheritedWidget,它是最重要的一个，也是文档较少的widget。</p><p>难度：初级</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://docs.flutter.io/flutter/widgets/Widget-class.html" target="_blank" rel="noopener">Widget</a>，<a href="https://docs.flutter.io/flutter/widgets/State-class.html" target="_blank" rel="noopener">State</a>和<a href="https://docs.flutter.io/flutter/widgets/BuildContext-class.html" target="_blank" rel="noopener">BuildContext</a>的概念是Flutter中每个Flutter开发人员需要完全理解的最重要概念。</p><p>尽管文档量巨大，但是并不总能清楚地解释这些概念。</p><p>我会用自己的话语来解释这些概念，知道这可能会让一些纯粹主义者感到震惊，但本文的真正目的是弄清楚以下话题：</p><ul><li><a href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html" target="_blank" rel="noopener">有状态</a>和<a href="https://docs.flutter.io/flutter/widgets/StatelessWidget-class.html" target="_blank" rel="noopener">无状态</a>widget之间的区别</li><li>什么是<a href="https://docs.flutter.io/flutter/widgets/BuildContext-class.html" target="_blank" rel="noopener">BuildContext</a></li><li>什么是<a href="https://docs.flutter.io/flutter/widgets/State-class.html" target="_blank" rel="noopener">状态</a>以及如何使用它</li><li>BuildContext与其State对象之间的关系</li><li><a href="https://docs.flutter.io/flutter/widgets/InheritedWidget-class.html" target="_blank" rel="noopener">InheritedWidget</a>以及在Widgets树中传播信息的方式</li><li>重建的概念</li></ul><h2 id="第一部分：概念"><a href="#第一部分：概念" class="headerlink" title="第一部分：概念"></a>第一部分：概念</h2><h3 id="Widget-的概念"><a href="#Widget-的概念" class="headerlink" title="Widget 的概念"></a>Widget 的概念</h3><p>在Flutter中，几乎所有的东西都是widget。</p><p>将Widget视为可视组件（或与应用程序的可视方面交互的组件）</p><p>当您需要构建与布局直接或间接相关的任何内容时，您就正在使用widget。</p><h3 id="Widget树的概念"><a href="#Widget树的概念" class="headerlink" title="Widget树的概念"></a>Widget树的概念</h3><p>包含其他widget的widget被称为父widget（或widget容器）。</p><p>包含在父widget中的widget称为子widget。</p><p>让我们用Flutter自动生成的基本应用程序来说明这一点。</p><p>这是简化的代码，仅限于<code>build</code>方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        title: <span class="keyword">new</span> Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: <span class="keyword">new</span> Center(</span><br><span class="line">        child: <span class="keyword">new</span> Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">new</span> Text(</span><br><span class="line">              <span class="string">'You have pushed the button this many times:'</span>,</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> Text(</span><br><span class="line">              <span class="string">'<span class="subst">$_counter</span>'</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">'Increment'</span>,</span><br><span class="line">        child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们现在思考这个基础例子，我们将获得以下Widgets树结构（限于代码中存在的Widgets列表）：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*z_A9htJmE6THrxZeloVRiw.png" alt></p><h3 id="BuildContext"><a href="#BuildContext" class="headerlink" title="BuildContext"></a>BuildContext</h3><p>另一个重要的概念是BuildContext。</p><p>BuildContext只不过是对构建的所有widget的树结构中widget的位置的引用。</p><p>简而言之，将BuildContext视为Widgets树的一部分，BuildContext是Widget连接到此树的位置。</p><p>BuildContext仅属于一个wdiget。</p><p>如果widget“A”具有子widget，则widget“A”的BuildContext将成为直接子widget BuildContexts的父BuildContext。</p><p>读到此处，很明显BuildContexts被链接在一起的，并且组成了BuildContexts树（父子关系）。</p><p>如果我们现在尝试在上图中说明BuildContext的概念，我们获得（仍然是一个非常简化的视图），其中每种颜色代表一个BuildContext，MyApp除外，它是不同的：<br><img src="https://cdn-images-1.medium.com/max/800/1*Tc0kB9YXL4Bj6tonRJlH0w.png" alt></p><p>BuildContext可见性（简化的声明）：</p><p>它是仅在其自己的BuildContext或其父BuildContext的BuildContext中可见的东西。</p><p>按这句话说的，我们可以从子BuildContext获取BuildContext，并且很容易找到一个父Widget。</p><p>有个例子是，思考下 支架 &gt; 中心 &gt; 列 &gt; 文本 ：<br>context.ancestorWidgetOfExactType（Scaffold）=&gt; 通过从Text上下文转到树结构来返回第一个Scaffold。</p><p>从父BuildContext，也可以找到一个后代（=子）Widget，但不建议这样做（我们稍后会讨论）。</p><h3 id="两种类型的widget"><a href="#两种类型的widget" class="headerlink" title="两种类型的widget"></a>两种类型的widget</h3><p>Widget有两种类型：</p><h3 id="无状态widget"><a href="#无状态widget" class="headerlink" title="无状态widget"></a>无状态widget</h3><p>一些可视组件中除了它们自己的配置信息之外不依赖于任何其他信息，该信息在其直接父级构建时提供。</p><p>换句话说，这些小部件一旦创建就不必关心任何变化。</p><p>这些widget称为无状态widget。</p><p>这种widget的典型是Text，Row，Column，Container等，在构建时，我们只是将一些参数传递给它们。</p><p>参数可以是装饰，尺寸甚至其它widget的任何内容。不要紧。唯一重要的是这个配置一旦应用，在下一个构建过程之前都不会改变</p><p>无状态widget只能在加载/构建widget时绘制一次，这意味着无法根据任何事件或用户操作重绘widget。</p><h3 id="无状态widget生命周期"><a href="#无状态widget生命周期" class="headerlink" title="无状态widget生命周期"></a>无状态widget生命周期</h3><p>这是与无状态小组件相关的代码的典型结构。</p><p>如您所见，我们可以将一些额外的参数传递给它的构造函数。但是，请记住，这些参数不会在以后阶段发生变化（变异），只能按原样使用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatelessWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">MyStatelessWidget(&#123;</span><br><span class="line">Key key,</span><br><span class="line"><span class="keyword">this</span>.parameter,</span><br><span class="line">&#125;): <span class="keyword">super</span>(key:key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> parameter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使有另一种方法可以被覆盖（createElement），后者几乎从不被重写。</p><p>唯一需要被重写的是构建。</p><p>这种无状态widget的生命周期是简单直接的：</p><ul><li>初始化</li><li>通过build()渲染</li></ul><h3 id="有状态的widget"><a href="#有状态的widget" class="headerlink" title="有状态的widget"></a>有状态的widget</h3><p>其他一些widget将处理一些在Widget生命周期内会发生变化的内部数据。因此，该数据变得动态。</p><p>由此Widget持有的，在此Widget的生命周期中可能会有所不同的数据集，被称为State。</p><p>这些widget称为有状态widget。</p><p>此类Widget的示例可以是用户可以选择的复选框列表，也可以是根据条件禁用的Button。</p><h2 id="状态的概念"><a href="#状态的概念" class="headerlink" title="状态的概念"></a>状态的概念</h2><p>State定义StatefulWidget实例的“行为”部分。</p><p>它持有了就行为和布局布局而言有着相互作用/妨碍的信息。</p><p>所有应用于State变更都会强制Widget重建。</p><h2 id="State和BuildContext之间的关系"><a href="#State和BuildContext之间的关系" class="headerlink" title="State和BuildContext之间的关系"></a>State和BuildContext之间的关系</h2><p>对于有状态widget，状态与BuildContext相关联的。</p><p>此关联是永久性的，State对象永远不会更改其BuildContext。</p><p>即使可以在树结构周围移动Widget BuildContext，State仍将与该BuildContext保持关联。</p><p>当State与BuildContext关联时，State被视为已挂载。</p><p>超重要的：</p><p>由于State对象与BuildContext相关联，这意味着State对象不能（直接）通过另一个BuildContext访问！（我们将在稍后讨论这个问题）。</p><h2 id="有状态widget的生命周期"><a href="#有状态widget的生命周期" class="headerlink" title="有状态widget的生命周期"></a>有状态widget的生命周期</h2><p>在介绍了基本概念之后，是时候进一步深入了</p><p>这是与Stateful Widget相关的典型代码结构。</p><p>由于本文的主要目的是用“变量”数据来解释State的概念，我将故意跳过与某些Stateful Widget overridable方法相关的任何解释，这些方法与此没有特别的关系。</p><p>这些可覆盖的方法是didUpdateWidget，deactivate，reassemble。这些将在另一篇文章中讨论。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatefulWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">MyStatefulWidget(&#123;</span><br><span class="line">Key key,</span><br><span class="line"><span class="keyword">this</span>.parameter,</span><br><span class="line">&#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> parameter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">_MyStatefulWidgetState createState() =&gt; <span class="keyword">new</span> _MyStatefulWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyStatefulWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyStatefulWidget</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState()&#123;</span><br><span class="line"><span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Additional initialization of the State</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> didChangeDependencies()&#123;</span><br><span class="line"><span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Additional code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> dispose()&#123;</span><br><span class="line"><span class="comment">// Additional disposal code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>.dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图显示了与创建有状态widget相关的操作/调用序列（简化版本）。</p><p>在图的右侧，您将注意到流程中的State对象的内部状态。</p><p>您还将看到上下文与状态相关联的时刻，从而变为可用（已挂载）。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*a4Vdp6kZAUqXh2ye_JAEwQ.png" alt></p><p>那么让我们用一些细节来说明：</p><h3 id="initState"><a href="#initState" class="headerlink" title="initState()"></a>initState()</h3><p>initState()方法是在创建State对象后要调用的第一个方法（在构造函数之后）。</p><p>当需要执行额外初始化时，将覆盖此方法。典型的初始化是与动画，控制器有关的。</p><p>如果重写此方法，则需要在第一个位置调用super.initState()方法。</p><p>在这个方法中，上下文可用但你还不能真正使用它，因为框架还没有完全将状态与它相关联。</p><p>一旦initState（）方法完成，State对象就初始化完成了，并且上下文是可用的。</p><p>在此State对象的生命周期内不再调用此方法。</p><p>didChangeDependencies（）</p><p>didChangeDependencies（）方法是要调用的第二个方法。</p><p>在此阶段，由于上下文已经可用了，你就可以使用它了。</p><p>如果您的Widget链接到InheritedWidget和/或您需要基于BuildContext初始化一些监听器（），则通常会覆盖此方法。</p><p>请注意，如果您的widget链接到了InheritedWidget，则每次重建此widget时都会调用此方法。</p><p>如果重写此方法，则应首先调用super.didChangeDependencies()。</p><h3 id="build"><a href="#build" class="headerlink" title="build()"></a>build()</h3><p>build（BuildContext context）方法在didChangeDependencies()和didUpdateWidget(）之后调用。</p><p>这是您构建widget(以及可能的所有子树)的地方。</p><p>每次State对象更改时（或者当InheritedWidget需要通知“已注册”的widget时）都会调用此方法！</p><p>为了强制重建，您可以调用setState（（）{…}）方法。</p><h3 id="dispose"><a href="#dispose" class="headerlink" title="dispose()"></a>dispose()</h3><p>丢弃widget时调用dispose()方法。</p><p>如果需要执行一些清理（例如监听器，控制器……），则重写此方法，然后立即调用super.dispose()。</p><h2 id="无状态widget还是有状态widget"><a href="#无状态widget还是有状态widget" class="headerlink" title="无状态widget还是有状态widget"></a>无状态widget还是有状态widget</h2><p>这是一个许多开发人员需要问自己的问题：“我需要我的Widget是无状态还是有状态的？”</p><p>为了回答这个问题，请问问自己：</p><p>在我的widget的生命周期中，我是否需要考虑一个会更改的变量，并且更改的时候是否会强制widget重建？</p><p>如果问题的答案是肯定的，那么您需要一个有状态widget，否则，您需要一个无状态widget。</p><p>举几个例子：</p><ul><li>一个要展示复选框列表的widget。为了展示复选框，您需要考虑使用一个条目的数组。每个条目都是一个带着标题和状态的对象。如果单击复选框，则会切换相应的条目的状态;</li></ul><p>在这种情况下，您需要使用有状态widget来保存条目的状态，以便能够重绘复选框。</p><ul><li>表单页面。该页面允许用户填写表单widget，并将表单发送到服务器。</li></ul><p>在这种情况下，除非在提交表单之前验证表单或执行任何其他操作，无状态widget可能就足够了。</p><h2 id="有状态的widget有两部分组成的"><a href="#有状态的widget有两部分组成的" class="headerlink" title="有状态的widget有两部分组成的"></a>有状态的widget有两部分组成的</h2><p>还记得Stateful小部件的结构吗？有两个部分：</p><h3 id="Widget的主要部分的定义"><a href="#Widget的主要部分的定义" class="headerlink" title="Widget的主要部分的定义"></a>Widget的主要部分的定义</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatefulWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">    MyStatefulWidget(&#123;</span><br><span class="line">Key key,</span><br><span class="line"><span class="keyword">this</span>.color,</span><br><span class="line">&#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">_MyStatefulWidgetState createState() =&gt; <span class="keyword">new</span> _MyStatefulWidgetState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一部分“MyStatefulWidget”通常是Widget的公有部分。当您要将其添加到widget树时，可以实例化这部分。此部分在Widget的生命周期内不会发生变化，但可能接受可能由其相应的State实例使用的参数。</p><p>请注意，在Widget的第一部分级别定义的任何变量，通常在其生命周期内不会更改。</p><h3 id="widget状态定义"><a href="#widget状态定义" class="headerlink" title="widget状态定义"></a>widget状态定义</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyStatefulWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyStatefulWidget</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二部分“_MyStatefulWidgetState”，是在Widget的生命周期中变化的部分，并强制在发生改变的时候重建Widget的特定实例。</p><p>名称开头的“_”字符使该类对.dart文件是私有的。如果需要在.dart文件之外引用此类，请不要使用“_”前缀。</p><p>_MyStatefulWidgetState类可以使用widget.{变量的名称}访问存储在MyStatefulWidget中的任何变量。在此示例中：widget.color。</p><h2 id="widget唯一标识-Key"><a href="#widget唯一标识-Key" class="headerlink" title="widget唯一标识-Key"></a>widget唯一标识-Key</h2><p>在Flutter中，每个Widget都是唯一标识的。这个唯一标识由构建/渲染时的框架定义。</p><p>此唯一标识对应于可选的Key参数。如果省略，Flutter将为您生成一个。</p><p>在某些情况下，您可能需要强制使用此密钥，以便可以通过key访问widget。</p><p>为此，您可以使用以下辅助类：GlobalKey <t>，LocalKey，UniqueKey或ObjectKey。</t></p><p>GlobalKey确保key在整个应用程序中是唯一的。</p><p>强制使用Widget的唯一标识：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GlobalKey myKey = <span class="keyword">new</span> GlobalKey();</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyWidget(</span><br><span class="line">            key: myKey</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="第二部分：如何访问状态"><a href="#第二部分：如何访问状态" class="headerlink" title="第二部分：如何访问状态"></a>第二部分：如何访问状态</h2><p>如上所述，State被链接到一个Context，并且Context被链接到Widget的一个实例。</p><h3 id="1-Widget本身"><a href="#1-Widget本身" class="headerlink" title="1. Widget本身"></a>1. Widget本身</h3><p>从理论上讲，唯一能够访问状态的是Widget状态本身。</p><p>在这种情况下，没有困难。 Widget的<code>State</code>类访问其任何变量。</p><h3 id="2-一个直连的子widget"><a href="#2-一个直连的子widget" class="headerlink" title="2.一个直连的子widget"></a>2.一个直连的子widget</h3><p>有时，父widget可能需要访问直连的子widget的状态才能执行特定任务。</p><p>在这种情况下，要访问直连的子widget，你需要了解它们。</p><p>给某人打电话的最简单方法是通过名字。在Flutter中，每个Widget都有一个唯一的标识，由框架在构建/渲染时确定。</p><p>如上所示，您可以使用key参数强制使用Widget的标识。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    GlobalKey&lt;MyStatefulWidgetState&gt; myWidgetStateKey = <span class="keyword">new</span> GlobalKey&lt;MyStatefulWidgetState&gt;();</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyStatefulWidget(</span><br><span class="line">            key: myWidgetStateKey,</span><br><span class="line">            color: Colors.blue,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一旦确定，父Widget可以通过以下方式访问子widget的状态：</p><p>myWidgetStateKey.currentState</p><p>让我们考虑一个基础的例子，在用户点击按钮时显示SnackBar。</p><p>由于SnackBar是Scaffold的子Widget，它不能直接访问Scaffold body 部分的任何其他孩子（请记住上下文的概念及其层次结构/树结构？）。因此，访问它的唯一方法是通过ScaffoldState，它暴露一个公共方法来显示SnackBar。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyScreen</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/// the unique identity of the Scaffold</span></span><br><span class="line">        <span class="keyword">final</span> GlobalKey&lt;ScaffoldState&gt; _scaffoldKey = <span class="keyword">new</span> GlobalKey&lt;ScaffoldState&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        Widget build(BuildContext context)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">                key: _scaffoldKey,</span><br><span class="line">                appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">                    title: <span class="keyword">new</span> Text(<span class="string">'My Screen'</span>),</span><br><span class="line">                ),</span><br><span class="line">                body: <span class="keyword">new</span> Center(</span><br><span class="line">                    <span class="keyword">new</span> RaiseButton(</span><br><span class="line">                        child: <span class="keyword">new</span> Text(<span class="string">'Hit me'</span>),</span><br><span class="line">                        onPressed: ()&#123;</span><br><span class="line">                            _scaffoldKey.currentState.showSnackBar(</span><br><span class="line">                                <span class="keyword">new</span> SnackBar(</span><br><span class="line">                                    content: <span class="keyword">new</span> Text(<span class="string">'This is the Snackbar...'</span>),</span><br><span class="line">                                )</span><br><span class="line">                            );</span><br><span class="line">                        &#125;</span><br><span class="line">                    ),</span><br><span class="line">                ),</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-始祖widget"><a href="#3-始祖widget" class="headerlink" title="3.始祖widget"></a>3.始祖widget</h3><p>假设您有一个属于另一个Widget的子树的Widget，如下图所示。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*aE03QEqgcxdGe3NZXJ3wsA.png" alt></p><p>为了实现这一目标，需要满足3个条件：</p><h3 id="1-“带状态的widget”（红色）需要暴露其状态"><a href="#1-“带状态的widget”（红色）需要暴露其状态" class="headerlink" title="1.“带状态的widget”（红色）需要暴露其状态"></a>1.“带状态的widget”（红色）需要暴露其状态</h3><p>为了公开它的状态，Widget需要在创建时记录它，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyExposingWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   MyExposingWidgetState myState;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   MyExposingWidgetState createState()&#123;</span><br><span class="line">      myState = <span class="keyword">new</span> MyExposingWidgetState();</span><br><span class="line">      <span class="keyword">return</span> myState;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-widget-state需要暴露一些getter-setter"><a href="#2-widget-state需要暴露一些getter-setter" class="headerlink" title="2.widget state需要暴露一些getter / setter"></a>2.<code>widget state</code>需要暴露一些getter / setter</h3><p>为了让局外人能设置/获取State的属性，Widget State需要通过以下方式授权访问：</p><ul><li>公有属性（不推荐）</li><li>getter / setter</li></ul><p>举个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyExposingWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyExposingWidget</span>&gt;</span>&#123;</span><br><span class="line">   Color _color;</span><br><span class="line"></span><br><span class="line">   Color <span class="keyword">get</span> color =&gt; _color;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-“对获得状态感兴趣的widget”（蓝色）需要获得对状态的引用"><a href="#3-“对获得状态感兴趣的widget”（蓝色）需要获得对状态的引用" class="headerlink" title="3.“对获得状态感兴趣的widget”（蓝色）需要获得对状态的引用"></a>3.“对获得状态感兴趣的widget”（蓝色）需要获得对状态的引用</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChildWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   Widget build(BuildContext context)&#123;</span><br><span class="line">      <span class="keyword">final</span> MyExposingWidget widget = context.ancestorWidgetOfExactType(MyExposingWidget);</span><br><span class="line">      <span class="keyword">final</span> MyExposingWidgetState state = widget?.myState;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">         color: state == <span class="keyword">null</span> ? Colors.blue : state.color,</span><br><span class="line">      );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解决方案很容易实现，但widget如何知道它何时需要重建？</p><p>对于这个解决方案，它是不知道什么时候重建的。它必须等待重建发生，才能刷新其内容，这不是很方便。</p><p>下一节将讨论<code>Inherited Widget</code>的概念，它可以解决这个问题。</p><h2 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h2><p>简而言之，InheritedWidget使在widget树中有效地传播（和共享）信息成为可能。</p><p>InheritedWidget是一个特殊的Widget，您可以将其作为另一个子树的父级放在Widgets树中。该子树的所有widget都必须能够与该InheritedWidget公有数据进行交互。</p><p>基本</p><p>为了解释它，让我们思考以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInheritedWidget</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">   MyInheritedWidget(&#123;</span><br><span class="line">      Key key,</span><br><span class="line">      <span class="meta">@required</span> Widget child,</span><br><span class="line">      <span class="keyword">this</span>.data,</span><br><span class="line">   &#125;): <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> data;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> MyInheritedWidget of(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">return</span> context.inheritFromWidgetOfExactType(MyInheritedWidget);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   <span class="built_in">bool</span> updateShouldNotify(MyInheritedWidget oldWidget) =&gt; data != oldWidget.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码定义了一个名为“MyInheritedWidget”的Widget，它作为子树的一部分，目的是在所有widget中的共享一些数据。</p><p>如上所述，为了能够传播/共享某些数据，需要将InheritedWidget摆放在widget树的顶部，这解释了所需的子widget是如何传递给InheritedWidget的基础构造器的。</p><p>“静态方法MyInheritedWidget(BuildContext context）”允许所有子widget获取最接近上下文的MyInheritedWidget的实例(具体看后面)。</p><p>最后，如果数据发生更改，“updateShouldNotify”重写方法，用于告诉InheritedWidget是否必须将通知传递给所有子widget（那些已注册/已订阅的）。</p><p>因此，我们需要将它放在如下的树节点层级</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParentWidget</span>... </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   Widget build(BuildContext context)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyInheritedWidget(</span><br><span class="line">         data: counter,</span><br><span class="line">         child: <span class="keyword">new</span> Row(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">               ...</span><br><span class="line">            ],</span><br><span class="line">         ),</span><br><span class="line">      );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子widget是如何访问InheritedWidget的数据？"><a href="#子widget是如何访问InheritedWidget的数据？" class="headerlink" title="子widget是如何访问InheritedWidget的数据？"></a>子widget是如何访问InheritedWidget的数据？</h2><p>在子widget的构建过程中，后者将获得对InheritedWidget的引用，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChildWidget</span>... </span>&#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   Widget build(BuildContext context)&#123;</span><br><span class="line">      <span class="keyword">final</span> MyInheritedWidget inheritedWidget = MyInheritedWidget.of(context);</span><br><span class="line"></span><br><span class="line">      <span class="comment">///</span></span><br><span class="line">      <span class="comment">/// 从这个时候起，widget就能通过调用inheritedWidget.data，使用 yInheritedWidget暴露的数据</span></span><br><span class="line">      <span class="comment">///</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">         color: inheritedWidget.data.color,</span><br><span class="line">      );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何在widget之间进行交互？"><a href="#如何在widget之间进行交互？" class="headerlink" title="如何在widget之间进行交互？"></a>如何在widget之间进行交互？</h2><p>请思考以下展示widget树结构的图表。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*g3yJbjYt6jaVuV7DHpKKSA.png" alt></p><p>为了说明一种交互方式，我们作出以下假定：</p><ul><li>“widget A”是一个将项目添加到购物车的按钮;</li><li>“widget B”是一个显示购物车中商品数量的文本;</li><li>“widget C”位于widgetB旁边，是一个内置任何文本的文本widget;</li><li>我们希望“Widget B”在按下“Widget A”时自动在购物车中显示正确数量的项目，但我们不希望重建“Widget C”</li></ul><p>InheritedWidget就是用于这种情况的正确的widget。</p><p>示例代码：</p><p>先让我写下代码，随后会对其进行解释</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">   <span class="built_in">String</span> reference;</span><br><span class="line"></span><br><span class="line">   Item(<span class="keyword">this</span>.reference);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyInherited</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  _MyInherited(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.data,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> MyInheritedWidgetState data;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(_MyInherited oldWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInheritedWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  MyInheritedWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.child,</span><br><span class="line">  &#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  MyInheritedWidgetState createState() =&gt; <span class="keyword">new</span> MyInheritedWidgetState();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> MyInheritedWidgetState of(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> (context.inheritFromWidgetOfExactType(_MyInherited) <span class="keyword">as</span> _MyInherited).data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInheritedWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyInheritedWidget</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">/// List of Items</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Item&gt; _items = &lt;Item&gt;[];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Getter (number of items)</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> itemsCount =&gt; _items.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Helper method to add an Item</span></span><br><span class="line">  <span class="keyword">void</span> addItem(<span class="built_in">String</span> reference)&#123;</span><br><span class="line">    setState(()&#123;</span><br><span class="line">      _items.add(<span class="keyword">new</span> Item(reference));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _MyInherited(</span><br><span class="line">      data: <span class="keyword">this</span>,</span><br><span class="line">      child: widget.child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTree</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyTreeState createState() =&gt; <span class="keyword">new</span> _MyTreeState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyTreeState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyTree</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyInheritedWidget(</span><br><span class="line">      child: <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">          title: <span class="keyword">new</span> Text(<span class="string">'Title'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: <span class="keyword">new</span> Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">new</span> WidgetA(),</span><br><span class="line">            <span class="keyword">new</span> Container(</span><br><span class="line">              child: <span class="keyword">new</span> Row(</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  <span class="keyword">new</span> Icon(Icons.shopping_cart),</span><br><span class="line">                  <span class="keyword">new</span> WidgetB(),</span><br><span class="line">                  <span class="keyword">new</span> WidgetC(),</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetA</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> MyInheritedWidgetState state = MyInheritedWidget.of(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">      child: <span class="keyword">new</span> RaisedButton(</span><br><span class="line">        child: <span class="keyword">new</span> Text(<span class="string">'Add Item'</span>),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          state.addItem(<span class="string">'new item'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetB</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> MyInheritedWidgetState state = MyInheritedWidget.of(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Text(<span class="string">'<span class="subst">$&#123;state.itemsCount&#125;</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetC</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Text(<span class="string">'I am Widget C'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解释说明"><a href="#解释说明" class="headerlink" title="解释说明"></a>解释说明</h3><p>在这个非常基础的例子中，</p><ul><li>_MyInherited是一个InheritedWidget，每次我们通过点击“Widget A”按钮添加一个Item时都会重建</li><li>MyInheritedWidget是一个Widget，其状态包含Items列表。可以通过“（BuildContext context）的静态MyInheritedWidgetState”访问此状态。</li><li>MyInheritedWidgetState公开一个getter（itemsCount）和一个方法（addItem），以便它们可以被widget使用，这是子wiget树的一部分</li><li>每次我们将一个Item添加到State时，MyInheritedWidgetState都会重建</li><li>MyTree类只是构建一个widget树，将MyInheritedWidget作为树的父级</li><li>WidgetA是一个简单的RaisedButton，当按下它时，从最近的MyInheritedWidget调用addItem方法</li><li>WidgetB是一个简单的文本，显示最接近的MyInheritedWidget级别的项目数</li></ul><p>这一切是如何运作？</p><p>注册Widget以供以后通知</p><p>当子Widget调用MyInheritedWidget.of（context）时，它会调用MyInheritedWidget的以下方法，并传递自己的BuildContext。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MyInheritedWidgetState of(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> (context.inheritFromWidgetOfExactType(_MyInherited) <span class="keyword">as</span> _MyInherited).data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内部，除了简单地返回MyInheritedWidgetState的实例之外，它还将消费者widget订阅了以便更改通知。</p><p>在这个景象背后，对这个静态方法的简单调用实际上做了两件事：</p><ul><li>当对InheritedWidget应用修改时，消费者widget会自动添加到将重建的订户者列表中（此处为_MyInherited）</li><li>_MyInherited小部件（又名MyInheritedWidgetState）中引用的数据将返回给“消费者”。</li></ul><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>由于’Widget A’和’Widget B’都已订阅了InheritedWidget，因此如果对_MyInherited应用了修改，则当单击Widget A的RaisedButton时，操作流程如下（简化版本）：</p><ul><li>调用MyInheritedWidgetState的addItem方法</li><li>MyInheritedWidgetState.addItem方法将新项添加到List <item></item></li><li>调用setState（）以重建MyInheritedWidget</li><li>使用List <item>的新内容创建_MyInherited的新实例</item></li><li>_MyInherited记录在参数（数据）中传递的新State</li><li>作为InheritedWidget，它检查是否需要“通知”“使用者”（答案为是）</li><li>它遍历整个消费者列表（这里是Widget A和Widget B）并请求他们重建</li><li>由于Wiget C不是消费者，因此不会重建。</li></ul><p>但是，Widget A和Widget B都重建了，而重建Wiget A是没有必要的，因为它没有任何改变。</p><p>如何防止这种情况发生？</p><h3 id="在仍然访问“继承的”小组件时阻止某些小组件重建"><a href="#在仍然访问“继承的”小组件时阻止某些小组件重建" class="headerlink" title="在仍然访问“继承的”小组件时阻止某些小组件重建"></a>在仍然访问“继承的”小组件时阻止某些小组件重建</h3><p>Widget A也被重建的原因来自它访问MyInheritedWidgetState的方式。</p><p>正如我们之前看到的，调用“context.inheritFromWidgetOfExactType（）”方法的事实自动将Widget订阅到“使用者”列表。</p><p>防止此自动订阅同时仍允许Widget A访问MyInheritedWidgetState的解决方案是更改MyInheritedWidget的静态方法，如下所示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MyInheritedWidgetState of([BuildContext context, <span class="built_in">bool</span> rebuild = <span class="keyword">true</span>])&#123;</span><br><span class="line">    <span class="keyword">return</span> (rebuild ? context.inheritFromWidgetOfExactType(_MyInherited) <span class="keyword">as</span> _MyInherited</span><br><span class="line">                    : context.ancestorWidgetOfExactType(_MyInherited) <span class="keyword">as</span> _MyInherited).data;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过添加布尔额外参数…</p><ul><li>如果“rebuild”参数为true（默认情况下），我们使用常规方法（并且Widget将添加到订阅者列表中）</li><li>如果“rebuild”参数为false，我们仍然可以访问数据，但不使用InheritedWidget的内部实现<br>因此，要完成解决方案，我们还需要稍微更新Widget A的代码，如下所示（我们添加false额外参数）：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetA</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> MyInheritedWidgetState state = MyInheritedWidget.of(context, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">      child: <span class="keyword">new</span> RaisedButton(</span><br><span class="line">        child: <span class="keyword">new</span> Text(<span class="string">'Add Item'</span>),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          state.addItem(<span class="string">'new item'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，按下它时就不再重建Widget A.</p><h2 id="针对路由，对话框的特别说明"><a href="#针对路由，对话框的特别说明" class="headerlink" title="针对路由，对话框的特别说明"></a>针对路由，对话框的特别说明</h2><p>路由，对话框的上下文是与应用程序绑定的。<br>这意味着即使在页面A内部您要求显示另一个页面B（例如，在当前的屏幕上），两个屏幕中的任何一个都没有“简单的方法”来关联它们自己的上下文。<br>页面B了解页面A上下文的唯一方法是从页面A把它作为Navigator.of（context）.push（…。）的参数获取。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>关于这些主题还有很多话要说……特别是在InheritedWidget上。</p><p>在下一篇文章中，我将介绍通知器/监听器的概念，这在使用状态和传送数据的方式中也非常有趣。</p><p>感谢您阅读这篇相当长的文章，请继续关注，做一个快乐编码的人。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Inherited Widget </tag>
            
            <tag> State </tag>
            
            <tag> Widget </tag>
            
            <tag> BuildContext </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
