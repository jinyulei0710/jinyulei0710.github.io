---
layout: post
title:  "设计模式"
date:   2020-02-19 14:16:17 +0800
categories: 
    - reuse
tags:
    - 设计模式
---

## 什么是设计模式

在软件工程领域,设计模式其实就是前人总结的一些关于编写代码的一些套路.所谓套路就是针对不同问题而提出的最佳实践方案.而这里的问题都归于面向对象编程领域,对于过程编程来说就不是特别适用了.

然后设计模式的目标是什么呢? 我们可以用这本书的书名来回答,设计模式-可复用面向对象软件的基础.复用,这是一个贯穿设计模式始终的东西.对于码农的日常来说,也是说的通的,我们的目标是少写代码,甚至是不写代码,代码的可复用性就显得尤为重要.而此书中的设计模式,指的是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述.而这些设计模式的同样是要基于面向对象的,而对于面向对象来说,“继承”、“封装”、“多态”则是逃不开的机制.

<!--more-->


## 知道什么是设计模式,我们还需要用统一的格式描述它.

模式名和分类-模式名简洁地描述模式的本质。

意图-设计模式是做什么的？它的基本原理和意图是什么？

别名-模式的其他名称

动机-用以说明一个设计问题以及如何使用模式中的类、对象来解决该问题的特定情景。

适用性-什么情况下可以使用该设计模式

结构-对象建模技术

参与者-指设计模式中的类和或对象以及它们各自的职责。

效果-模式怎么支持他的目标。

实现、代码示例、已知应用、


## 编目：
Abstract Factory- 提供一个创建一系列相关或相互依赖的接口，而无须指定它们的具体的类。

Adapter- 将一个类的接口转换成客户希望的另一个接口。

Bridge- 将抽象部分与它的实现部分分离，使它们都可以独立变化

Builder- 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

Chain of Responsibility- 为解除请求的发送者和接收者之前的耦合,而使多个对象都有机会处理这个请求.将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它.

Command- 将一个请求封装为一个对象,从而使你可用不同的请求对客户进行参数化,对请求排队或记录请求日志,以及支持可取消的操作.

Composite- 将对象组合成树形结构以表示“部分-整体”的层次结构.Composite 使得客户对单个对象和符合对象的使用具有一致性.

Decorator-动态地给一个对象添加一些额外的职责.就扩展功能而言,Decorator模式比生成字累方式更为灵活.

Facade: 为子系统中的一组接口提供一个一致的界面,Facade模式定义了一个高层的接口,这个接口使得对单个对象和符合对象的使用具有一致性.

Flyweight: 运用共享技术有效地支持大量细粒度的对象

Interpreter: 给定一个语言,定义它的文法的表示,并定义一个解释器,并解释适用该表示来解释语言中的句子

Iterator: 提供一方法顺序访问一个聚合对象中的各个元素,而由不需要暴露该对象的内部表示.

Mediator: 用一个中介对象来封装一系列的对象交互.中介者使各对象不需要显式地相互引用,从而使其耦合松散,而且可以独立改变它们之间的交互.

Memento: 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态,这样以后就可将该对象恢复到保存的状态

Observer: 定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新

Prototype: 用原型实例指定创建对象的种类,并且通过拷贝这个原型来创建新的对象

Proxy: 为其他对象提供一个代理以控制对这个对象访问

Singleton: 保证一个类仅有一个实例,并提供一个访问它的全局访问点.

State: 允许一个对象在其内部状态改变时改变它的行为.

Strategy: 定义一系列的算法,把它们一个个封装起来,并且使它们可相互替换.本模式是的算法的变化可独立于适用它的客户

Template Method: 定义一个操作中算法的骨架,而将一些步骤延迟到子类中.

Visitor: 表示一个作用于某对象结构中的各元素的操作.

目的(创建型、结构型、行为型)

范围(用于类还是用于对象)

模式关系

设计模式怎样解决设计问题:

寻找合适的对象

决定对象的粒度

指定对象接口








