<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="目前为止,目前我们使用的线程通讯手段都是常规的 Java 应用所使用的. 管道、内存共享、可阻塞式队列可以应用到 Android 应用 ,但是会引起 UI 线程的问题, 因为这些手段都倾向于堵塞. UI 线程的响应性在使用带有阻塞行为的机制的时候是有风险的,因为这些机制通常可能会使线程挂起. 在 Android 中绝大部份线程之间的通讯是 UI 线程和 工作线程之间的通讯.因此,Android 平">
<meta name="keywords" content="线程">
<meta property="og:type" content="article">
<meta property="og:title" content="(译)Android 消息传递机制">
<meta property="og:url" content="https://jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/index.html">
<meta property="og:site_name" content="捕线程者">
<meta property="og:description" content="目前为止,目前我们使用的线程通讯手段都是常规的 Java 应用所使用的. 管道、内存共享、可阻塞式队列可以应用到 Android 应用 ,但是会引起 UI 线程的问题, 因为这些手段都倾向于堵塞. UI 线程的响应性在使用带有阻塞行为的机制的时候是有风险的,因为这些机制通常可能会使线程挂起. 在 Android 中绝大部份线程之间的通讯是 UI 线程和 工作线程之间的通讯.因此,Android 平">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-4.api-overview.png">
<meta property="og:image" content="https://jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-5.png">
<meta property="og:image" content="https://jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-6.png">
<meta property="og:image" content="https://jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-7.png">
<meta property="og:image" content="https://jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-8.png">
<meta property="og:image" content="https://jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-9.png">
<meta property="og:updated_time" content="2020-04-01T06:11:06.359Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="(译)Android 消息传递机制">
<meta name="twitter:description" content="目前为止,目前我们使用的线程通讯手段都是常规的 Java 应用所使用的. 管道、内存共享、可阻塞式队列可以应用到 Android 应用 ,但是会引起 UI 线程的问题, 因为这些手段都倾向于堵塞. UI 线程的响应性在使用带有阻塞行为的机制的时候是有风险的,因为这些机制通常可能会使线程挂起. 在 Android 中绝大部份线程之间的通讯是 UI 线程和 工作线程之间的通讯.因此,Android 平">
<meta name="twitter:image" content="https://jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-4.api-overview.png">





  
  
  <link rel="canonical" href="https://jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>(译)Android 消息传递机制 | 捕线程者</title>
  




  <script async src="//www.googletagmanager.com/gtag/js?id=UA-138654110-1"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !false) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-138654110-1');
    }
  </script>



  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bcc193740f027583bde09c22a8c7a191";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">捕线程者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">死磕技术,淡然下笔</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="顽石">
      <meta itemprop="description" content="去油之旅">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="捕线程者">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">(译)Android 消息传递机制

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-26 14:16:17" itemprop="dateCreated datePublished" datetime="2020-03-26T14:16:17+08:00">2020-03-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-04-01 14:11:06" itemprop="dateModified" datetime="2020-04-01T14:11:06+08:00">2020-04-01</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2020/03/26/Android/AndroidMessagePassing/" class="leancloud_visitors" data-flag-title="(译)Android 消息传递机制">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>目前为止,目前我们使用的线程通讯手段都是常规的 Java 应用所使用的. 管道、内存共享、可阻塞式队列可以应用到 Android 应用 ,但是会引起 UI 线程的问题, 因为这些手段都倾向于堵塞. UI 线程的响应性在使用带有阻塞行为的机制的时候是有风险的,因为这些机制通常可能会使线程挂起.</p>
<p>在 Android 中绝大部份线程之间的通讯是 UI 线程和 工作线程之间的通讯.因此,Android 平台定义了它自己的线程间通讯的方式. UI 线程能够以发送数据消息的方式让长时间运行的任务在后台线程被处理.消息传递机制是非阻塞式的 生产者-消费者模式,在这个模式下无论是生产者线程还是消费者线程,在消息处理的时候都不会被堵塞.</p>
<p>消息处理机制是 Android 平台的基石, API 位于 android.os 包下, 由下图 4-4 中所示的一系列类来实现功能.</p>
<p><img src="//jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-4.api-overview.png" alt></p>
<a id="more"></a>

<p>android.os.Looper</p>
<p>&emsp;&emsp;&emsp;&emsp; 跟有且只有一个消费者线程关联的消息分发者</p>
<p>android.os.Handler</p>
<p>&emsp;&emsp;&emsp;&emsp; 消费线程消息处理者,生产者线程插入消息到队列的接口. 一个Looper能有多个相关联的Handler,但是它们都会被插入到相同的队列中.</p>
<p>android.os.MessageQueue</p>
<p>&emsp;&emsp;&emsp;&emsp; 在消费者线程被处理的无限的消息列表.每一个Looper以及线程至多有一个消息队列.</p>
<p>android.os.Message</p>
<p>&emsp;&emsp;&emsp;&emsp; 将被在消费者线程执行的消息</p>
<p>如图4-5所示消息由生产者线程插入并且由消费者线程处理.</p>
<ol>
<li>插入: 生产者线程通过使用与消费者线程相关联的Handler往消息队列中插入消息</li>
<li>获取:运行在消息者线程的Looper按照序列的顺序从队列中获取消息</li>
<li>分发: handler负责在消费者线程处理消息.一个线程可能有多个Handler实例来处理消息,Looper确保了消息被分发到了正确的Handler.</li>
</ol>
<p><img src="//jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-5.png" alt></p>
<p>图 4-5 ,多个生产者线程和单个消费者线程之间的消息传递机制.每个消息都指向队列中的下一个消息,图中以左向的箭头指示.</p>
<h1 id="例子-基本的消息传递"><a href="#例子-基本的消息传递" class="headerlink" title="例子: 基本的消息传递"></a>例子: 基本的消息传递</h1><p>在我们进一步详细的分析组件之前,让我们先来看个基本的消息传递的例子来熟悉下:</p>
<p>以下代码实现可能是最常见的使用场景之一,用户按下屏幕上的一个能够触发长时间操作的按钮,例如网络操作.为了不拖慢UI的渲染,一个假的 代表长时间运行的操作doLongRunningOperation()方法 ,需要运行在工作线程.因此,需要仅仅需要对一个生产者线程(UI线程)以及一个工作线程(Looper线程)进行设置.</p>
<p>我们的代码建立了一个消息队列.它在click()回调中处理按钮点击事件,这是在UI线程执行的.在我们的实现中,回调插入了一条假的消息到消息队列当中.为简洁起见,布局和UI组件在我们的代码事例中被省略了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class LooperActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    LooperThread mLooperThread;</span><br><span class="line"></span><br><span class="line">    private static class LooperThread extends Thread &#123; //1</span><br><span class="line"></span><br><span class="line">        Handler mHandler;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Looper.prepare();//2</span><br><span class="line">            mHandler = new Handler() &#123;//3</span><br><span class="line">                @Override</span><br><span class="line">                public void handleMessage(@NonNull Message msg) &#123;//4</span><br><span class="line">                    if (msg.what == 0) &#123;</span><br><span class="line">                        doLongRunningOperation();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Looper.loop();//5</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void doLongRunningOperation() &#123;</span><br><span class="line">            //Add long running operation here.</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onCreate(Bundle saveInstanceState) &#123;</span><br><span class="line">        super.onCreate(saveInstanceState);</span><br><span class="line">        mLooperThread = new LooperThread();//6</span><br><span class="line">        mLooperThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        if (mLooperThread.mHandler != null) &#123;//7</span><br><span class="line">            Message msg = mLooperThread.mHandler.obtainMessage(0);//8</span><br><span class="line">            mLooperThread.mHandler.sendMessage(msg);//9</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        mLooperThread.mHandler.getLooper().quit();//10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>定义工作线程,作为消息队列的消费者</li>
<li>将 Looper-隐式关联了消息队列与线程关联在一起</li>
<li>设置一个被生产者所使用的Handler,让生产者用来插入消息到队列中.这里我们使用的是默认的构造器,因而会与当前线程的 Looper 绑定在一起. 因此,Handler 只能在 Looper.prepare() 之后创建,不然它没有东西可以绑定了.</li>
<li>当消息被分发到工作线程的时候进入了回调.它会检查 what 参数并执行长时间运行的任务</li>
<li>开始从消息队列向消息者线程分发消息.这是一个阻塞的调用,因此工作现象不会终止.</li>
<li>启动工作线程,从而它能开始处理消息</li>
<li>后台工作线程上handler的设置和handler在UI线程上的使用存在竞态.因此需要验证mHandler是否可用.</li>
<li>初始化一个消息对象并将其what参数设置为0</li>
<li>将消息插入队列</li>
<li>终止后台线程.Looper.quit()的调用终止了 消息的分发并将 Looper.loop 从 阻塞中释放出来,从而run方法能终止,从而导致线程的终止.</li>
</ol>
<h1 id="消息传递所使用的类"><a href="#消息传递所使用的类" class="headerlink" title="消息传递所使用的类"></a>消息传递所使用的类</h1><p>现在,让我们更为具体地看看消息传递中所使用的具体组件,以及它们的用途.</p>
<h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>消息队列由 android.os.MessageQueue 所代表.它由链接的消息构建而成,形成了一个无限的单向链表.生产者线程插入到队列的消息,稍后会被分发到消息者.消息是基于事件戳排序的.队列中时间戳最小的消息,排在分发给消费者的队列的最前面.但是,消息只有在时间戳的值小于当前的时间值的时候才会被分发.如果时间没有到,分发这个动作会等到当前时间超过时间戳.</p>
<p>图4-6 显示了一个有三个等待的消息的消息队列,它们是以时间戳顺序排列的, t1 &lt; t2&lt; t3. 只有一个消息越过了分发栏栅,这个栏栅代表当前时间.能够被分发的消息的时间是小于当前时间的.</p>
<p><img src="//jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-6.png" alt></p>
<p>图 4-6 队列中的处于等待状态的消息.最右边的消息,是队列中最先被处理的.队列中的消息的箭头指向队列中的下一个消息.</p>
<p>如果没有消息被越过分发栏栅,而Looper以及做好获取下一个消息的转呗,消费者者线程会阻塞. 执行会在消息被发送到分发栏栅的时候恢复.</p>
<p>生产者能能够在任意时间以及队列的任意位置插入一个新的消息.队列中插入的位置是由时间戳决定的.如果跟等待的消息比,新的消息由最小的时间戳,那么它就会占据队列的第一个位置,将被下一个分发.插入总是遵循时间戳的顺序的.关于消息插入的部分会在 Hanlder这节进一步分析.</p>
<h2 id="MessageQueue-IdleHandler"><a href="#MessageQueue-IdleHandler" class="headerlink" title="MessageQueue.IdleHandler"></a>MessageQueue.IdleHandler</h2><p>如果没有消息要处理,消费者线程就会有一些空闲时间.例如,图4-7,显示了当消费者线程空闲的时候,由一段时间槽.默认情况下,消费者线程只会在空闲时间期间等待新的消息,但是处了等待,在空闲槽期间线程能被分配去执行其它任务.这个特性能够让非重要的任务让出它们的执行时间,直到没有其它消息竞争执行时间. </p>
<p><img src="//jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-7.png" alt></p>
<p>图 4-7. 如果没有消息被传到分发栏栅,在下一个等待消息被执行之前,就存在一段时间槽能用来执行.</p>
<p>当等待的消息被分发之后,没有其它消息被传到分发栏栅,就会有一段时间槽,期间消费者线程能利用它来执行其它任务.应用通过 android.os.Message.IdleHandler 接口来获取着的时间槽. IdleHanlder 接口,值当线程空闲的时候的一个监听回调.监听被附加到消息队列上并以如下调用的方式从队列上脱离出来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Get the message queue of the current thread.</span><br><span class="line">Message mq=Looper.myQueue();</span><br><span class="line">//Create and register and idle listener</span><br><span class="line">MessageQueue.IdleHandler idleHanlder=new MessageQueue.IldeHandler();</span><br><span class="line">mq.addIdleHandler(idlehandler)</span><br><span class="line">//Unregister an idle Handler</span><br><span class="line">mq.removeIdleHanlder(idleHanlder)</span><br></pre></td></tr></table></figure>

<p>idle hanlder 接口只包含了一个 callback 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IdleHandler &#123;</span><br><span class="line">     boolean queueIdle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当消息队列监测到消息队列的空闲时间的时候,它会调用所有注册过 IdleHanlder 实例地方的 queueIdle().实现callback的责任就交给了应用.你应该避免运行长时间运行的任务,因为在它们运行的时候,它们会推迟等待中的消息.</p>
<p>queue() 的实现必须返回一个布尔值,具体含义如下:</p>
<p>true</p>
<p>&emsp;&emsp;&emsp;&emsp; idle hanlder 处于活跃态,它会继续在接下来的时间槽中接收回调.</p>
<p>false</p>
<p>&emsp;&emsp;&emsp;&emsp; idle handler 已经不活跃了,就接下去又时间槽,他也不会接受到回调了.这个效用是更通过 MessageQueue.removeIdleHanlder()移除监听是一样的.</p>
<h3 id="例子-使用-Idle-Hanlder-来终止一个不再使用的线程"><a href="#例子-使用-Idle-Hanlder-来终止一个不再使用的线程" class="headerlink" title="例子:使用 Idle Hanlder 来终止一个不再使用的线程"></a>例子:使用 Idle Hanlder 来终止一个不再使用的线程</h3><p>当线程又空闲时间槽的时候,所有在 MessageQueue 上注册过 IdleHanlders 的,都会被调用,期间他在等待要处理的新消息. 空闲时间槽能够发生在第一个消息之前,消息之前,以及最后一个消息之后.如果多个内容提供者应该在消费者线程上按序处理数据, IdleHandler 可以用来终止消费者线程,当消息都处理完了,线程在内存中就没有用处了.有了 IdleHanlder,没有必要记录最后一个插入的消息去得知什么时候线程能被终止.</p>
<p>这只在生产者线程没有延迟地插入消息到队列中才有效,因为这样直到最后一个消息插入之后消费者线程才会进入空闲状态.</p>
<p>ConsumeAndQuitThread 方法展示了 带有 Looper和消息队列的线程的结构,这个线程会在没有消息要处理的时候被终止:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private static class ConsumeAndQuitThread extends Thread implements MessageQueue.IdleHandler &#123;</span><br><span class="line"></span><br><span class="line">        private static final String THREAD_NAME = &quot;ConsumeAndQuitThread&quot;;</span><br><span class="line"></span><br><span class="line">        public Handler mConsumerHandler;</span><br><span class="line">        private boolean mIsFirstIdle = true;</span><br><span class="line"></span><br><span class="line">        public ConsumeAndQuitThread() &#123;</span><br><span class="line">            super(THREAD_NAME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Looper.prepare();</span><br><span class="line"></span><br><span class="line">            mConsumerHandler = new Handler() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void handleMessage(Message msg) &#123;</span><br><span class="line">                    // Consume data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Looper.myQueue().addIdleHandler(this);//1</span><br><span class="line">            Looper.loop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean queueIdle() &#123;</span><br><span class="line">            if (mIsFirstIdle) &#123;//2</span><br><span class="line">                mIsFirstIdle = false;</span><br><span class="line">                return true;//3</span><br><span class="line">            &#125;</span><br><span class="line">            mConsumerHandler.getLooper().quit();//4</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void enqueueData(int i) &#123;</span><br><span class="line">            mConsumerHandler.sendEmptyMessage(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>当天启动的时候在后台线程注册IdleHanlder,然后Looper就准备好了,然后消息队列就设置好了.</p>
</li>
<li><p>让第一个 queueIdle 调用通过,因此它会在首个消息到达之前发生</p>
</li>
<li><p>在一次调用的时候返回true,所以IdleHandler仍然是注册着的</p>
</li>
<li><p>终止线程</p>
<p>消息插入是由多个线程并发插入的,并且模拟一个随机的插入时间:</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final ConsumeAndQuitThread consumeAndQuitThread = new ConsumeAndQuitThread();</span><br><span class="line">        consumeAndQuitThread.start();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                        SystemClock.sleep(new Random().nextInt(10));</span><br><span class="line">                        consumeAndQuitThread.enqueueData(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h1 id="消息-Message"><a href="#消息-Message" class="headerlink" title="消息(Message)"></a>消息(Message)</h1><p>消息队列上的每一项都是 android.os.Message 类,这是一个运送数据或任务,或什么也不运的容器对象.数据由消费者线程处理,然而任务只是在出队列的时候执行,你不需要做其它处理:</p>
<p>消息知道他的接受处理者Hanlder,并通过Message.sendToTarget()将其自身入队:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message m=Message.obtain(hanlder,runnable);</span><br><span class="line">m.sendToTarget();</span><br></pre></td></tr></table></figure>

<p>正如我们会在handler这一节会看到的,handler 最常用来进行消息入队,同时就消息插入提供了更多的灵活性.</p>
<h2 id="数据消息-Data-Message"><a href="#数据消息-Data-Message" class="headerlink" title="数据消息(Data Message)"></a>数据消息(Data Message)</h2><p>数据集有着多个能够被传递给消费者线程的参数,如表 4-2 所示:</p>
<p>表 4-2 消息参数</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>what</td>
<td>int</td>
<td>消息标识.消息的通讯意图</td>
</tr>
<tr>
<td>arg1,arg2</td>
<td>int</td>
<td>用于传递整型的简单数据,如果最多只有两个整数值要被传递到消费者线程,这些参数比分配一个bundle来传递更为高效.</td>
</tr>
<tr>
<td>obj</td>
<td>Object</td>
<td>任意对象.如果一个对象要传递到另一个进程的线程中,它必须实现 Parcelable</td>
</tr>
<tr>
<td>data</td>
<td>Bundle</td>
<td>任意数据值的容器</td>
</tr>
<tr>
<td>replyTo</td>
<td>Messager</td>
<td>指向其它进程中的Hanlder.使跨进程消息通讯成为可能</td>
</tr>
<tr>
<td>callback</td>
<td>Runnable</td>
<td>在线程上执行的任务.这是一个持有来自Hanlder.post 方法的 Runnable 对象的内部实例域.</td>
</tr>
</tbody></table>
<h2 id="任务消息-Task-Message"><a href="#任务消息-Task-Message" class="headerlink" title="任务消息(Task Message)"></a>任务消息(Task Message)</h2><p>任务由运行在消费者线程的java.lang.Runnable 对象代表.任务对象除了任务本身之外不能包含任何数据.</p>
<p>消息队列可以包含仍以数据和任务消息的组合.消费者线程以线性的方式对它们进行处理,不管它们是什么类型.如果消息是数据消息,消费者线程会处理数据.任务消息的处理方式是让Runnable执行在消费者线程上,但是消费者线程没有像数据消息一样在Handler.handleMessage(Message)中收到任何消息.</p>
<p>消息的生命周期是简单的:生产者创建消息,并且最终消息由消费者线程处理.这样的描述适用于大部分使用场景,但是出问题的时候,对消息处理的进一步理解就很有价值了.让我们看看在它的生命周期中,在消息身上到底发生了什么,这个过程可以分为如图4-8中的最重要的4步.运行时将消息对象存储到一个应用范围的对象池,从而使得能对之前的消息进行复用.这个避免了在每个处理的时候创建新的实例的消耗.消息对象的处理时间通常是很短的,并且许多消息在在一个时间单位就处理完了.</p>
<p><img src="//jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-8.png" alt></p>
<p>图 4-8 消息生命周期状态</p>
<p>状态转换部分由应用控制,部分由平台控制.注意状态不是可观察的,并且应用不能观察到从一个状态到另一个状态的变化.因此,应用不应该对于消息的当前状态作出任何假定.</p>
<h2 id="初始化-Initialized"><a href="#初始化-Initialized" class="headerlink" title="初始化(Initialized)"></a>初始化(Initialized)</h2><p>在初始化状态,一个可修改状态的消息对象已经被创建,并且如果它是数据对象的话,已经被数据填充了.应用负责使用以下的调用来创建消息对象.它们能够从对象池中获取一个对象:</p>
<ul>
<li><p>明确的对象构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message m=new Message();</span><br></pre></td></tr></table></figure>
</li>
<li><p>工厂方法:</p>
<ul>
<li><p>空消息:</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message m=Message.obtain();</span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>数据消息:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Message m=Message.obtain(Handler h);</span><br><span class="line">Message m=Message.obtain(Hanlder h,int what);</span><br><span class="line">Message m=Message.obtain(Handler h,int what, object o);</span><br><span class="line">Message m=Message.obtain(Handler h,int what, int arg1, int arg2);</span><br><span class="line">Message m=Message.obtain(Hanlder,int what,int arg1,int arg2,Object o);</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><p>任务消息</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message m=Message.obtain(Handler h,Runnable task);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>拷贝构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message m=Message.obtain(Message originMsg);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="等待-Pending"><a href="#等待-Pending" class="headerlink" title="等待(Pending)"></a>等待(Pending)</h2><p>消息已经由生产者线程插入队列,并且它正等待着被分发到消费者线程.</p>
<h2 id="已分发-Dispatched"><a href="#已分发-Dispatched" class="headerlink" title="已分发(Dispatched)"></a>已分发(Dispatched)</h2><p>在此状态下,Looper已经获取并从队列中移除了消息.消息已经被分发到了消费者线程,并且正在被处理.对于这部操作没有应用api,因为分发是由Looper控制的,而不受应用的影响.当Looper分发一个消息,它会检查消息的分发信息然后分发消息到正确的接受者.一旦分发了,消息是在消费者线程上执行的.</p>
<h2 id="已回收-Recycled"><a href="#已回收-Recycled" class="headerlink" title="已回收(Recycled)"></a>已回收(Recycled)</h2><p>在生命周期的这一时刻,消息的状态已经被清理了并且实例已经被交还给了消息池.当它结束在消费者线程的执行,Looper 处理了消息的回收.消息的回收是由运行时处理的,并且不应该由应用显式地完成.</p>
<p>一旦消息被插入了队列,内容应该不应在被修改了.理论上,在消息处理之前修改内容是合法的.但是,因为状态是不可观察的,在变更数据的时候,消息已经可能被消费者线程处理的,就会导致线程安全问题.更糟糕的是,消息可能已经被回收,因为它已经被交还给了消息池并且被另一个生产者传入到另一个队列中.</p>
<h1 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h1><p>android.os.Looper 类负责将队列中的消息分发到相关联的 handler.就如图4-6所示,所有的消息都得发送到分发栏栅,从而能够被Looper进行分发.只要队列中有消息能被分发,Looper就能保证消费者线程能收到消息.当没有消息被传到分发栏栅的时候,消费者线程就会阻塞直到有消息传到分发栏栅.</p>
<p>消费者线程并不直接和消息队列交互来获取消息.而是,在Looper添加到线程之后,消息队列才添加到线程.Looper对消息队列进行管理并促进消息到消费者线程的分发.</p>
<p>默认情况下,只有UI线程会有Looper,在应用中创建的线程需要获取looper并显式地进行关联.当Thread上的Looper创建好了,他就被连接到了消息队列.Looper就成了队列和线程之前的中介.设置过程是在线程的run方法中完成的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class ConsumerThread extends Thread &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void run()&#123;</span><br><span class="line">        Looper.prepare();//1</span><br><span class="line">        </span><br><span class="line">        //Handler creation omitted.</span><br><span class="line">        </span><br><span class="line">        Looper.loop();//2</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>第一步是创建Looper,这一步是由静态的 prepare() 方法完成的;它会创建一个消息队列并将当前的线程与之关联.此时,队列已经做了了消息插入的准备,但是它们没有被分发到消费者线程.</li>
<li>开始在消息队列中处理消息.这是一个阻塞方法,从而确保run()方法不会终止,当run()阻塞的时候,Looper分发消息到消费者线程进行处理.</li>
</ol>
<p>一个线程只能有一个相关的Looper,当应用尝试设置第二个Looper的时候会发生运行时错误.因此,一个线程只有有一个消息队列,意味着有多个生产者线程发送的消息在消费者线程中是顺序处理的.<br>因此,当前的消息在它被执行之前都会推迟后续消息的执行.需要长时间执行的消息不能被使用,因为它们可能对队列中其它重要的消息造成延迟.</p>
<h2 id="Looper-终止"><a href="#Looper-终止" class="headerlink" title="Looper 终止"></a>Looper 终止</h2><p>Looper如果要停止执行消息的话,就要使用 quit 或者 quitSafely. quit()让looper停止对队列中的其余消息进行分发,所有队列中等待的消息包括那些已经到到分发栏栅的,都会被丢弃.另一方面,quitSafely,只会丢弃那些没有到达分发栏栅的消息.在Looper终止之前,符合分发条件的等待消息会被处理掉. quitSafely 是在api 18添加的,之前的api只支持quit.</p>
<p>终止Looper并没有终止线程,它只是跳出了Looper.loop()并让线程恢复运行在调用loop的方法.但是你不能启动旧的Looper或新建一个looper,所以线程就不能在入队和处理消息了.如果你调用Looper.prepare(),它会抛出运行时异常,因为线程已经有Looper附加了.如果你调用Looper.loop,它会阻塞,但是没有消息会从队列中分发出来.</p>
<h2 id="UI-线程-Looper"><a href="#UI-线程-Looper" class="headerlink" title="UI 线程 Looper"></a>UI 线程 Looper</h2><p>UI 线程是唯一一个默认就有相关联Looper的线程.和其它由应用本身创建的线程一样,它是一个常规的线程,但是Looper是在应用组件初始化之前就被关联到线程的.</p>
<p>UI 线程 Looper和其它应用线程Looper还是由一些实际区别的:</p>
<ul>
<li>它能通过Looper.getMainLooper()方法从任意地方访问.</li>
<li>它不能被终止.调用Looper.quit()会抛出运行时异常.</li>
<li>运行时通过Looper.prepareMainLoop()将Looper和UI线程关联在一起.每一个应用只能执行一次.正因如此,尝试附加主线程Looper到其它线程或抛出异常.</li>
</ul>
<h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><p>目前为止,关注点在于Android线程通讯的内部机制,但是应用大部分是和android.os.Hanlder打交道的.它是一个双侧的API,既要处理消息的插入队列也要进行消息的处理.如同 4-5所示,它同时由生产者线程和消费者线程调用来进行以下处理:</p>
<ul>
<li>创建消息</li>
<li>插入消息到队列中</li>
<li>在消费者线程处理消息</li>
<li>队列中消息的管理</li>
</ul>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>谈及到Hanlder的职责,handler 与 Looper ,消息队列以及消息都有交互.如图4-4所示:handler唯一直接的关系是和Looper,Looper是和消息队列连接的.如果没有Looper,handler就不能工作,它们不能与队列组合来插入消息,因此它们不能收到任何消息进行处理.因此,handler实例是构造的时候与Looper 实例绑定的:</p>
<ul>
<li><p>没有显式Looper的构造器绑定的是当前线程的Looper:UI线程由平台内部的类android.app.ActivityThread 管理</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Hanlder();</span><br><span class="line">new Hanlder(Hanlder.Callback)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在构造器中显式指定Looper进行绑定</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Handler(Looper);</span><br><span class="line">new Hanlder(Looper,Hanlder.Callback);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果没有显式构造器的Looper在一个没有Looper的线程被调用(例如:它没有调用Looper.prepare()),就没东西让Hanlder绑定了,就会导致运行时异常.一旦handler绑定到了一个Looper,这个绑定是不可变的.</p>
<p>一个线程能够有多个handler,来自这些hanlder的消息共存于消息中,但是能够被分发到正确的Handler实例.如图 4-9所示:</p>
<p><img src="//jinyulei.cn/2020/03/26/Android/AndroidMessagePassing/4-9.png" alt></p>
<p>图4-9 多个handler使用同一个Looper,插入消息的handler和处理消息的handler是同一个.</p>
<p>多个hanlder了并没有导致并发执行,消息仍然在一个队列中并按序被处理.</p>
<h2 id="消息创建"><a href="#消息创建" class="headerlink" title="消息创建"></a>消息创建</h2><p>为简单起见,Handler类提供了如下所示的工产方法封装用来创建Message类的对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Message obtainMessage(int what, int arg1,int arg2);</span><br><span class="line">Message obtainMessage()</span><br><span class="line">Message obtainMessage(int what,int arg1,int arg2,Object obj)</span><br><span class="line">Message obtainMessage(int what,Object obj)</span><br></pre></td></tr></table></figure>

<p>从Handler获取的message是从消息池获取而来的,并且与请求它的Hanlder实例隐式连接.这个连接使Looper能将每个消息分发到正确的Hanlder成为可能.</p>
<h2 id="消息插入"><a href="#消息插入" class="headerlink" title="消息插入"></a>消息插入</h2><p>根据消息类型的不同,Hanlderyou着多种插入队列的不同方式.插入任务消息的方法是以post为前缀的,而数据消息是以send为前缀的:</p>
<ul>
<li><p>添加一个任务到消息队列当中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean post(Runnable r)</span><br><span class="line">boolean postAtFrontQueue(Runnable r)</span><br><span class="line">boolean postAtTime(Runnable r, Object token,long uptimeMillis)</span><br><span class="line">boolean postAtTime(Runnable r,long uptimeMills)</span><br><span class="line">boolean postDealyed(Runnable r,long dealyMillis)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>添加一个数据对象到消息队列中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean sendMessage(Message msg)</span><br><span class="line">boolean sendMessageAtFrontOfQueue(Message msg)</span><br><span class="line">boolean sendMessageAtTime(Message msg,long uptimeMillis)</span><br><span class="line">boolean sendMessageDelayed(Messsage msg,long delayMillis)</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加一个简单数据对象到消息队列中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean sendEmptyMessage(int what)</span><br><span class="line">boolean sendEmptyAtTime(int what, long uptimeMillis)</span><br><span class="line">boolean sendEmptyDelayed(int what, long delayMillis)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>所有的插入方法都会放一个消息到队列中,即使应用没有显式地创建消息对象.post系列中的Runnable, send 系列中的 what,都被包含在Message对象中,因为消息是队列中唯一可以包含的对象.</p>
<p>每个插入消息的队列都有会有个指示消息能够被分发到消费者线程的的时间参数.队列的排序是基于时间参数的,并且踏实应用唯一能影响分发顺序的方式:</p>
<p>default:</p>
<p>&emsp;&emsp;&emsp;&emsp; 立即能够被分发</p>
<p>at_front    </p>
<p>&emsp;&emsp;&emsp;&emsp; 消息在时间为0的时候被分发.因此,它是下一个被分发的消息,除非有另一个消息在它被处理之前插入了.</p>
<p>delay</p>
<p>&emsp;&emsp;&emsp;&emsp; 在能够被分发之前延长一定的时间</p>
<p>uptime</p>
<p>&emsp;&emsp;&emsp;&emsp; 消息能够被分发的绝对时间</p>
<p>尽管显式的延迟和运行时间是可以指定的,但是咩哥消息的处理时间是不确定的.这依赖于已有消息的处理时间和操作系统调度情况.</p>
<p>插入消息到队列中不是保险的.如下表4-3所示的一些常见错误会发生.</p>
<p>表4-3.消息插入错误</p>
<table>
<thead>
<tr>
<th>错误</th>
<th>错误返回</th>
<th>常见的应用问题</th>
</tr>
</thead>
<tbody><tr>
<td>消息没有Hanlder</td>
<td>RuntimeException</td>
<td>消息是从一个没有Hanlder的Message.obtain()方法创建的.</td>
</tr>
<tr>
<td>Message已经被分发了并且已经被处理了</td>
<td>RuntimeExeception</td>
<td>同样的消息被插入了两次</td>
</tr>
<tr>
<td>Looper已经退出</td>
<td>返回 false</td>
<td>在Looper.quit()被调用之后消息被插入了</td>
</tr>
</tbody></table>
<p>Handler类的dispatchMessage()方法是用来让Looper分发消息到消费者线程的.如果由应用直接使用,消息会在调用的线程处理而不是在消费者线程处理.</p>
<h2 id="例子-双向消息传递"><a href="#例子-双向消息传递" class="headerlink" title="例子: 双向消息传递"></a>例子: 双向消息传递</h2><p>HanlderExampleActivity 模拟了一个长时间运行的操作,这个操作是在用户点击按钮的时候启动的.长时间运行的任务在后台线程运行,与此同时,用户界面上展示了一个进度条,这个进度条会在结果返回UI线程的时候被移除.</p>
<p>首先,设置Activity:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class HanlderExampleActivity entends Activity&#123;</span><br><span class="line">   </span><br><span class="line">     private final static int SHOW_PROGRESS_BAR=1;</span><br><span class="line">     private final static int HIDE_PROGRESS_BAR=0;</span><br><span class="line">     private BackgroundThread mBackgroundThread;</span><br><span class="line">     </span><br><span class="line">     private TextView mText;</span><br><span class="line">     private Button mButton;</span><br><span class="line">     private ProgressBar mProgressBar;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     @Override</span><br><span class="line">     public void onCreate(Bundle savedInstanceState)&#123;</span><br><span class="line">         super.onCreate(savedInstanceState);</span><br><span class="line">         setContentView(R.layout.activity_handler_example);</span><br><span class="line">         </span><br><span class="line">         mBackgroundThread=new BackgroundThread();</span><br><span class="line">         mBackgroundThread.start();//1</span><br><span class="line">         </span><br><span class="line">         mText=(TextView)findViewById(R.id.text);</span><br><span class="line">         mProgressBar=(ProgressBar)findViewById(R.id.progress);</span><br><span class="line">         mButton.setOnClickListener(new OnClickListener()&#123;</span><br><span class="line">         </span><br><span class="line">             @Override</span><br><span class="line">             public void onClick(View v)&#123;</span><br><span class="line">                 </span><br><span class="line">                 @Override</span><br><span class="line">                 public void click(View v)&#123;</span><br><span class="line">                 </span><br><span class="line">                    mBackgroundThread.doWork(); //2</span><br><span class="line">                 &#125;</span><br><span class="line">         </span><br><span class="line">         &#125;);</span><br><span class="line">          </span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();   </span><br><span class="line">        mBackgroundThread.exit();//3</span><br><span class="line">    &#125;</span><br><span class="line">    //... The rest of the Activity is defined futher down</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>带有消息队列的后台线程是在HanlderExampleActivity创建的时候启动的.它处理了来自UI线程的任务.</li>
<li>当用户点击按钮,一个新的任务就被发送到后续线程.因为任务在后台线程是线性处理的,在它们被处理完之前,多次按钮点击可能导致排队.</li>
<li>当 HanlderExampleActivity 被销毁的时候,后台线程被终止了.</li>
</ol>
<p>后台线程是用来承载来自UI线程的任务的.当它运行的时候,在HanlderExampleActivity生命周期期间它就能接受消息.它并没有暴露出它内部的Hanlder, 而是将所有对Handler的访问封装成公有方法 doWork 和 exit:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private class BackgroundThread extends Thread &#123;</span><br><span class="line">   </span><br><span class="line">   private Handler mBackgroundHanlder;</span><br><span class="line">   </span><br><span class="line">   public void run()&#123; //1</span><br><span class="line">      Looper.prepare();</span><br><span class="line">      mBackgroundHanlder=new Hander();//2</span><br><span class="line">      Looper.loop()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void doWork()&#123;</span><br><span class="line">      mBackgroundHanlder.post(new Runnable()&#123;//3</span><br><span class="line">          @Override</span><br><span class="line">          public void run()&#123;</span><br><span class="line">             Message uiMsg=mUiHanlder.obtainMessage(</span><br><span class="line">                SHOW_PROGRESS_BAR,0,0,null);//4</span><br><span class="line">             mUiHanlder.sendMessage(uiMsg);//5</span><br><span class="line">             </span><br><span class="line">             Random r=new Random();</span><br><span class="line">             int randomInt=r.next(5000);</span><br><span class="line">             SystemClock.sleep(randomInt);//6</span><br><span class="line">             </span><br><span class="line">             uiMsg=mUiHanlder.obtainMessage(</span><br><span class="line">                  HIDE_PROGERSSS_BAR,randomInt,0,null);//7</span><br><span class="line">                  mUiHanlder.sendMessage(uiMsg);//8</span><br><span class="line">                </span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">      &#125;);</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void exit()&#123;//9</span><br><span class="line">       mBackgroundHanlder.getLooper().quit()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>将Looper与线程相关联</li>
<li>Handler只处理Runnable.因此,它不需要实现Hanlder.handleMessage.</li>
<li>发出一个需要在后台线程执行的长时间任务</li>
<li>创建一个只包含一个what参数以及一个SHOW_PROGRESS_BAR命令的的消息对象给到UI线程,从而它能够显示进度条.</li>
<li>发送消息到UI线程</li>
<li>模拟一个随机时间长度的长时间任务</li>
<li>创建一个带有randomInt的消息对象,它被传入arg1参数.what参数包含了一个命令-HIDE_PROGRESS_BAR 来移除进度条.</li>
<li>最后消息通知UI线程任务结束了,并分发出一个结果</li>
<li>退出Looper,从而线程能终止</li>
</ol>
<p>UI线程定义了它自己的Hanlder,从而它能接收命令来控制进度条来用来自后台线程的结果来更新ui界.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private final Handler mUiHanlder =new Hanlder() &#123;</span><br><span class="line"></span><br><span class="line">    public void hanldeMessage(Message msg)&#123;</span><br><span class="line">        </span><br><span class="line">        switch(msg.what)&#123;</span><br><span class="line">           case SHOW_PROGRESS_BAR:</span><br><span class="line">             mProgressbar.setVisibility(View.VISIBLE);</span><br><span class="line">             break;</span><br><span class="line">           case HIDE_PROGRESS_BAR:</span><br><span class="line">             mText.setText(String.valueOf(msg.arg1));</span><br><span class="line">             mProgress.setVisibility(View.INVISIBLE)</span><br><span class="line">              break;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>显示进度条</li>
<li>隐藏进度条并用处理好的结果更新TextView</li>
</ol>
<h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p>被Looper分发的消息由Hanlder在消费者线程处理,消息类型决定了处理过程:</p>
<p><em>任务消息</em></p>
<p>消息对象只包含了一个Runnable并且没有数据.因此,处理过程定义在Runnable的在run()方法中,这个过程自动地是在消费者线程执行的,而不用调用Hanlder.handleMessage().</p>
<p><em>数据消息</em></p>
<p>当消息包含数据的时候,Hanlder是数据的接收者并负责对它进行处理.消费者线程以重载hanlder.handleMessage(Message msg) 方法来处理数据.如下所示有两种方式:</p>
<p>其中一种是将定义handlerMessage作为创建Handler的一部分.这个方法应该在消息队列准备好的时候就定义(在Looper.prepare()调用之后)但是在消息获取开始之前(在Looper.loop()被调用之前).</p>
<p>以下是一个设置数据消息处理的模版:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ConsumerThread extends Thread &#123;</span><br><span class="line">    Hanlder mHandler;</span><br><span class="line">    @Overide</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        mHanlder=new Hanlder()&#123;</span><br><span class="line">           public void hanldeMessage(Mssage msg)&#123;</span><br><span class="line">              //Process data message here</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;;) </span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这份代码中, Handler是以匿名内部类的形式定义的,但是它也能够被定义成常规的内部类.</p>
<p>有一种替代扩展Handler类的替代方式是使用Hanlder.Callback.它定义了一个handleMessage()方法以及一个hanlder.hanldeMessage()所有没有的返回参数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Callback&#123;</span><br><span class="line">    public boolean hanldeMessage(Message msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了Callback接口,就没有必要去扩展Hanlder类了.实际上,Callback实现能够被传递到Hanlder构造器中,然后它会接收被分发的消息进行处理:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class HanlderCallbackActivity extends Activity implements Hanlder.Callback &#123;</span><br><span class="line">   Hanlder mUiHanlder;</span><br><span class="line">   </span><br><span class="line">   @Override </span><br><span class="line">   public void onCreate(Bundle savedInstanceState)&#123;</span><br><span class="line">       super.onCreate(savedInstance);</span><br><span class="line">       mUiHanlder=new Hanlder(this);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">   public boolean handleMessage(Message message)&#123;</span><br><span class="line">       //Process messages</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果消息被处理了,Callback.HandleMessage()应该返回true,它保证了消息完成处理后不再进行处理.但是,如果返回了false,消息被传入了Handler.hanldeMessage()方法来进一步处理,它添加了一个消息处理者,这个调用过程在Handler自己的方法之前.Callback 处理者能够在Hanlder接收到消息之前对消息进行拦截和修改.以下的代码展示了用Callback()方法拦截消息的原则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class HanlderCallbackActivity entends Activity implements Hanlder.Callback&#123;//1</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">   public boolean hanldeMessage(Message msg)&#123;//2</span><br><span class="line">       switch(msg.what)&#123;</span><br><span class="line">          case 1:</span><br><span class="line">             msg.what=11;</span><br><span class="line">             return true;</span><br><span class="line">          default:</span><br><span class="line">              msg.what=22;</span><br><span class="line">             return false;    </span><br><span class="line">       &#125; </span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   //Invoked a button click</span><br><span class="line">   </span><br><span class="line">   public void onHanlderCallback(View v)&#123;</span><br><span class="line">       Hanlder hanlder=new Hanlder(this)&#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void handleMessage(Message msg)&#123;</span><br><span class="line">             //Procress message//3</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       handler.sendEmptyMessage(1);//4</span><br><span class="line">       hanlder.sendEmptyMessage(2);//5</span><br><span class="line">         </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>HanlderCallbackActivity 实现了 Callback接口来拦截消息</li>
<li>Callback 实现拦截了消息.如果 msg.what 是1,它就返回true-消息就被处理了.否则的话,它就会将msg.what的值修改为22并返回false,消息没有被处理,所以它被传递到了Hanlder的handle实现.</li>
<li>在第二个Hanlder中处理消息</li>
<li>插入一个msg.what=1的消息,这个消息被Callback拦截并返回true.</li>
<li>插入一个msg.what=2的消息.这个消息被Callback改变然后传递给Hanlder,从属Hanlder 出来的msg=22</li>
</ol>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/线程/" rel="tag"># 线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/23/Flutter/development/add-flutter-to-existing-app/add-to-app/" rel="next" title="(译)添加 Flutter 到已有的应用">
                <i class="fa fa-chevron-left"></i> (译)添加 Flutter 到已有的应用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/19/Android/dependency-injection/" rel="prev" title="(译)Android 中的依赖注入">
                (译)Android 中的依赖注入 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">顽石</p>
              <div class="site-description motion-element" itemprop="description">去油之旅</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">59</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:jinyulei@outlook.com" title="E-Mail &rarr; mailto:jinyulei@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/jinyulei0710" title="Weibo &rarr; https://weibo.com/jinyulei0710" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#例子-基本的消息传递"><span class="nav-number">1.</span> <span class="nav-text">例子: 基本的消息传递</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消息传递所使用的类"><span class="nav-number">2.</span> <span class="nav-text">消息传递所使用的类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MessageQueue"><span class="nav-number">2.1.</span> <span class="nav-text">MessageQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MessageQueue-IdleHandler"><span class="nav-number">2.2.</span> <span class="nav-text">MessageQueue.IdleHandler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例子-使用-Idle-Hanlder-来终止一个不再使用的线程"><span class="nav-number">2.2.1.</span> <span class="nav-text">例子:使用 Idle Hanlder 来终止一个不再使用的线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消息-Message"><span class="nav-number">3.</span> <span class="nav-text">消息(Message)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据消息-Data-Message"><span class="nav-number">3.1.</span> <span class="nav-text">数据消息(Data Message)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务消息-Task-Message"><span class="nav-number">3.2.</span> <span class="nav-text">任务消息(Task Message)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化-Initialized"><span class="nav-number">3.3.</span> <span class="nav-text">初始化(Initialized)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#等待-Pending"><span class="nav-number">3.4.</span> <span class="nav-text">等待(Pending)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#已分发-Dispatched"><span class="nav-number">3.5.</span> <span class="nav-text">已分发(Dispatched)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#已回收-Recycled"><span class="nav-number">3.6.</span> <span class="nav-text">已回收(Recycled)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Looper"><span class="nav-number">4.</span> <span class="nav-text">Looper</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Looper-终止"><span class="nav-number">4.1.</span> <span class="nav-text">Looper 终止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UI-线程-Looper"><span class="nav-number">4.2.</span> <span class="nav-text">UI 线程 Looper</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Handler"><span class="nav-number">5.</span> <span class="nav-text">Handler</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#设置"><span class="nav-number">5.1.</span> <span class="nav-text">设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息创建"><span class="nav-number">5.2.</span> <span class="nav-text">消息创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息插入"><span class="nav-number">5.3.</span> <span class="nav-text">消息插入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#例子-双向消息传递"><span class="nav-number">5.4.</span> <span class="nav-text">例子: 双向消息传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息处理"><span class="nav-number">5.5.</span> <span class="nav-text">消息处理</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">顽石</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.1.1</div>




        





<script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1278706234'%3E%3C/span%3E%3Cscript src='https://s4.cnzz.com/z_stat.php%3Fid%3D1278706234%26show%3Dpic2' type='text/javascript'%3E%3C/script%3E"));</script>

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>




  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  
  
  <script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
              })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1 }))
                .done(function() {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function() {
                  console.log('Failed to create');
                });
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'eHGr88WsRNLEoMuwdgIlCtkE-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'eHGr88WsRNLEoMuwdgIlCtkE-gzGzoHsz',
                'X-LC-Key': 'TYodVy5avzk1wnyVhGU1RCT0',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script>



  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
